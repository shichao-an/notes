<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/apue/ch3/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 3. File I/O - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../github.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../..">Home</a>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                    
                        <li >
                            <a href="../ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                    
                        <li class="active">
                            <a href="./">Chapter 3. File I/O</a>
                        </li>
                    
                        <li >
                            <a href="../ch4/">Chapter 4. Files and Directories</a>
                        </li>
                    
                        <li >
                            <a href="../ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                    
                        <li >
                            <a href="../ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                    
                        <li >
                            <a href="../ch7/">Chapter 7. Process Environment</a>
                        </li>
                    
                        <li >
                            <a href="../ch8/">Chapter 8. Process Control</a>
                        </li>
                    
                        <li >
                            <a href="../ch9/">Chapter 9. Process Relationships</a>
                        </li>
                    
                        <li >
                            <a href="../ch10/">Chapter 10. Signals</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UTLK <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../utlk/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../utlk/ch2/">Chapter 2. Memory Addressing</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch5/">Chapter 5. System Calls</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">ICND <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../icnd1/part1/">ICND1 Part I: Networking Fundamentals</a>
                        </li>
                    
                        <li >
                            <a href="../../icnd2/part1/">ICND2 Part I: LAN Switching</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Others <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../htae/">HTAE</a>
                        </li>
                    
                        <li >
                            <a href="../../golang/">Go</a>
                        </li>
                    
                        <li >
                            <a href="../../bash/">Bash</a>
                        </li>
                    
                        <li >
                            <a href="../../c/">C</a>
                        </li>
                    
                        <li >
                            <a href="../../iptables/">iptables</a>
                        </li>
                    
                        <li >
                            <a href="../../nginx/">Nginx</a>
                        </li>
                    
                        <li >
                            <a href="../../vim/">Vim</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="https://github.com/shichao-an/notes">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-3-file-io">Chapter 3. File I/O</a></li>
        
    
        <li class="main "><a href="#file-descriptors">File Descriptors</a></li>
        
    
        <li class="main "><a href="#open-and-openat-functions">open and openat Functions</a></li>
        
            <li><a href="#tocttou">TOCTTOU</a></li>
        
    
        <li class="main "><a href="#filename-and-pathname-truncation">Filename and Pathname Truncation</a></li>
        
    
        <li class="main "><a href="#creat-function">creat Function</a></li>
        
    
        <li class="main "><a href="#close-function">close Function</a></li>
        
    
        <li class="main "><a href="#lseek-function">lseek Function</a></li>
        
    
        <li class="main "><a href="#read-function">read Function</a></li>
        
    
        <li class="main "><a href="#write-function">write Function</a></li>
        
    
        <li class="main "><a href="#io-efficiency">I/O Efficiency</a></li>
        
    
        <li class="main "><a href="#file-sharing">File Sharing</a></li>
        
            <li><a href="#specific-operations">Specific operations</a></li>
        
            <li><a href="#file-descriptor-flags-vs-the-file-status-flags">File descriptor flags vs. the file status flags</a></li>
        
    
        <li class="main "><a href="#atomic-operations">Atomic Operations</a></li>
        
    
        <li class="main "><a href="#pread-and-pwrite-functions">pread and pwrite Functions</a></li>
        
            <li><a href="#creating-a-file">Creating a File</a></li>
        
    
        <li class="main "><a href="#dup-and-dup2-functions">dup and dup2 Functions</a></li>
        
    
        <li class="main "><a href="#sync-fsync-and-fdatasync-functions">sync, fsync, and fdatasync Functions</a></li>
        
    
        <li class="main "><a href="#fcntl-function">fcntl Function</a></li>
        
            <li><a href="#getting-file-flags">Getting file flags</a></li>
        
            <li><a href="#modifying-file-flags">Modifying file flags</a></li>
        
            <li><a href="#synchronous-write-flag">Synchronous-write flag</a></li>
        
    
        <li class="main "><a href="#ioctl-function">ioctl Function</a></li>
        
    
        <li class="main "><a href="#devfd">/dev/fd</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-3-file-io"><strong>Chapter 3. File I/O</strong></h3>
<p>This chapter discusses unbuffered I/O, which are not part of ISO C but are part of POSIX.1 and the Single UNIX Specification.</p>
<h3 id="file-descriptors">File Descriptors</h3>
<ul>
<li>All open files are referred to by file descriptors</li>
<li>Non-negative integer</li>
<li>Range from 0 to <code>OPEN_MAX - 1</code>. With FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10, the limit is essentially infinite, bounded by the amount of memory on the system, the size of an integer, and any hard and soft limits configured by the system administrator.</li>
</ul>
<h3 id="open-and-openat-functions"><code>open</code> and <code>openat</code> Functions</h3>
<p><small><a href="https://gist.github.com/shichao-an/84b85f42bf03c30fa75b">apue_open.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;fcntl.h&gt;</span>

<span class="kt">int</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oflag</span><span class="p">,</span> <span class="p">...</span> <span class="cm">/* mode_t mode */</span> <span class="p">);</span>
<span class="kt">int</span> <span class="nf">openat</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oflag</span><span class="p">,</span> <span class="p">...</span> <span class="cm">/* mode_t mode */</span> <span class="p">);</span>

<span class="cm">/* Both return: file descriptor if OK, −1 on error */</span>
</pre></div>


<p><code>oflag</code> argument is formed by ORing one or more of the following constants from <code>&lt;fcntl.h&gt;</code> [p62]:</p>
<p>Required:</p>
<ul>
<li><code>O_RDONLY</code></li>
<li><code>O_WRONLY</code></li>
<li><code>O_RDWR</code></li>
<li><code>O_EXEC</code></li>
<li><code>O_SEARCH</code>: Open for search only (applies to directories).</li>
</ul>
<p>Optional:</p>
<ul>
<li><code>O_APPEND</code></li>
<li><code>O_CLOEXEC</code>: Set the <a href="https://www.gnu.org/software/libc/manual/html_node/Descriptor-Flags.html"><code>FD_CLOEXEC</code></a> file descriptor flag</li>
<li><code>O_CREAT</code>: Create the file if it doesn’t exist</li>
<li><code>O_DIRECTORY</code>: Generate an error if <code>O_CREAT</code> is also specified and the file already exists. This test for whether the file already exists and the creation of the file if it doesn’t exist is an atomic operation</li>
<li><code>O_EXCL</code></li>
<li><code>O_NOCTTY</code></li>
<li><code>O_NOFOLLOW</code></li>
<li><code>O_NONBLOCK</code></li>
<li><code>O_SYNC</code>: Have each <code>write</code> wait for physical I/O to complete</li>
<li><code>O_TRUNC</code></li>
<li><code>O_TTY_INIT</code></li>
<li><code>O_DSYNC</code></li>
<li><code>O_RSYNC</code></li>
</ul>
<h4 id="tocttou">TOCTTOU</h4>
<p><code>openat</code>, for example, provides a way to avoid <a href="http://en.wikipedia.org/wiki/Time_of_check_to_time_of_use">time-of-check-to-time-of-use</a> (TOCTTOU) errors. A program is vulnerable if it makes two file-based function calls where the second call depends on the results of the first call (two calls are not atomic).</p>
<h3 id="filename-and-pathname-truncation">Filename and Pathname Truncation</h3>
<p>Most modern file systems support a maximum of 255 characters for filenames.</p>
<h3 id="creat-function"><code>creat</code> Function</h3>
<p><small><a href="https://gist.github.com/shichao-an/e0ac0fe91b023280e33f">apue_creat.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;fcntl.h&gt;</span>

<span class="kt">int</span> <span class="nf">creat</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">mode_t</span> <span class="n">mode</span><span class="p">);</span>

<span class="cm">/* Returns: file descriptor opened for write-only if OK, −1 on error */</span>
</pre></div>


<p>This function is equivalent to:</p>
<div class="codehilite"><pre><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
</pre></div>


<p>With <code>creat</code>, the file is opened only for writing. To read and write a file, use [p66]:</p>
<div class="codehilite"><pre><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
</pre></div>


<h3 id="close-function"><code>close</code> Function</h3>
<p><small><a href="https://gist.github.com/shichao-an/84758a089b6cb82b7495">apue_close.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;unistd.h&gt;</span>

<span class="kt">int</span> <span class="nf">close</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, −1 on error */</span>
</pre></div>


<p>When a process terminates, all of its open files are closed automatically by the kernel. Many programs take advantage of this fact and don’t explicitly close open files.</p>
<h3 id="lseek-function"><code>lseek</code> Function</h3>
<p>Every open file has a "current file offset", normally a non-negative integer that measures the number of bytes from the beginning of the file.</p>
<p><small><a href="https://gist.github.com/shichao-an/b9b0bc7d6dca91b7afd6">apue_lseek.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;unistd.h&gt;</span>

<span class="kt">off_t</span> <span class="nf">lseek</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whence</span><span class="p">);</span>

<span class="cm">/* Returns: new file offset if OK, −1 on error */</span>
</pre></div>


<p>The <em>whence</em> argument can be:</p>
<ul>
<li><code>SEEK_SET</code>: the file’s offset is set to <em>offset</em> bytes from the beginning of the file</li>
<li><code>SEEK_CUR</code>: the file’s offset is set to its current value plus the <em>offset</em>. The <em>offset</em> can be positive or negative.</li>
<li><code>SEEK_END</code>: the file’s offset is set to the size of the file plus the <em>offset</em>. The <em>offset</em> can be positive or negative.</li>
</ul>
<p>To determine the current offset, <u>seek zero bytes from the current position</u>:</p>
<div class="codehilite"><pre><span class="kt">off_t</span> <span class="n">currpos</span><span class="p">;</span>
<span class="n">currpos</span> <span class="o">=</span> <span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_CUR</span><span class="p">);</span>
</pre></div>


<p>This technique (above code) can also be used to determine if a file is capable of seeking. If the file descriptor refers to a pipe, FIFO, or socket, <code>lseek</code> sets <code>errno</code> to <code>ESPIPE</code> and returns −1.</p>
<ul>
<li>Negative offsets are possible for certain devices, but for regular files, the offset must be non-negative.</li>
<li><code>lseek</code> only records the current file offset within the kernel and does not cause any I/O to take place. This offset is then used by the next read or write operation.</li>
<li>Hole in a file: file’s offset can be greater than the file’s current size, in which case the next <code>write</code> to the file will extend the file. This creates a hole in the file.<ul>
<li>Bytes in the hole (bytes that have not been writen) are read back as 0.</li>
<li>A hole in a file isn’t required to have storage backing it on disk.</li>
</ul>
</li>
</ul>
<h3 id="read-function"><code>read</code> Function</h3>
<p><small><a href="https://gist.github.com/shichao-an/ed695671abeb99a2a4b4">apue_read.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;unistd.h&gt;</span>

<span class="kt">ssize_t</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>

<span class="cm">/* Returns: number of bytes read, 0 if end of file, −1 on error */</span>
</pre></div>


<ul>
<li><em>buf</em>: type <code>void *</code> is used for generic pointers.</li>
<li>Return value is required to be a signed integer (<code>ssize_t</code>) to return a positive byte count, 0 (for end of file), or −1 (for an error).</li>
</ul>
<p>Several cases in which the number of bytes actually read is less than the amount requested:</p>
<ul>
<li>Regular file: if the end of file is reached before the requested number of bytes has been read.</li>
<li>Terminal device: up to one line is read at a time</li>
<li>Network: buffering within the network may cause less than the requested amount to be returned</li>
<li>Pipe or FIFO: if the pipe contains fewer bytes than requested, <code>read</code> will return only what is available</li>
<li>Record-oriented device</li>
<li>Interrupted by a signal and a partial amount of data has already been read</li>
</ul>
<h3 id="write-function"><code>write</code> Function</h3>
<p><small><a href="https://gist.github.com/shichao-an/dc05a71e1e7eb4c18a0f">apue_write.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;unistd.h&gt;</span>

<span class="kt">ssize_t</span> <span class="nf">write</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>

<span class="cm">/* Returns: number of bytes written if OK, −1 on error */</span>
</pre></div>


<p>The return value is usually equal to the <em>nbytes</em> argument; otherwise, an error has occurred.</p>
<p>Common causes for a <code>write</code> error:</p>
<ul>
<li>Filling up a disk</li>
<li>Exceeding the file size limit for a given process</li>
</ul>
<p>For a regular file, the write operation starts at the file’s current offset. If the <code>O_APPEND</code> option was specified when the file was opened, the file’s offset is set to the current end of file before each write operation. After a successful write, the file’s offset is incremented by the number of bytes actually written.</p>
<h3 id="io-efficiency">I/O Efficiency</h3>
<ul>
<li><a href="https://github.com/shichao-an/apue.3e/blob/master/fileio/mycat.c">mycat.c</a></li>
</ul>
<div class="codehilite"><pre><span class="cp">#include &quot;apue.h&quot;</span>

<span class="cp">#define BUFFSIZE 4096</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUFFSIZE</span><span class="p">];</span>

    <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUFFSIZE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;write error&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;read error&quot;</span><span class="p">);</span>

    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Caveats of the above program:</p>
<ul>
<li>It reads from standard input and writes to standard output, assuming that these have been set up by the shell before this program is executed.</li>
<li>It doesn’t close the input file or output file. Instead, the program uses the feature of the <u>UNIX kernel that closes all open file descriptors in a process when that process terminates.</u></li>
<li>This example works for both text files and binary files, since there is no difference between the two to the UNIX kernel.</li>
</ul>
<p>Timing results for reading with different buffer sizes (<code>BUFFSIZE</code>) on Linux:</p>
<p><a href="../figure_3.6.png" title="Figure 3.6 Timing results for reading with different buffer sizes on Linux"><img alt="Figure 3.6 Timing results for reading with different buffer sizes on Linux" src="../figure_3.6_600.png" /></a></p>
<p>The file was read using the program shown above, with standard output redirected to <code>/dev/null</code>. The file system used for this test was the Linux ext4 file system with 4,096-byte blocks (the <code>st_blksize</code> value is 4,096). This accounts for the minimum in the system time occurring at the few timing measurements starting around a <code>BUFFSIZE</code> of 4,096. Increasing the buffer size beyond this limit has little positive effect.</p>
<p>Most file systems support some kind of read-ahead to improve performance. When sequential reads are detected, the system tries to read in more data than an application requests, assuming that the application will read it shortly. The effect of read-ahead can be seen in Figure 3.6, where the elapsed time for buffer sizes as small as 32 bytes is as good as the elapsed time for larger buffer sizes. [p73]</p>
<h3 id="file-sharing">File Sharing</h3>
<p>The UNIX System supports the sharing of open files among different processes.</p>
<p><a href="../figure_3.7.png" title="Figure 3.7 Kernel data structures for open files"><img alt="Figure 3.7 Kernel data structures for open files" src="../figure_3.7_600.png" /></a></p>
<p>The kernel uses three data structures to represent an open file, and the relationships among them determine the effect one process has on another with regard to file sharing.</p>
<ul>
<li><strong>Process table entry</strong>: every process has an entry in the process table. Each process table entry has a table of open file descriptors. Associated with each file descriptor are:<ul>
<li><a href="http://www.gnu.org/software/libc/manual/html_node/Descriptor-Flags.html"><strong>File descriptor flags</strong></a> (close-on-exec)</li>
<li>Pointer to a file table entry:</li>
</ul>
</li>
<li><strong>File table entry</strong>: the kernel maintains a file table for all open files. Each file table entry contains:<ul>
<li><a href="http://www.gnu.org/software/libc/manual/html_node/File-Status-Flags.html"><strong>File status flags</strong></a></li>
<li>Current file offset</li>
<li>Pointer to the v-node table entry for the file</li>
</ul>
</li>
<li><strong>v-node</strong> structure: contains information about the type of file and pointers to functions that operate on the file<ul>
<li>This information is read from disk when the file is opened, so that all the pertinent information about the file is readily available</li>
<li>v-node also contains the <strong>i-node</strong> for the file</li>
<li>Linux has no v-node. Instead, a generic i-node structure is used. [p75] Instead of splitting the data structures into a v-node and an i-node, Linux uses a file system–independent i-node and a file system–dependent i-node. [p76]</li>
</ul>
</li>
</ul>
<p><a href="../figure_3.7.png">Figure 3.7</a> shows a pictorial arrangement of these three tables for a single process that has two different files open: one file is open on standard input (file descriptor 0), and the other is open on standard output (file descriptor 1).</p>
<p>If two independent processes have the same file open, we could have the arrangement shown in Figure 3.8 (below).</p>
<p><a href="../figure_3.8.png" title="Figure 3.8 Two independent processes with the same file open"><img alt="Figure 3.8 Two independent processes with the same file open" src="../figure_3.8_600.png" /></a></p>
<p>Each process that opens the file gets its own file table entry, but only a single v-node table entry is required for a given file. One reason <u>each process gets its own file table entry is so that each process has its own current offset for the file.</u></p>
<h4 id="specific-operations">Specific operations</h4>
<ul>
<li>File offset: After each <code>write</code> is complete, the current file offset in the file table entry is incremented by the number of bytes written. If this causes the current file offset to exceed the current file size, the current file size in the i-node table entry is set to the current file offset (the file is extended).</li>
<li><code>O_APPEND</code>: If a file is opened with the <code>O_APPEND</code> flag, a corresponding flag is set in the file status flags of the file table entry. Each time a <code>write</code> is performed for a file with this append flag set, the current file offset in the file table entry is first set to the current file size from the i-node table entry. Th is forces every <code>write</code> to be appended to the current end of file.</li>
<li><code>lseek</code><ul>
<li>If a file is positioned to its current end of file using <code>lseek</code>, all that happens is the current file offset in the file table entry is set to the current file size from the i-node table entry. <u>This is not the same as if the file was opened with the <code>O_APPEND</code> flag.</u></li>
<li>The <code>lseek</code> function modifies only the current file offset in the file table entry. No I/O takes place.</li>
</ul>
</li>
</ul>
<p>It is possible for more than one file descriptor entry to point to the same file table entry:</p>
<ul>
<li><code>dup</code></li>
<li><code>fork</code>: the parent and the child share the same file table entry for each open descriptor</li>
</ul>
<h4 id="file-descriptor-flags-vs-the-file-status-flags">File descriptor flags vs. the file status flags</h4>
<ul>
<li>File descriptor flags: apply only to a single descriptor in a single process</li>
<li>File status flags: apply to all descriptors in any process that point to the given file table entry</li>
<li><code>fcntl</code> is used to fetch and modify both of them</li>
</ul>
<h3 id="atomic-operations">Atomic Operations</h3>
<p>Older versions of the UNIX System didn’t support the <code>O_APPEND</code> option if a single process wants to append to the end of a file. The program would be:</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="p">(</span><span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0L</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* position to EOF, 2 means SEEK_END */</span>
    <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;lseek error&quot;</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">100</span><span class="p">)</span> <span class="cm">/* and write */</span>
    <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;write error&quot;</span><span class="p">);</span>
</pre></div>


<p>This works fine for a single process, but problems arise if multiple processes (or multiple instances of the same program) use this technique to append to the same file. The problem here is that our logical operation of "position to the end of file and write" requires two separate function calls. The solution is to have the positioning to the current end of file and the write be an atomic operation with regard to other processes. Any operation that requires more than one function call cannot be atomic, as there is always the possibility that the kernel might temporarily suspend the process between the two function calls. The UNIX System provides an atomic way to do this operation if we set the <code>O_APPEND</code> flag when a file is opened. This causes the kernel to position the file to its current end of file before each <code>write</code>. We no longer have to call lseek before each <code>write</code>.</p>
<h3 id="pread-and-pwrite-functions"><code>pread</code> and <code>pwrite</code> Functions</h3>
<p>The Single UNIX Specification includes two functions that allow applications to seek and perform I/O atomically:</p>
<p><small><a href="https://gist.github.com/shichao-an/2f2fb4d9288fd1fa79b3">apue_pread.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;unistd.h&gt;</span>

<span class="kt">ssize_t</span> <span class="nf">pread</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">);</span>
<span class="cm">/* Returns: number of bytes read, 0 if end of file, −1 on error */</span>

<span class="kt">ssize_t</span> <span class="nf">pwrite</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">);</span>
<span class="cm">/* Returns: number of bytes written if OK, −1 on error */</span>
</pre></div>


<ul>
<li><code>pread</code>: equivalent to calling <code>lseek</code> followed by a call to <code>read</code>, with the following exceptions:<ul>
<li>There is no way to interrupt the two operations that occur calling <code>pread</code>.</li>
<li>The current file offset is not updated.</li>
</ul>
</li>
<li><code>pwrite</code>:  equivalent to calling lseek followed by a call to write, with similar exceptions to <code>pread</code>.</li>
</ul>
<h4 id="creating-a-file">Creating a File</h4>
<h5 id="atomic-operation"><strong>Atomic operation</strong></h5>
<p>When both of <code>O_CREAT</code> and <code>O_EXCL</code> options are specified, the <code>open</code> will fail if the file already exists. The check for the existence of the file and the creation of the file was performed as an atomic operation.</p>
<h5 id="non-atomic-operation"><strong>Non-atomic operation</strong></h5>
<p>If we didn’t have this atomic operation, we might try:</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="p">((</span><span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">fd</span> <span class="o">=</span> <span class="n">creat</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;creat error&quot;</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;open error&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The problem occurs if the file is created by another process between the <code>open</code> and the <code>creat</code>. If the file is created by another process between these two function calls, and if that other process writes something to the file, that data is erased when this <code>creat</code> is executed. Combining the test for existence and the creation into a single atomic operation avoids this problem.</p>
<p><strong>Atomic operation</strong> refers to an operation that might be composed of multiple steps. <u>If the operation is performed atomically, either all the steps are performed (on success) or none are performed (on failure). It must not be possible for only a subset of the steps to be performed.</u></p>
<h3 id="dup-and-dup2-functions"><code>dup</code> and <code>dup2</code> Functions</h3>
<p>An existing file descriptor is duplicated by either of the following functions:</p>
<p><small><a href="https://gist.github.com/shichao-an/7f7dfbcf28d77d8cff67">apue_dup.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;unistd.h&gt;</span>

<span class="kt">int</span> <span class="nf">dup</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">dup2</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd2</span><span class="p">);</span>

<span class="cm">/* Both return: new file descriptor if OK, −1 on error */</span>
</pre></div>


<ul>
<li><code>dup</code>: return the new file descriptor, which is guaranteed to be the lowest-numbered available file descriptor</li>
<li><code>dup2</code>: <em>fd2</em> argument is the new file descriptor we specifiy.<ul>
<li>If <em>fd2</em> is already open, it is first closed</li>
<li>If <em>fd</em> equals <em>fd2</em>, then <code>dup2</code> returns <em>fd2</em> without closing it. Otherwise, the <code>FD_CLOEXEC</code> file descriptor flag is cleared for <em>fd2</em>, so that <em>fd2</em> is left open if the process calls <code>exec</code>.</li>
</ul>
</li>
</ul>
<p>Kernel data structures after <code>dup(1)</code>:</p>
<p><a href="../figure_3.9.png" title="Figure 3.9 Kernel data structures after dup(1)"><img alt="Figure 3.9 Kernel data structures after dup(1)" src="../figure_3.9_600.png" /></a></p>
<p>In the above figure, we assume the process executes:</p>
<div class="codehilite"><pre><span class="n">newfd</span> <span class="o">=</span> <span class="n">dup</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</pre></div>


<ul>
<li>Because both descriptors point to the same file table entry, they share the same file status flags (e.g. read, write, append) and the same current file offset.</li>
<li>Each descriptor has its own set of file descriptor flags</li>
</ul>
<p>Another way to duplicate a descriptor is with the <code>fcntl</code> function:</p>
<div class="codehilite"><pre><span class="n">dup</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_DUPFD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>


<p>Similarly, the call</p>
<div class="codehilite"><pre><span class="n">dup2</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">fd2</span><span class="p">);</span>
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span class="n">close</span><span class="p">(</span><span class="n">fd2</span><span class="p">);</span>
<span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_DUPFD</span><span class="p">,</span> <span class="n">fd2</span><span class="p">);</span>
</pre></div>


<p>In this last case (above), the <code>dup2</code> is not exactly the same as a <code>close</code> followed by an <code>fcntl</code>:</p>
<ol>
<li><code>dup2</code> is an atomic operation, whereas the alternate form involves two function calls. It is possible in the latter case to have a signal catcher called between the <code>close</code> and the <code>fcntl</code> that could modify the file descriptors. The same problem could occur if a different thread changes the file descriptors.</li>
<li>There are some <code>errno</code> differences between <code>dup2</code> and <code>fcntl</code>.</li>
</ol>
<h3 id="sync-fsync-and-fdatasync-functions"><code>sync</code>, <code>fsync</code>, and <code>fdatasync</code> Functions</h3>
<p>Traditional implementations of the UNIX System have a buffer cache or page cache in the kernel through which most disk I/O passes.</p>
<ul>
<li><strong>Delayed write</strong>: when we write data to a file, the data is normally copied by the kernel into one of its buffers and queued for writing to disk at some later time</li>
</ul>
<p>The kernel eventually writes all the delayed-write blocks to disk, normally when it needs to reuse the buffer for some other disk block. To ensure consistency of the file system on disk with the contents of the buffer cache, the <code>sync</code>, <code>fsync</code>, and <code>fdatasync</code> functions are provided.</p>
<p><small><a href="https://gist.github.com/shichao-an/2b0c9e36de750eb9de05">apue_fsync.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;unistd.h&gt;</span>

<span class="kt">int</span> <span class="nf">fsync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">fdatasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, −1 on error */</span>

<span class="kt">void</span> <span class="nf">sync</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>


<ul>
<li><code>sync</code>: queues all the modified block buffers for writing and returns. It does not wait for the disk writes to take place<ul>
<li><code>sync</code> is normally called periodically (usually every 30 seconds) from a system daemon, often called <code>update</code>, which guarantees regular flushing of the kernel’s block buffers. The command <code>sync(1)</code> also calls the <code>sync</code> function.</li>
</ul>
</li>
<li><code>fsync</code>: applies to a single file specified by the file descriptor <em>fd</em>, and waits for the disk writes to complete before returning.<ul>
<li><code>fsync</code> also updates the file's attributes synchronously</li>
</ul>
</li>
<li><code>fdatasync</code>: similar to <code>fsync</code>, but it affects only the data portions of a file.</li>
</ul>
<h3 id="fcntl-function"><code>fcntl</code> Function</h3>
<p>The <code>fcntl</code> function can change the properties of a file that is already open.</p>
<p><small><a href="https://gist.github.com/shichao-an/45ca16d52791e4ab773d">apue_fcntl.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;fcntl.h&gt;</span>

<span class="kt">int</span> <span class="nf">fcntl</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">...</span> <span class="cm">/* int arg */</span> <span class="p">);</span>

<span class="cm">/* Returns: depends on cmd if OK (see following), −1 on error */</span>
</pre></div>


<p>In this section, the third argument of <code>fcntl</code> is always an integer, corresponding to the comment in the function prototype just shown.</p>
<p>The <code>fcntl</code> function is used for five different purposes:</p>
<ol>
<li>Duplicate an existing descriptor (<em>cmd</em> = <code>F_DUPFD</code> or <code>F_DUPFD_CLOEXEC</code>)</li>
<li>Get/set file descriptor flags (<em>cmd</em> = <code>F_GETFD</code> or <code>F_SETFD</code>)</li>
<li>Get/set file status flags (<em>cmd</em> = <code>F_GETFL</code> or <code>F_SETFL</code>)</li>
<li>Get/set asynchronous I/O ownership (<em>cmd</em> = <code>F_GETOWN</code> or <code>F_SETOWN</code>)</li>
<li>Get/set record locks (<em>cmd</em> = <code>F_GETLK</code>, <code>F_SETLK</code>, or <code>F_SETLKW</code>)</li>
</ol>
<p>The following text discusses both the file descriptor flags associated with each file descriptor in the process table entry and the file status flags associated with each file table entry.</p>
<ul>
<li><code>F_DUPFD</code>: Duplicate the file descriptor <em>fd</em>. The new file descriptor, which is the lowest-numbered descriptor that is not already open and is greater than or equal to the third argument (integer), is returned as the value of the function. The new descriptor has its own set of file descriptor flags with <code>FD_CLOEXEC</code> cleared.
cleared.</li>
<li><code>F_DUPFD_CLOEXEC</code>: Duplicate the file descriptor and set the <code>FD_CLOEXEC</code> file descriptor flag associated with the new descriptor.</li>
<li><code>F_GETFD</code>: Return the file descriptor flags for <em>fd</em>. Currently, only one file descriptor flag (<code>FD_CLOEXEC</code>) is defined.</li>
<li><code>F_SETFD</code>: Set the file descriptor flags for <em>fd</em>. The new flag value is set from the third argument.<ul>
<li>Some existing programs don’t use constant <code>FD_CLOEXEC</code>. Instead, these programs set the flag to either 0 (don’t close-on-exec, the default) or 1 (do close-on-exec).</li>
</ul>
</li>
<li>
<p><code>F_GETFL</code>: Return the file status flags for <em>fd</em>. The file status flags were described with the <code>open</code> function.</p>
<ul>
<li>The five access-mode flags (<code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code>, <code>O_EXEC</code>, and <code>O_SEARCH</code>) are not separate bits that can be tested.</li>
<li><code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code> often have the values 0, 1, and 2, respectively</li>
<li><u>The five access-mode flags are mutually exclusive: this means a file can have only one of them enabled.</u></li>
<li><u>We must first use the <code>O_ACCMODE</code> mask to obtain the access-mode bits and then compare the result against any of the five values.</u></li>
</ul>
<table>
<thead>
<tr>
<th>File status flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O_RDONLY</code></td>
<td>open for reading only</td>
</tr>
<tr>
<td><code>O_WRONLY</code></td>
<td>open for writing only</td>
</tr>
<tr>
<td><code>O_RDWR</code></td>
<td>open for reading and writing</td>
</tr>
<tr>
<td><code>O_EXEC</code></td>
<td>open for execute only</td>
</tr>
<tr>
<td><code>O_SEARCH</code></td>
<td>open directory for searching only</td>
</tr>
<tr>
<td><code>O_APPEND</code></td>
<td>append on each write</td>
</tr>
<tr>
<td><code>O_NONBLOCK</code></td>
<td>nonblocking mode</td>
</tr>
<tr>
<td><code>O_SYNC</code></td>
<td>wait for writes to complete (data and attributes)</td>
</tr>
<tr>
<td><code>O_DSYNC</code></td>
<td>wait for writes to complete (data only)</td>
</tr>
<tr>
<td><code>O_RSYNC</code></td>
<td>synchronize reads and writes</td>
</tr>
<tr>
<td><code>O_FSYNC</code></td>
<td>wait for writes to complete (FreeBSD and Mac OS X only)</td>
</tr>
<tr>
<td><code>O_ASYNC</code></td>
<td>asynchronous I/O (FreeBSD and Mac OS X only)</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><code>F_SETFL</code>: Set the file status flags to the value of the third argument (integer). The only flags that can be changed are:</p>
<ul>
<li><code>O_APPEND</code></li>
<li><code>O_NONBLOCK</code></li>
<li><code>O_SYNC</code></li>
<li><code>O_DSYNC</code></li>
<li><code>O_RSYNC</code></li>
<li><code>O_FSYNC</code></li>
<li><code>O_ASYNC</code></li>
</ul>
</li>
<li><code>F_GETOWN</code>: Get the process ID or process group ID currently receiving the <code>SIGIO</code> and <code>SIGURG</code> signals.</li>
<li><code>F_SETOWN</code>: Set the process ID or process group ID to receive the <code>SIGIO</code> and <code>SIGURG</code> signals.</li>
</ul>
<p>The return value from <code>fcntl</code> depends on the command. All commands return −1 on an error or some other value if OK. The following four commands have special return values:</p>
<ul>
<li><code>F_DUPFD</code>: returns the new file descriptor</li>
<li><code>F_GETFD</code>: returns the file descriptor flags</li>
<li><code>F_GETFL</code>: returns the file status flags</li>
<li><code>F_GETOWN</code>: returns a positive process ID or a negative process group ID</li>
</ul>
<h4 id="getting-file-flags">Getting file flags</h4>
<p>Example:</p>
<ul>
<li><a href="https://github.com/shichao-an/apue.3e/blob/master/fileio/fileflags.c">fileflags.c</a></li>
</ul>
<div class="codehilite"><pre><span class="cp">#include &quot;apue.h&quot;</span>
<span class="cp">#include &lt;fcntl.h&gt;</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">err_quit</span><span class="p">(</span><span class="s">&quot;usage: a.out &lt;descriptor#&gt;&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">F_GETFL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;fcntl error for fd %d&quot;</span><span class="p">,</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">O_RDONLY</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;read only&quot;</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">O_WRONLY</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;write only&quot;</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">O_RDWR</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;read write&quot;</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="n">err_dump</span><span class="p">(</span><span class="s">&quot;unknown access mode&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">O_APPEND</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, append&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, nonblocking&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">O_SYNC</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, synchronous writes&quot;</span><span class="p">);</span>

<span class="cp">#if !defined(_POSIX_C_SOURCE) &amp;&amp; defined(O_FSYNC) &amp;&amp; (O_FSYNC != O_SYNC)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">O_FSYNC</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, synchronous writes&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

    <span class="n">putchar</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Results:</p>
<div class="codehilite"><pre><span class="nv">$ </span>./a.out <span class="m">0</span> &lt; /dev/tty
<span class="nb">read </span>only
<span class="nv">$ </span>./a.out <span class="m">1</span> &gt; temp.foo
<span class="nv">$ </span>cat temp.foo
write only
<span class="nv">$ </span>./a.out <span class="m">2</span> 2&gt;&gt;temp.foo
write only, append
<span class="nv">$ </span>./a.out <span class="m">5</span> 5&lt;&gt;temp.foo
<span class="nb">read </span>write
</pre></div>


<h4 id="modifying-file-flags">Modifying file flags</h4>
<p>To modify either the file descriptor flags or the file status flags, we must be careful to fetch the existing flag value, modify it as desired, and then set the new flag value. We can’t simply issue an <code>F_SETFD</code> or an <code>F_SETFL</code> command, as this could turn off flag bits that were previously set.</p>
<p>Example:</p>
<div class="codehilite"><pre><span class="cp">#include &quot;apue.h&quot;</span>
<span class="cp">#include &lt;fcntl.h&gt;</span>

<span class="kt">void</span>
<span class="nf">set_fl</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="cm">/* flags are file status flags to turn on */</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_GETFL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;fcntl F_GETFL error&quot;</span><span class="p">);</span>
    <span class="n">val</span> <span class="o">|=</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* turn on flags */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;fcntl F_SETFL error&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>If we change the middle statement to</p>
<div class="codehilite"><pre><span class="n">val</span> <span class="o">&amp;=</span> <span class="err">˜</span><span class="n">flags</span><span class="p">;</span> <span class="cm">/* turn flags off */</span>
</pre></div>


<p>we have a function named <code>clr_fl</code>,  logically ANDs the one’s complement of <code>flags</code> with the current <code>val</code>.</p>
<h4 id="synchronous-write-flag">Synchronous-write flag</h4>
<p>If we add the line</p>
<div class="codehilite"><pre><span class="n">set_fl</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">O_SYNC</span><span class="p">);</span>
</pre></div>


<p>to the beginning of the program shown in <a href="#io-efficiency">I/O Efficiency section</a>, we’ll turn on the synchronous-write flag. This causes each write to wait for the data to be written to disk before returning. Normally in the UNIX System, <u>a <code>write</code> only queues the data for writing; the actual disk write operation can take place sometime later.</u> A database system is a likely candidate for using <code>O_SYNC</code>, so that it knows on return from a write that the data is actually on the disk, in case of an abnormal system failure.</p>
<p>Linux ext4 timing results using various synchronization mechanisms [p86]</p>
<p>Mac OS X HFS timing results using various synchronization mechanisms [p87]</p>
<p>The <a href="#modifying-file-flags">above program</a> operates on a descriptor (standard output), never knowing the name of the file that was opened on that descriptor. We can’t set the <code>O_SYNC</code> flag when the file is opened, since the shell opened the file. With <code>fcntl</code>, we can modify the properties of a descriptor, knowing only the descriptor for the open file.</p>
<h3 id="ioctl-function"><code>ioctl</code> Function</h3>
<p><small><a href="https://gist.github.com/shichao-an/26d278ca768f90e8c67a">apue_ioctl.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;unistd.h&gt; </span><span class="cm">/* System V */</span><span class="cp"></span>
<span class="cp">#include &lt;sys/ioctl.h&gt; </span><span class="cm">/* BSD and Linux */</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">ioctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">request</span><span class="p">,</span> <span class="p">...);</span>

<span class="cm">/* Returns: −1 on error, something else if OK */</span>
</pre></div>


<p>The <code>ioctl</code> function has always been the catchall for I/O operations. Anything that couldn’t be expressed using one of the other functions in this chapter usually ended up being specified with an <code>ioctl</code>. Terminal I/O was the biggest user of this function.</p>
<p>For the ISO C prototype, an ellipsis is used for the remaining arguments. Normally, however, there is only one more argument, and it’s usually a pointer to a variable or a structure.</p>
<p>Each device driver can define its own set of <code>ioctl</code> commands. The system, however, provides generic ioctl commands for different classes of devices.</p>
<p>We use the <code>ioctl</code> function in Section 18.12 to fetch and set the size of a terminal’s window, and in Section 19.7 when we access the advanced features of pseudo terminals.</p>
<h3 id="devfd"><code>/dev/fd</code></h3>
<p>Newer systems provide a directory named <code>/dev/fd</code> whose entries are files named 0, 1, 2, and so on. Opening the file <code>/dev/fd/n</code> is equivalent to duplicating descriptor <em>n</em>, assuming that descriptor <em>n</em> is open. <code>/dev/fd</code> is not part of POSIX.1.</p>
<p>The following are equivalent:</p>
<div class="codehilite"><pre><span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&quot;/dev/fd/0&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="n">fd</span> <span class="o">=</span> <span class="n">dup</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>


<p>Most systems ignore the specified <code>mode</code>, whereas others require that it be a subset of the mode used when the referenced file (standard input, in this case) was originally opened. The descriptors 0 and <code>fd</code> <a href="../figure_3.9.png">share the same file table entry</a>.</p>
<p>The Linux implementation of <code>/dev/fd</code> is an exception. It maps file descriptors into symbolic links pointing to the underlying physical files. When you open <code>/dev/fd/0</code>, for example, you are really opening the file associated with your standard input. Thus the mode of the new file descriptor returned is unrelated to the mode of the <code>/dev/fd</code> file descriptor.</p>
<p>We can also call <code>creat</code> with a <code>/dev/fd</code> pathname argument as well as specify <code>O_CREAT</code> in a call to open. This allows a program that calls <code>creat</code> to still work if the pathname argument is <code>/dev/fd/1</code>, for example.</p>
<p>Some systems provide the pathnames <code>/dev/stdin</code>, <code>/dev/stdout</code>, and <code>/dev/stderr</code>. These pathnames are equivalent to <code>/dev/fd/0</code>, <code>/dev/fd/1</code>, and <code>/dev/fd/2</code>, respectively.</p>
<p>The main use of the <code>/dev/fd</code> files is from the shell. It allows programs that use pathname arguments to handle standard input and standard output in the same manner as other pathnames.</p>
<p>The following are equivalent:</p>
<div class="codehilite"><pre>filter file2 <span class="p">|</span> cat file1 - file3 <span class="p">|</span> lpr
filter file2 <span class="p">|</span> cat file1 /dev/fd/0 file3 <span class="p">|</span> lpr
</pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>