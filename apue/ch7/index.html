<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/apue/ch7/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 7. Process Environment - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                    
                      
                        <li class="active">
                            <a href="./">Chapter 7. Process Environment</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch10/">Chapter 10. Signals</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch11/">Chapter 11. Threads</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../lkd/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch5/">Chapter 5. System Calls</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch7/">Chapter 7. Interrupts and Interrupt Handlers</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch8/">Chapter 8. Bottom Halves and Deferring Work</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch9/">Chapter 9. An Introduction to Kernel Synchronization</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch10/">Chapter 10. Kernel Synchronization Methods</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch11/">Chapter 11. Timers and Time Management</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch12/">Chapter 12. Memory Management</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch13/">Chapter 13. The Virtual Filesystem</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch14/">Chapter 14. The Block I/O Layer</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch15/">Chapter 15. The Process Address Space</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch16/">Chapter 16. The Page Cache and Page Writeback</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            
            
            
            
            
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../gopl/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../gopl/ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../gopl/ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../gopl/ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../gopl/ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../gopl/ch5/">Chapter 5. Functions</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../gopl/ch6/">Chapter 6. Methods</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../gopl/ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">PER <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../per/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../per/ch1/">Chapter 1. A Tutorial Introduction</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../per/ch6/">Chapter 6. Functions and Functional Programming</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TWGR <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../twgr/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../twgr/ch1/">Chapter 1. Bootstrapping your Ruby literacy</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../twgr/ch2/">Chapter 2. Objects, methods, and local variables</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            
            
            
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">SPEC <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../spec/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../spec/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../spec/ch2/">Chapter 2. Methodology</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../spec/ch3/">Chapter 3. Operating Systems</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">BD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../bd/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../bd/ch1/">Chapter 1. A new paradigm for Big Data</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../bd/ch2/">Chapter 2. Data model for Big Data</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../bd/ch3/">Chapter 3. Data model for Big Data: Illustration</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            
            
            
            
            
            
            
            
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/apue/ch7.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-7-process-environment">Chapter 7. Process Environment</a></li>
        
    
        <li class="main "><a href="#introduction">Introduction</a></li>
        
    
        <li class="main "><a href="#main-function">main Function</a></li>
        
    
        <li class="main "><a href="#process-termination">Process Termination</a></li>
        
            <li><a href="#exit-functions">Exit Functions</a></li>
        
            <li><a href="#atexit-function">atexit Function</a></li>
        
    
        <li class="main "><a href="#command-line-arguments">Command-Line Arguments</a></li>
        
    
        <li class="main "><a href="#environment-list">Environment List</a></li>
        
    
        <li class="main "><a href="#memory-layout-of-a-c-program">Memory Layout of a C Program</a></li>
        
    
        <li class="main "><a href="#shared-libraries">Shared Libraries</a></li>
        
    
        <li class="main "><a href="#memory-allocation">Memory Allocation</a></li>
        
            <li><a href="#alternate-memory-allocators">Alternate Memory Allocators</a></li>
        
    
        <li class="main "><a href="#environment-variables">Environment Variables</a></li>
        
    
        <li class="main "><a href="#setjmp-and-longjmp-functions">setjmp and longjmp Functions</a></li>
        
            <li><a href="#automatic-register-and-volatile-variables">Automatic, Register, and Volatile Variables</a></li>
        
            <li><a href="#potential-problem-with-automatic-variables">Potential Problem with Automatic Variables</a></li>
        
    
        <li class="main "><a href="#getrlimit-and-setrlimit-functions">getrlimit and setrlimit Functions</a></li>
        
    
        <li class="main "><a href="#summary">Summary</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-7-process-environment"><strong>Chapter 7. Process Environment</strong></h3>
<h3 id="introduction">Introduction</h3>
<h3 id="main-function"><code>main</code> Function</h3>
<p>A C program starts execution with a function called <code>main</code>:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]);</span>
</pre></div>


<ul>
<li><em>argc</em>: number of command-line arguments</li>
<li><em>argv</em>: an array of pointers to the arguments</li>
</ul>
<p>When a C program is executed by the kernel (by one of the <code>exec</code> functions), a special start-up routine is called before the <code>main</code> function is called. The executable program file specifies this routine as the starting address for the program; this is set up by the link editor (linker) when it is invoked by the C compiler. This start-up routine takes values from the kernel (the command-line arguments and the environment) and sets things up so that the <code>main</code> function is called as shown earlier.</p>
<h3 id="process-termination">Process Termination</h3>
<p>There are eight ways for a process to terminate.</p>
<ul>
<li>
<p>Normal termination occurs in five ways:</p>
<ol>
<li>Return from <code>main</code></li>
<li>Calling <code>exit</code></li>
<li>Calling <code>_exit</code> or <code>_Exit</code></li>
<li>Return of the last thread from its start routine (Section 11.5)</li>
<li>Calling <code>pthread_exit</code> (Section 11.5) from the last thread</li>
</ol>
</li>
<li>
<p>Abnormal termination occurs in three ways:</p>
<ol>
<li>Calling <code>abort</code> (Section 10.17)</li>
<li>Receipt of a signal (Section 10.2)</li>
<li>Response of the last thread to a cancellation request (Sections 11.5 and 12.7)</li>
</ol>
</li>
</ul>
<h4 id="exit-functions">Exit Functions</h4>
<p>Three functions terminate a program normally:</p>
<p><small><a href="https://gist.github.com/shichao-an/8387fdff1497e1cc7fd6">apue_exit.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">void</span> <span class="nf">exit</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">_Exit</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">);</span>

<span class="cp">#include &lt;unistd.h&gt;</span>

<span class="kt">void</span> <span class="nf">_exit</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">);</span>
</pre></div>


<ul>
<li><code>_exit</code>: returns to the kernel immediately</li>
<li><code>_Exit</code>: same as <code>_exit</code></li>
<li><code>exit</code>: performs certain cleanup processing and then returns to the kernel. Historically, it has always performed a clean shutdown of the standard I/O library: the <code>fclose</code> function is called for all open streams</li>
</ul>
<p>All three exit functions expect a single integer argument (<strong>exit status</strong>).</p>
<p>The <u>exit status of the process is undefined</u>, if any of the following occurs:</p>
<ul>
<li>Any of these functions is called without an exit status</li>
<li><code>main</code> does a return without a return value</li>
<li><code>main</code> function is not declared to return an integer</li>
</ul>
<p>If the return type of main is an integer and main "falls off the end" (an implicit return), the exit status of the process is 0.</p>
<p>Returning an integer value from the main function is equivalent to calling exit with the same value:</p>
<p><code>exit(0);</code> is same as <code>return(0);</code> from the <code>main</code> function.</p>
<h4 id="atexit-function"><code>atexit</code> Function</h4>
<p>With ISO C, a process can register at least 32 functions that are automatically called by <code>exit</code>. These are called <strong>exit handlers</strong> and are registered by calling the <code>atexit</code> function.</p>
<p><small><a href="https://gist.github.com/shichao-an/edfab5a8a91b62b4ba5b">apue_atexit.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">atexit</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">void</span><span class="p">));</span>

<span class="cm">/* Returns: 0 if OK, nonzero on error */</span>
</pre></div>


<ul>
<li><em>func</em> argument is the address of the function to be called by <code>exit</code>. When this function is called, it is not passed any arguments and is not expected to return a value. The <code>exit</code> function calls these functions in reverse order of their registration. Each function is called as many times as it was registered.</li>
</ul>
<p>With ISO C and POSIX.1, <code>exit</code> first calls the exit handlers and then closes (via <code>fclose</code>) all open streams. POSIX.1 extends the ISO C standard by specifying that any exit handlers installed will be cleared if the program calls any of the <code>exec</code> family of functions.</p>
<p>The only way a program can be executed by the kernel is if one of the <code>exec</code> functions is called. <u>The only way a process can voluntarily terminate is if <code>_exit</code> or <code>_Exit</code> is called</u>, either explicitly or implicitly (by calling <code>exit</code>). A process can also be involuntarily terminated by a signal.</p>
<h3 id="command-line-arguments">Command-Line Arguments</h3>
<p>When a program is executed, the process that does the <code>exec</code> can pass command-line arguments to the new program. This is part of the normal operation of the UNIX system shells.</p>
<p>Example:</p>
<div class="codehilite"><pre><span class="cp">#include &quot;apue.h&quot;</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="cm">/* echo all command-line args */</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;argv[%d]: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>We are guaranteed by both ISO C and POSIX.1 that argv[argc] is a null pointer. This lets us alternatively code the argument-processing loop as:</p>
<div class="codehilite"><pre><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</pre></div>


<h3 id="environment-list">Environment List</h3>
<p>Each program is also passed an environment list, which is an array of character pointers, with each pointer containing the address of a null-terminated C string. It is contained in the global variable environ:</p>
<div class="codehilite"><pre><span class="k">extern</span> <span class="kt">char</span> <span class="o">**</span><span class="n">environ</span><span class="p">;</span>
</pre></div>


<p><a href="../figure_7.5.png" title="Figure 7.5 Environment consisting of five C character strings"><img alt="Figure 7.5 Environment consisting of five C character strings" src="../figure_7.5_600.png" /></a></p>
<ul>
<li><code>environ</code> is called the <strong>environment pointer</strong>, the array of pointers the environment list, and the strings they point to the <strong>environment strings</strong>, which by convention is <code>name=value</code> strings. By convetion, predefined names are entirely uppercase.</li>
</ul>
<h3 id="memory-layout-of-a-c-program">Memory Layout of a C Program</h3>
<p>Historically, a C program has been composed of the following pieces:</p>
<ul>
<li>Text segment: consists of the machine instructions that the CPU executes</li>
<li>Initialized data segment (or simply data segment): contains variables that are specifically initialized in the program</li>
<li>Uninitialized data segment (often called the "bss" segment, which is named after "block started by symbol"): data in this segment is initialized by the kernel to arithmetic 0 or null pointers before the program starts executing</li>
<li>Stack: stores automatic variables, along with information that is saved each time a function is called</li>
<li>Heap is where dynamic memory allocation usually takes place</li>
</ul>
<p><a href="../figure_7.6.png" title="Figure 7.5 Environment consisting of five C character strings"><img alt="Figure 7.5 Environment consisting of five C character strings" src="../figure_7.6.png" /></a></p>
<p>With Linux on a 32-bit Intel x86 processor, the text segment starts at location <code>0x08048000</code>, and the bottom of the stack starts just below <code>0xC0000000</code>. <u>The stack grows from higher-numbered addresses to lower-numbered addresses on this particular architecture.</u> The unused virtual address space between the top of the heap and the top of the stack is large</p>
<p>The <code>size(1)</code> command reports the sizes (in bytes) of the text, data, and bss segments:</p>
<div class="codehilite"><pre><span class="nv">$ </span>size /usr/bin/cc /bin/sh
text data bss dec hex filename
<span class="m">346919</span> <span class="m">3576</span> <span class="m">6680</span> <span class="m">357175</span> <span class="m">57337</span> /usr/bin/cc
<span class="m">102134</span> <span class="m">1776</span> <span class="m">11272</span> <span class="m">115182</span> 1c1ee /bin/sh
</pre></div>


<h3 id="shared-libraries">Shared Libraries</h3>
<p>Shared libraries remove the common library routines from the executable file and maintains a single copy of the library routine somewhere in memory that all processes reference:</p>
<ul>
<li>Pros: reduces the size of each executable file; library functions can be replaced with new versions without having to relink edit every program that uses the library</li>
<li>Cons: adds some runtime overhead, either when the program is first executed or the first time each shared library function is called</li>
</ul>
<h3 id="memory-allocation">Memory Allocation</h3>
<p><small><a href="https://gist.github.com/shichao-an/e4b320547e3c303af467">apue_malloc.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">calloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">nobj</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">realloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">newsize</span><span class="p">);</span>

<span class="cm">/* All three return: non-null pointer if OK, NULL on error */</span>

<span class="kt">void</span> <span class="nf">free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
</pre></div>


<ul>
<li><code>malloc</code>: allocates a specified number of bytes of memory</li>
<li><code>calloc</code>: allocates space for a specified number of objects of a specified size</li>
<li><code>realloc</code>: increases or decreases the size of a previously allocated area. The final argument to realloc is the new size of the region, not the
difference between the old and new sizes</li>
</ul>
<p>The pointer returned by the three allocation functions is guaranteed to be suitably aligned so that it can be used for any data object.</p>
<p>Because the three <code>alloc</code> functions return a generic <code>void *</code> pointer, if we <code>#include &lt;stdlib.h&gt;</code> (to obtain the function prototypes), we do not explicitly have to cast the pointer returned by these functions when we assign it to a pointer of a different type. <u>The default return value for undeclared functions is int, so using a cast without the proper function declaration could hide an error on systems where the size of type int differs from the size of a function’s return value (a pointer in this case).</u></p>
<ul>
<li><code>free</code>: causes the space pointed to by <em>ptr</em> to be deallocated. This freed space is usually put into a pool of available memory and can be allocated in a later call to one of the three <code>alloc</code> functions.</li>
</ul>
<p>The allocation routines are usually implemented with the <code>sbrk(2)</code> system call. This system call expands (or contracts) the heap of the process. Although <code>sbrk</code> can expand or contract the memory of a process, most versions of <code>malloc</code> and free never decrease their memory size. <u>The space that we free is available for a later allocation, but the freed space is not usually returned to the kernel; instead, that space is kept in the <code>malloc</code> pool.</u></p>
<h4 id="alternate-memory-allocators">Alternate Memory Allocators</h4>
<p>[p209]</p>
<ul>
<li><code>libmalloc</code></li>
<li><code>vmalloc</code></li>
<li><code>quick-fit</code></li>
<li><code>jemalloc</code></li>
<li><code>TCMalloc</code></li>
<li><code>alloca</code> Function: has the same calling sequence as <code>malloc</code>; however, instead of allocating memory from the heap, the memory is allocated from the stack frame of the current function</li>
</ul>
<h3 id="environment-variables">Environment Variables</h3>
<p>The environment strings are usually of the form:</p>
<div class="codehilite"><pre>name=value
</pre></div>


<p>The UNIX kernel never looks at these strings; their interpretation is up to the various applications.</p>
<p><small><a href="https://gist.github.com/shichao-an/618104c2fa3a6caba3b3">apue_getenv.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">getenv</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="cm">/* Returns: pointer to value associated with name, NULL if not found */</span>

<span class="kt">int</span> <span class="nf">putenv</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
<span class="cm">/* Returns: 0 if OK, nonzero on error */</span>

<span class="kt">int</span> <span class="nf">setenv</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rewrite</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">unsetenv</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/* Both return: 0 if OK, −1 on error */</span>
</pre></div>


<ul>
<li><code>getenv</code>: returns a pointer to the value of a <code>name=value</code> string. We should always use <code>getenv</code> to fetch a specific value from the environment, instead of accessing <code>environ</code> directly</li>
</ul>
<p><a href="../figure_7.7.png" title="Figure 7.7 Environment variables defined in the Single UNIX Specification"><img alt="Figure 7.7 Environment variables defined in the Single UNIX Specification" src="../figure_7.7_600.png" /></a></p>
<ul>
<li><code>putenv</code>: takes a string of the form <code>name=value</code> and places it in the environment list. If name already exists, its old definition is first removed.</li>
<li><code>setenv</code>: sets <em>name</em> to <em>value</em>. If name already exists in the environment, then:<ul>
<li>If <em>rewrite</em> is nonzero, the existing definition for <em>name</em> is first removed</li>
<li>If <em>rewrite</em> is 0, the existing definition for <em>name</em> is not removed, <em>name</em> is not set to the new value, and no error occurs</li>
</ul>
</li>
<li><code>unsetenv</code>: removes any definition of name. It is not an error if such a definition does not exist.</li>
</ul>
<p>Note the difference between <code>putenv</code> and <code>setenv</code>. Whereas <code>setenv</code> must allocate memory to create the <code>name=value</code> string from its arguments, <code>putenv</code> is free to place the string passed to it directly into the environment. Indeed, many implementations do exactly this, so <u>it would be an error to pass putenv a string allocated on the stack, since the memory would be reused after we return from the current function.</u></p>
<ul>
<li>Deleting a string: we just find the pointer in the environment list and move all subsequent pointers down one.</li>
<li>Modifying a existing <em>name</em>:<ul>
<li>If new <em>value</em> is smaller than or equal to old: we just copy the string</li>
<li>If new <em>value</em> is larger than old: we must <code>malloc</code> and replace the old pointer in the environment list for <em>name</em> with the pointer to this allocated area</li>
</ul>
</li>
<li>Adding a new <em>name</em>:<ul>
<li>First time: we call <code>malloc</code>, copy the old environment list to this new area and store a pointer to the <code>name=value</code> string at the end of
this list of pointers. We also store a null pointer at the end of this list, of course. Finally, we set <code>environ</code> to point to this new list of pointers. <u>If the original environment list was contained above the top of the stack, as is common, then we have moved this list of pointers to the heap. But most of the pointers in this list still point to <code>name=value</code> strings above the top of the stack.</u></li>
<li>Not first time: we call <code>realloc</code> to allocate room for one more pointer. The pointer to the new <code>name=value</code> string is stored at the end of the list (on top of the previous null pointer), followed by a null pointer.</li>
</ul>
</li>
</ul>
<h3 id="setjmp-and-longjmp-functions"><code>setjmp</code> and <code>longjmp</code> Functions</h3>
<p>In C, we can't <code>goto</code> a label that’s in another function. Instead, we must use the <code>setjmp</code> and <code>longjmp</code> functions to perform this type of branching. These two functions are useful for handling error conditions that occur in a deeply nested function call.</p>
<p><small><a href="https://gist.github.com/shichao-an/4d30742d979b1b83dc69">apue_setjmp.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;setjmp.h&gt;</span>

<span class="kt">int</span> <span class="nf">setjmp</span><span class="p">(</span><span class="kt">jmp_buf</span> <span class="n">env</span><span class="p">);</span>
<span class="cm">/* Returns: 0 if called directly, nonzero if returning from a call to longjmp */</span>

<span class="kt">void</span> <span class="nf">longjmp</span><span class="p">(</span><span class="kt">jmp_buf</span> <span class="n">env</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
</pre></div>


<p>Examples:</p>
<ul>
<li><a href="https://github.com/shichao-an/apue.3e/blob/master/environ/cmd1.c">cmd1.c</a></li>
<li><a href="https://github.com/shichao-an/apue.3e/blob/master/environ/cmd2.c">cmd2.c</a></li>
</ul>
<h4 id="automatic-register-and-volatile-variables">Automatic, Register, and Volatile Variables</h4>
<p>When we return to <code>main</code> as a result of the <code>longjmp</code>, implementations do not try to roll back these automatic variables and register variables (in <code>main</code>), though standards say only that their values are indeterminate.</p>
<p>Example:</p>
<ul>
<li><a href="https://github.com/shichao-an/apue.3e/blob/master/environ/testjmp.c">testjmp.c</a></li>
</ul>
<p>Compile the above program, with and without compiler optimizations, the results are different:</p>
<div class="codehilite"><pre>$ gcc testjmp.c compile without any optimization
$ ./a.out
in f1():
globval = 95, autoval = 96, regival = 97, volaval = 98, statval = 99
after longjmp:
globval = 95, autoval = 96, regival = 97, volaval = 98, statval = 99
$ gcc -O testjmp.c compile with full optimization
$ ./a.out
in f1():
globval = 95, autoval = 96, regival = 97, volaval = 98, statval = 99
after longjmp:
globval = 95, autoval = 2, regival = 3, volaval = 98, statval = 99
</pre></div>


<p>The optimizations don’t affect the global, static, and volatile variables. The <code>setjmp(3)</code> manual page on one system states that variables stored in memory will have values as of the time of the <code>longjmp</code>, whereas variables in the CPU and floating-point registers are restored to their values when <code>setjmp</code> was called. Without optimization, all five variables are stored in memory. When we enable optimization, both <code>autoval</code> and <code>regival</code> go into registers, even though the former wasn't declared <code>register</code>, and the <code>volatile</code> variable stays in memory.</p>
<h4 id="potential-problem-with-automatic-variables">Potential Problem with Automatic Variables</h4>
<p><u>An automatic variable can never be referenced after the function that declared it returns.</u></p>
<p>Incorrect usage of an automatic variable:</p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="kt">FILE</span> <span class="o">*</span>
<span class="nf">open_data</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">databuf</span><span class="p">[</span><span class="n">BUFSIZ</span><span class="p">];</span> <span class="cm">/* setvbuf makes this the stdio buffer */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">&quot;datafile&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">setvbuf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">databuf</span><span class="p">,</span> <span class="n">_IOLBF</span><span class="p">,</span> <span class="n">BUFSIZ</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="k">return</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span> <span class="cm">/* error */</span>
<span class="p">}</span>
</pre></div>


<p>The problem is that when <code>open_data</code> returns, the space it used on the stack will be used by the stack frame for the next function that is called. But the standard I/O library will still be using that portion of memory for its stream buffer. Chaos is sure to result. To correct this problem, the array <code>databuf</code> needs to be allocated from global memory, either statically (<code>static</code> or <code>extern</code>) or dynamically (one of the <code>alloc</code> functions).</p>
<h3 id="getrlimit-and-setrlimit-functions"><code>getrlimit</code> and <code>setrlimit</code> Functions</h3>
<p>Every process has a set of resource limits, some of which can be queried and changed by the <code>getrlimit</code> and <code>setrlimit</code> functions.</p>
<p><small><a href="https://gist.github.com/shichao-an/4562094dcbbca444ec4b">apue_getrlimit.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;sys/resource.h&gt;</span>

<span class="kt">int</span> <span class="nf">getrlimit</span><span class="p">(</span><span class="kt">int</span> <span class="n">resource</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">rlptr</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">setrlimit</span><span class="p">(</span><span class="kt">int</span> <span class="n">resource</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">rlptr</span><span class="p">);</span>

<span class="cm">/* Both return: 0 if OK, −1 on error */</span>
</pre></div>


<p>These two functions are defined in the XSI option in the Single UNIX Specification. The resource limits for a process are normally established by process 0 when the system is initialized and then inherited by each successive process. Each implementation has its own way of tuning the various limits.</p>
<ul>
<li><em>rlptr</em>: a pointer to the following structure:</li>
</ul>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">rlimit</span> <span class="p">{</span>
    <span class="kt">rlim_t</span> <span class="n">rlim_cur</span><span class="p">;</span> <span class="cm">/* soft limit: current limit */</span>
    <span class="kt">rlim_t</span> <span class="n">rlim_max</span><span class="p">;</span> <span class="cm">/* hard limit: maximum value for rlim_cur */</span>
<span class="p">};</span>
</pre></div>


<ul>
<li>
<p><em>resource</em> argument takes on one of the following values:</p>
<ul>
<li><code>RLIMIT_AS</code>: The maximum size in bytes of a process’s total available memory. This affects the <code>sbrk</code> function and the <code>mmap</code> function.</li>
<li><code>RLIMIT_CORE</code>: The maximum size in bytes of a core file. A limit of 0 prevents the creation of a core file.</li>
<li><code>RLIMIT_CPU</code>: The maximum amount of CPU time in seconds. When the soft limit is exceeded, the SIGXCPU signal is sent to the process.</li>
<li><code>RLIMIT_DATA</code>: The maximum size in bytes of the data segment: the sum of the initialized data, uninitialized data, and heap from <a href="../figure_7.6.png">Figure 7.6</a>.</li>
<li><code>RLIMIT_FSIZE</code>: The maximum size in bytes of a file that may be created.  When the soft limit is exceeded, the process is sent the <code>SIGXFSZ</code> signal.</li>
<li><code>RLIMIT_MEMLOCK</code>: The maximum amount of memory in bytes that a process can lock into memory using <code>mlock(2)</code>.</li>
<li><code>RLIMIT_MSGQUEUE</code>: The maximum amount of memory in bytes that a process can allocate for POSIX message queues.</li>
<li><code>RLIMIT_NICE</code>: The limit to which a process’s nice value can be raised to affect its scheduling priority.</li>
<li><code>RLIMIT_NOFILE</code>: The maximum number of open files per process. Changing this limit affects the value returned by the <code>sysconf</code> function for its <code>_SC_OPEN_MAX</code> argument.</li>
<li><code>RLIMIT_NPROC</code>: The maximum number of child processes per real user ID. Changing this limit affects the value returned for <code>_SC_CHILD_MAX</code> by the <code>sysconf</code> function.</li>
<li><code>RLIMIT_NPTS</code>: The maximum number of pseudo terminals that a user can have open at one time.</li>
<li><code>RLIMIT_RSS</code>: Maximum resident set size (RSS) in bytes. If available physical memory is low, the kernel takes memory from processes that exceed their RSS.</li>
<li><code>RLIMIT_SBSIZE</code>: The maximum size in bytes of socket buffers that a user can consume at any given time.</li>
<li><code>RLIMIT_SIGPENDING</code>: The maximum number of signals that can be queued for a process. This limit is enforced by the sigqueue function</li>
<li><code>RLIMIT_STACK</code>: The maximum size in bytes of the stack. See <a href="../figure_7.6.png">Figure 7.6</a>.</li>
<li><code>RLIMIT_SWAP</code>: The maximum amount of swap space in bytes that a user can consume.</li>
<li><code>RLIMIT_VMEM</code> This is a synonym for <code>RLIMIT_AS</code>.</li>
</ul>
</li>
</ul>
<p>Rules of changing resource limits:</p>
<ol>
<li>A process can change its soft limit to a value less than or equal to its hard limit.</li>
<li>A process can lower its hard limit to a value greater than or equal to its soft limit. <u>This lowering of the hard limit is irreversible for normal users.</u></li>
<li>Only a superuser process can raise a hard limit.</li>
</ol>
<p>The resource limits affect the calling process and are inherited by any of its children. This means that the setting of resource limits needs to be built into the shells to affect all our future processes. Indeed, the Bourne shell, the GNU Bourne-again shell, and the Korn shell have the built-in <code>ulimit</code> command, and the C shell has the built-in limit command. (The <code>umask</code> and <code>chdir</code> functions also have to be handled as shell built-ins.)</p>
<p>Example:</p>
<ul>
<li><a href="https://github.com/shichao-an/apue.3e/blob/master/environ/getrlimit.c">getrlimit.c</a></li>
</ul>
<h3 id="summary">Summary</h3>
<p>Understanding the environment of a C program within a UNIX system’s environment is a prerequisite to understanding the process control features of the UNIX System. This chapter discusses process start and termination, and how a process is passed  an argument list and an environment. Although both the argument list and the environment are uninterpreted by the kernel, it is the kernel that passes both from the caller of <code>exec</code> to the new process.  This chapter also examines the typical memory layout of a C program and how a process can dynamically allocate and free memory.</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>