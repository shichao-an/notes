<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/asm/">
        <link rel="shortcut icon" href="../toki_32.png">
        

	<title>x86 assembly - Shichao's Notes</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../custom.css" rel="stylesheet">
        <link href="../github.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
            
                <li >
                    <a href="..">Home</a>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                    
                        <li >
                            <a href="../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                    
                        <li >
                            <a href="../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                    
                        <li >
                            <a href="../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                    
                        <li >
                            <a href="../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                    
                        <li >
                            <a href="../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                    
                        <li >
                            <a href="../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                    
                        <li >
                            <a href="../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                    
                        <li >
                            <a href="../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                    
                        <li >
                            <a href="../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                    
                        <li >
                            <a href="../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                    
                        <li >
                            <a href="../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                    
                        <li >
                            <a href="../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                    
                        <li >
                            <a href="../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                    
                        <li >
                            <a href="../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                    
                        <li >
                            <a href="../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                    
                        <li >
                            <a href="../lkd/ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                    
                        <li >
                            <a href="../lkd/ch5/">Chapter 5. System Calls</a>
                        </li>
                    
                        <li >
                            <a href="../lkd/ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                    
                        <li >
                            <a href="../lkd/ch7/">Chapter 7. Interrupts and Interrupt Handlers</a>
                        </li>
                    
                        <li >
                            <a href="../lkd/ch8/">Chapter 8. Bottom Halves and Deferring Work</a>
                        </li>
                    
                        <li >
                            <a href="../lkd/ch9/">Chapter 9. An Introduction to Kernel Synchronization</a>
                        </li>
                    
                        <li >
                            <a href="../lkd/ch10/">Chapter 10. Kernel Synchronization Methods</a>
                        </li>
                    
                        <li >
                            <a href="../lkd/ch11/">Chapter 11. Timers and Time Management</a>
                        </li>
                    
                        <li >
                            <a href="../lkd/ch12/">Chapter 12. Memory Management</a>
                        </li>
                    
                        <li >
                            <a href="../lkd/ch13/">Chapter 13. The Virtual Filesystem</a>
                        </li>
                    
                        <li >
                            <a href="../lkd/ch14/">Chapter 14. The Block I/O Layer</a>
                        </li>
                    
                        <li >
                            <a href="../lkd/ch15/">Chapter 15. The Process Address Space</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                    
                        <li >
                            <a href="../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                    
                        <li >
                            <a href="../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                    
                        <li >
                            <a href="../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                    
                        <li >
                            <a href="../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                    
                        <li >
                            <a href="../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                    
                        <li >
                            <a href="../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                    
                        <li >
                            <a href="../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                    
                        <li >
                            <a href="../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                    
                        <li >
                            <a href="../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                    
                        <li >
                            <a href="../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                    
                        <li >
                            <a href="../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                    
                        <li >
                            <a href="../tcpv1/headers/">Headers</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UTLK <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../utlk/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../utlk/ch2/">Chapter 2. Memory Addressing</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LSP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../lsp/ch9/">Chapter 9. Memory Management</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TLPI <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../tlpi/ch6/">Chapter 6. Processes</a>
                        </li>
                    
                        <li >
                            <a href="../tlpi/ch7/">Chapter 7. Memory Allocation</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Others <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../clrs/">CLRS</a>
                        </li>
                    
                        <li >
                            <a href="../htae/">HTAE</a>
                        </li>
                    
                        <li >
                            <a href="../golang/">Go</a>
                        </li>
                    
                        <li >
                            <a href="../bash/">Bash</a>
                        </li>
                    
                        <li >
                            <a href="../c/">C</a>
                        </li>
                    
                        <li class="active">
                            <a href="./">x86 assembly</a>
                        </li>
                    
                        <li >
                            <a href="../iptables/">iptables</a>
                        </li>
                    
                        <li >
                            <a href="../nginx/">Nginx</a>
                        </li>
                    
                        <li >
                            <a href="../vim/">Vim</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/asm/index.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#x86-assembly">x86 Assembly</a></li>
        
    
        <li class="main "><a href="#introduction">Introduction</a></li>
        
            <li><a href="#why-learn-assembly">Why Learn Assembly?</a></li>
        
    
        <li class="main "><a href="#basic-faq">Basic FAQ</a></li>
        
            <li><a href="#how-computer-reads-assembly">How Computer Reads Assembly</a></li>
        
            <li><a href="#platform-differences">Platform differences</a></li>
        
    
        <li class="main "><a href="#x86-family">x86 Family</a></li>
        
    
        <li class="main "><a href="#x86-architecture">x86 Architecture</a></li>
        
            <li><a href="#the-x86-architecture">The x86 Architecture</a></li>
        
            <li><a href="#general-purpose-registers-gpr-32-bit-naming-conventions">General-Purpose Registers (GPR) (32-bit naming conventions)</a></li>
        
            <li><a href="#segment-registers">Segment Registers</a></li>
        
            <li><a href="#eflags-register">EFLAGS Register</a></li>
        
            <li><a href="#instruction-pointer">Instruction Pointer</a></li>
        
            <li><a href="#memory">Memory</a></li>
        
            <li><a href="#twos-complement-representation">Two's Complement Representation</a></li>
        
            <li><a href="#addressing-modes">Addressing modes</a></li>
        
            <li><a href="#general-purpose-registers-gpr-64-bit-naming-conventions">General-Purpose Registers (GPR) (64-bit naming conventions)</a></li>
        
    
        <li class="main "><a href="#stack">Stack</a></li>
        
    
        <li class="main "><a href="#cpu-operation-modes">CPU Operation Modes</a></li>
        
            <li><a href="#real-mode">Real Mode</a></li>
        
            <li><a href="#protected-mode">Protected Mode</a></li>
        
    
        <li class="main "><a href="#comments">Comments</a></li>
        
    
        <li class="main "><a href="#16-32-and-64-bits">16 32 and 64 Bits</a></li>
        
    
        <li class="main "><a href="#intrinsic-data-types">Intrinsic Data Types</a></li>
        
            <li><a href="#integer">Integer</a></li>
        
            <li><a href="#floating-point-numbers">Floating Point Numbers</a></li>
        
    
        <li class="main "><a href="#x86-instructions">x86 Instructions</a></li>
        
            <li><a href="#conventions">Conventions</a></li>
        
            <li><a href="#suffixes">Suffixes</a></li>
        
    
        <li class="main "><a href="#data-transfer-instructions">Data Transfer Instructions</a></li>
        
            <li><a href="#move-mov">Move: mov</a></li>
        
            <li><a href="#data-swap-xchg-and-cmpxchg">Data swap: xchg and cmpxchg</a></li>
        
            <li><a href="#move-with-zero-extend">Move with zero extend</a></li>
        
            <li><a href="#sign-extend">Sign Extend</a></li>
        
            <li><a href="#move-string">Move String</a></li>
        
            <li><a href="#load-effective-address">Load Effective Address</a></li>
        
    
        <li class="main "><a href="#control-flow-instructions">Control Flow Instructions</a></li>
        
            <li><a href="#comparison-test-and-cmp">Comparison: test and cmp</a></li>
        
            <li><a href="#jump-instructions">Jump Instructions</a></li>
        
            <li><a href="#function-calls">Function Calls</a></li>
        
            <li><a href="#loop-instructions">Loop Instructions</a></li>
        
            <li><a href="#enter-and-leave">Enter and Leave</a></li>
        
            <li><a href="#other-control-instructions">Other Control Instructions</a></li>
        
    
        <li class="main "><a href="#arithmetic-instructions">Arithmetic Instructions</a></li>
        
    
        <li class="main "><a href="#logic-instructions">Logic Instructions</a></li>
        
    
        <li class="main "><a href="#shift-and-rotate-instructions">Shift and Rotate Instructions</a></li>
        
    
        <li class="main "><a href="#other-instructions">Other Instructions</a></li>
        
            <li><a href="#stack-instructions">Stack Instructions</a></li>
        
            <li><a href="#flags-instructions">Flags instructions</a></li>
        
    
        <li class="main "><a href="#x86-interrupts">x86 Interrupts</a></li>
        
            <li><a href="#interrupt-instruction">Interrupt Instruction</a></li>
        
            <li><a href="#types-of-interrupts">Types of Interrupts</a></li>
        
    
        <li class="main "><a href="#x86-assemblers">x86 Assemblers</a></li>
        
    
        <li class="main "><a href="#gas-syntax">GAS Syntax</a></li>
        
    
        <li class="main "><a href="#masm-syntax">MASM Syntax</a></li>
        
    
        <li class="main "><a href="#interfacing-with-linux-system-calls">Interfacing with Linux: System Calls</a></li>
        
            <li><a href="#syscalls">Syscalls</a></li>
        
            <li><a href="#making-a-syscalls">Making a syscalls</a></li>
        
            <li><a href="#int-0x80">int 0x80</a></li>
        
            <li><a href="#syscall">syscall</a></li>
        
            <li><a href="#hello-world-example">Hello World example</a></li>
        
    
        <li class="main "><a href="#references">References</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="x86-assembly"><strong>x86 Assembly</strong></h3>
<blockquote>
<p>If you don't assemble the (assembly) code, it's complete gibberish to the computer.
<small>Wikibooks</small></p>
</blockquote>
<h3 id="introduction">Introduction</h3>
<p><small><a href="https://en.wikibooks.org/wiki/X86_Assembly/Introduction">Introduction</a></small></p>
<h4 id="why-learn-assembly">Why Learn Assembly?</h4>
<ul>
<li>With assembly, the programmer can precisely track the flow of data and execution in a program in a mostly human-readable form.<ul>
<li>Debuggers will frequently only show program code in assembly language.</li>
</ul>
</li>
<li>Assembly language is also the preferred tool for implementing some low-level tasks, such as bootloaders and low-level kernel components. Code written in assembly has less overhead than code written in high-level languages<ul>
<li>As hardware manufacturers such as Intel and AMD add new features and new instructions to their processors, often times the only way to access those features is to use assembly routines, at least until the major compiler vendors add support for those features.</li>
</ul>
</li>
</ul>
<h3 id="basic-faq">Basic FAQ</h3>
<p><small><a href="https://en.wikibooks.org/wiki/X86_Assembly/Basic_FAQ">Basic FAQ</a></small></p>
<h4 id="how-computer-reads-assembly">How Computer Reads Assembly</h4>
<p>The computer cannot read the assembly language that you write. Your assembler will convert the assembly language into a form of binary information called "machine code" that your computer uses to perform its operations.</p>
<h4 id="platform-differences">Platform differences</h4>
<p>The basic x86 machine code is dependent only on the processor. The x86 versions of Windows and Linux are obviously built on the x86 machine code. There are a few differences between Linux and Windows programming in x86 Assembly:</p>
<ol>
<li>On a Linux computer, the most popular assemblers are the GAS assembler, which uses the AT&amp;T syntax for writing code, and the Netwide Assembler, also known as NASM, which uses a syntax similar to MASM.</li>
<li>On a Windows computer, the most popular assembler is MASM, which uses the Intel syntax.</li>
<li>The available software interrupts, and their functions, are different on Windows and Linux.</li>
<li>The available code libraries are different on Windows and Linux.</li>
</ol>
<h3 id="x86-family">x86 Family</h3>
<p><small><a href="https://en.wikibooks.org/wiki/X86_Assembly/X86_Family">x86 Family</a></small></p>
<p>The term "x86" can refer both to an instruction set architecture and to microprocessors which implement it. The name x86 is derived from the fact that many of Intel's early processors had names ending in "86".</p>
<p>The x86 instruction set architecture originated at Intel and has evolved over time by the addition of new instructions as well as the expansion to 64-bits. As of 2009, x86 primarily refers to <a href="https://en.wikipedia.org/wiki/IA-32">IA-32</a> (Intel Architecture, 32-bit) and/or <a href="https://en.wikipedia.org/wiki/X86-64">x86-64</a>, the extension to 64-bit computing.</p>
<p>Versions of the x86 instruction set architecture have been implemented by Intel, AMD and several other vendors, with each vendor having its own family of x86 processors.</p>
<h3 id="x86-architecture">x86 Architecture</h3>
<p><small><a href="https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture">x86 Architecture</a></small></p>
<h4 id="the-x86-architecture">The x86 Architecture</h4>
<p>The x86 architecture has:</p>
<ul>
<li>8 General-Purpose Registers (GPR)</li>
<li>6 Segment Registers</li>
<li>1 Flags Register</li>
<li>1 Instruction Pointer</li>
</ul>
<p>64-bit x86 has additional registers.</p>
<h4 id="general-purpose-registers-gpr-32-bit-naming-conventions">General-Purpose Registers (GPR) (32-bit naming conventions)</h4>
<p>The 8 GPRs are:</p>
<ol>
<li>Accumulator register (AX). Used in arithmetic operations.</li>
<li>Counter register (CX). Used in shift/rotate instructions and loops.</li>
<li>Data register (DX). Used in arithmetic operations and I/O operations.</li>
<li>Base register (BX). Used as a pointer to data (located in segment register DS, when in segmented mode).</li>
<li>Stack Pointer register (SP). Pointer to the top of the stack.</li>
<li>Stack Base Pointer register (BP). Used to point to the base of the stack.</li>
<li>Source Index register (SI). Used as a pointer to a source in stream operations.</li>
<li>Destination Index register (DI). Used as a pointer to a destination in stream operations.</li>
</ol>
<p>The order in which they are listed here is for a reason: it is the same order that is used in a push-to-stack operation, which will be covered later.</p>
<p>All registers can be accessed in 16-bit, 32-bit and 64-bit modes:</p>
<ul>
<li>16-bit: the register is identified by its two-letter abbreviation from the list above. For example, 'AX'.</li>
<li>32-bit: the two-letter abbreviation is prefixed with an 'E' (extended). For example, 'EAX'.</li>
<li>64-bit: the two-letter abbreviation is prefixed with an 'R'. For example, 'RAX'.</li>
</ul>
<p>It is also possible to address the first four registers (AX, CX, DX and BX) in their size of 16-bit as two 8-bit halves:</p>
<ul>
<li>The least significant byte (LSB), or low half, is identified by replacing the 'X' with an 'L'.
&amp; The most significant byte (MSB), or high half, uses an 'H' instead.</li>
</ul>
<p>For example, CL is the LSB of the counter register, whereas CH is its MSB.</p>
<p>The following table summarizes five ways to access the accumulator, counter, data and base registers: 64-bit, 32-bit, 16-bit, 8-bit LSB, and 8-bit MSB:</p>
<p><a href="./figure_1.png" title="Five ways to access the accumulator, counter, data and base registers: 64-bit, 32-bit, 16-bit, 8-bit LSB, and 8-bit MSB"><img alt="Five ways to access the accumulator, counter, data and base registers: 64-bit, 32-bit, 16-bit, 8-bit LSB, and 8-bit MSB" src="./figure_1_600.png" /></a></p>
<h4 id="segment-registers">Segment Registers</h4>
<p>The 6 Segment Registers are:</p>
<ul>
<li>Stack Segment (SS). Pointer to the stack.</li>
<li>Code Segment (CS). Pointer to the code.</li>
<li>Data Segment (DS). Pointer to the data.</li>
<li>Extra Segment (ES). Pointer to extra data ('E' stands for 'Extra').</li>
<li>F Segment (FS). Pointer to more extra data ('F' comes after 'E').</li>
<li>G Segment (GS). Pointer to still more extra data ('G' comes after 'F').</li>
</ul>
<p>Most applications on most modern operating systems (FreeBSD, Linux or Microsoft Windows) use a memory model that points nearly all segment registers to the same place and uses paging instead, effectively disabling their use. Typically the use of FS or GS is an exception to this rule, instead being used to point at thread-specific data.</p>
<h4 id="eflags-register">EFLAGS Register</h4>
<p>The EFLAGS is a 32-bit register used as a collection of bits representing Boolean values to store the results of operations and the state of the processor.</p>
<p><a href="./figure_2.png" title="EFLAGS bits"><img alt="EFLAGS bits" src="./figure_2_600.png" /></a></p>
<p>The bits named 0 and 1 are reserved bits and shouldn't be modified.</p>
<p>The different use of these flags are:</p>
<ul>
<li>0 CF : Carry Flag. Set if the last arithmetic operation carried (addition) or borrowed (subtraction) a bit beyond the size of the register. This is then checked when the operation is followed with an add-with-carry or subtract-with-borrow to deal with values too large for just one register to contain.</li>
<li>2 PF : Parity Flag. Set if the number of set bits in the least significant byte is a multiple of 2.</li>
<li>4 AF : Adjust Flag. Carry of Binary Code Decimal (BCD) numbers arithmetic operations.</li>
<li>6 ZF : Zero Flag. Set if the result of an operation is Zero (0).</li>
<li>7 SF : Sign Flag. Set if the result of an operation is negative.</li>
<li>8 TF : Trap Flag. Set if step by step debugging.</li>
<li>9 IF : Interruption Flag. Set if interrupts are enabled.</li>
<li>10 DF : Direction Flag. Stream direction. If set, string operations will decrement their pointer rather than incrementing it, reading memory backwards.</li>
<li>11 OF : Overflow Flag. Set if signed arithmetic operations result in a value too large for the register to contain.</li>
<li>12-13 IOPL : I/O Privilege Level field (2 bits). I/O Privilege Level of the current process.</li>
<li>14 NT : Nested Task flag. Controls chaining of interrupts. Set if the current process is linked to the next process.</li>
<li>16 RF : Resume Flag. Response to debug exceptions.</li>
<li>17 VM : Virtual-8086 Mode. Set if in 8086 compatibility mode.</li>
<li>18 AC : Alignment Check. Set if alignment checking of memory references is done.</li>
<li>19 VIF : Virtual Interrupt Flag. Virtual image of IF.</li>
<li>20 VIP : Virtual Interrupt Pending flag. Set if an interrupt is pending.</li>
<li>21 ID : Identification Flag. Support for CPUID instruction if can be set.</li>
</ul>
<h4 id="instruction-pointer">Instruction Pointer</h4>
<p>The EIP register contains the address of the next instruction to be executed if no branching is done.</p>
<p>EIP can only be read through the stack after a <code>call</code> instruction.</p>
<h4 id="memory">Memory</h4>
<p>The x86 architecture is <a href="https://en.wikipedia.org/wiki/Endianness#Little-endian">little-endian</a>, meaning that multi-byte values are written least significant byte first. (This refers only to the ordering of the bytes, not to the bits.)</p>
<p><a href="./figure_3.png" title="Little Endian"><img alt="Little Endian" src="./figure_3.png" /></a></p>
<p>The 32 bit value B3B2B1B0<sub>16</sub> on an x86 would be represented in memory as:</p>
<div class="codehilite"><pre>+----+----+----+----+
| B0 | B1 | B2 | B3 |
+----+----+----+----+
</pre></div>


<p>The 32 bits double word 0x1BA583D4 (the 0x denotes hexadecimal) would be written in memory as:</p>
<div class="codehilite"><pre>+----+----+----+----+
| D4 | 83 | A5 | 1B |
+----+----+----+----+
</pre></div>


<p>This will be seen as <code>0xD4 0x83 0xA5 0x1B</code> when doing a memory dump.</p>
<h4 id="twos-complement-representation">Two's Complement Representation</h4>
<p>Two's complement is the standard way of representing negative integers in binary. The sign is changed by inverting all of the bits and adding one.</p>
<p>For example,</p>
<div class="codehilite"><pre>+----------+------+
| Start:   | 0001 |
+----------+------+
| Invert:  | 1110 |
+----------+------+
| Add One: | 1111 |
+----------+------+
</pre></div>


<ul>
<li>0001 represents decimal 1</li>
<li>1111 represents decimal -1</li>
</ul>
<h4 id="addressing-modes">Addressing modes</h4>
<p>The addressing mode indicates how the operand is presented.</p>
<h5 id="register-addressing"><strong>Register Addressing</strong></h5>
<p>Operand address R is in the address field.</p>
<div class="codehilite"><pre><span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="nb">bx</span>  <span class="c1">; moves contents of register bx into ax</span>
</pre></div>


<h5 id="immediate"><strong>Immediate</strong></h5>
<p>Aactual value is in the field.</p>
<div class="codehilite"><pre><span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="mi">1</span>   <span class="c1">; moves value of 1 into register ax</span>
</pre></div>


<p>Or:</p>
<div class="codehilite"><pre><span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="mh">010Ch</span> <span class="c1">; moves value of 0x010C into register ax</span>
</pre></div>


<h5 id="direct-memory-addressing"><strong>Direct memory addressing</strong></h5>
<p>Operand address is in the address field.</p>
<div class="codehilite"><pre><span class="nf">.data</span>
<span class="nf">my_var</span> <span class="nv">dw</span> <span class="mh">0abcdh</span> <span class="c1">; my_var = 0xabcd</span>
<span class="nf">.code</span>
<span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nv">my_var</span><span class="p">]</span> <span class="c1">; copy my_var content in ax (ax=0xabcd)</span>
</pre></div>


<h5 id="direct-offset-addressing"><strong>Direct offset addressing</strong></h5>
<p>Uses arithmetics to modify address.</p>
<div class="codehilite"><pre><span class="nf">byte_tbl</span> <span class="nv">db</span> <span class="mi">12</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="nv">.....</span> <span class="c1">; Table of bytes</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,[</span><span class="kt">byte</span><span class="nv">_tbl</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span><span class="kt">byte</span><span class="nv">_tbl</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1">; same as the former</span>
</pre></div>


<h5 id="register-indirect"><strong>Register Indirect</strong></h5>
<p>Field points to a register that contains the operand address.</p>
<div class="codehilite"><pre><span class="nf">mov</span> <span class="nb">ax</span><span class="p">,[</span><span class="nb">di</span><span class="p">]</span>
</pre></div>


<p>The registers used for indirect addressing are BX, BP, SI, DI</p>
<h5 id="base-index"><strong>Base-index</strong></h5>
<div class="codehilite"><pre><span class="nf">mov</span> <span class="nb">ax</span><span class="p">,[</span><span class="nb">bx</span> <span class="o">+</span> <span class="nb">di</span><span class="p">]</span>
</pre></div>


<p>For example, if we are talking about an array, BX contains the address of the beginning of the array, and DI contains the index into the array.</p>
<h5 id="base-index-with-displacement"><strong>Base-index with displacement</strong></h5>
<div class="codehilite"><pre><span class="nf">mov</span> <span class="nb">ax</span><span class="p">,[</span><span class="nb">bx</span> <span class="o">+</span> <span class="nb">di</span> <span class="o">+</span> <span class="mi">10</span><span class="p">]</span>
</pre></div>


<h4 id="general-purpose-registers-gpr-64-bit-naming-conventions">General-Purpose Registers (GPR) (64-bit naming conventions)</h4>
<p><small><a href="https://en.wikibooks.org/wiki/X86_Assembly/16_32_and_64_Bits">16 32 and 64 Bits</a></small></p>
<p>64-bit x86 adds 8 more general-purpose registers, named R8, R9, R10 and so on up to R15. It also introduces a new naming convention that must be used for these new registers and can also be used for the old ones (except that AH, CH, DH and BH have no equivalents). In the new convention:</p>
<ul>
<li>R0 is RAX.</li>
<li>R1 is RCX.</li>
<li>R2 is RDX.</li>
<li>R3 is RBX.</li>
<li>R4 is RSP.</li>
<li>R5 is RBP.</li>
<li>R6 is RSI.</li>
<li>R7 is RDI.</li>
<li>R8, R9, R10, R11, R12, R13, R14, R15 are the new registers and have no other names.</li>
<li>R0D~R15D are the lowermost 32 bits of each register. For example, R0D is EAX.</li>
<li>R0W~R15W are the lowermost 16 bits of each register. For example, R0W is AX.</li>
<li>R0L~R15L are the lowermost 8 bits of each register. For example, R0L is AL.</li>
</ul>
<p>For 128-bit registers, see <a href="https://en.wikibooks.org/wiki/X86_Assembly/SSE">SSE</a>.</p>
<h3 id="stack">Stack</h3>
<p>The stack is a Last In First Out (LIFO) data structure; data is pushed onto it and popped off of it in the reverse order.</p>
<div class="codehilite"><pre><span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="mh">006Ah</span>
<span class="nf">mov</span> <span class="nb">bx</span><span class="p">,</span> <span class="nv">F79Ah</span>
<span class="nf">mov</span> <span class="nb">cx</span><span class="p">,</span> <span class="mh">1124h</span>
<span class="c1">; Push the value in AX, BX, and CX onto the top of the stack</span>
<span class="nf">push</span> <span class="nb">ax</span>
<span class="nf">push</span> <span class="nb">bx</span>
<span class="nf">push</span> <span class="nb">cx</span>
</pre></div>


<p>Now the stack has $006A, $F79A, and $1124.</p>
<div class="codehilite"><pre><span class="nf">call</span> <span class="nv">do_stuff</span>
</pre></div>


<p>Do some stuff. The function is not forced to save the registers it uses, hence us saving them.</p>
<div class="codehilite"><pre><span class="nf">pop</span> <span class="nb">cx</span> <span class="c1">;Pop the last element pushed onto the stack into CX, $1124; the stack now has $006A and $F79A.</span>
<span class="nf">pop</span> <span class="nb">bx</span> <span class="c1">;Pop the last element pushed onto the stack into BX, $F79A; the stack now has just $006A.</span>
<span class="nf">pop</span> <span class="nb">ax</span> <span class="c1">;Pop the last element pushed onto the stack into AX, $006A; the stack is empty.</span>
</pre></div>


<p>The stack has two common uses:</p>
<ul>
<li>Passing arguments to functions or procedures and also keeping track of control flow when the <code>call</code> instruction is used.</li>
<li>Temporarily saving registers.</li>
</ul>
<h3 id="cpu-operation-modes">CPU Operation Modes</h3>
<p><small><a href="https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture#CPU_Operation_Modes">CPU Operation Modes</a></small></p>
<h4 id="real-mode">Real Mode</h4>
<p>Real Mode is a holdover from the original Intel 8086. The Intel 8086 accessed memory using 20-bit addresses. But, as the processor itself was 16-bit, Intel invented an addressing scheme that provided a way of mapping a 20-bit addressing space into 16-bit words. Today's x86 processors start in the so-called Real Mode, which is an operating mode that mimics the behavior of the 8086, with some very tiny differences, for backwards compatibility.</p>
<h4 id="protected-mode">Protected Mode</h4>
<h5 id="flat-memory-model"><strong>Flat Memory Model</strong></h5>
<p>If programming in a modern operating system (such as Linux, Windows), you are basically programming in flat 32-bit mode. Any register can be used in addressing, and it is generally more efficient to use a full 32-bit register instead of a 16-bit register part. Additionally, segment registers are generally unused in flat mode, and it is generally a bad idea to touch them.</p>
<h5 id="multi-segmented-memory-model"><strong>Multi-Segmented Memory Model</strong></h5>
<p>Using a 32-bit register to address memory, the program can access (almost) all of the memory in a modern computer. For earlier processors (with only 16-bit registers) the segmented memory model was used. The 'CS', 'DS', and 'ES' registers are used to point to the different chunks of memory. For a small program (small model) the CS=DS=ES. For larger memory models, these 'segments' can point to different locations.</p>
<h3 id="comments">Comments</h3>
<p>When writing code, it is very helpful to use some comments explaining what is going on. A comment is a section of regular text that the assembler ignores when turning the assembly code into the machine code. In assembly comments are usually denoted with a semicolon ";", although GAS uses "#" for single line comments and "/<em> ... </em>/" for multi-line comments.</p>
<p>For example:</p>
<div class="codehilite"><pre><span class="nl">Label1:</span>
   <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="nb">bx</span>    <span class="c1">;move contents of bx into ax</span>
   <span class="nf">add</span> <span class="nb">ax</span><span class="p">,</span> <span class="nb">bx</span>    <span class="c1">;add the contents of bx into ax</span>
   <span class="nf">...</span>
</pre></div>


<h3 id="16-32-and-64-bits">16 32 and 64 Bits</h3>
<p><small><a href="https://en.wikibooks.org/wiki/X86_Assembly/16_32_and_64_Bits">16 32 and 64 Bits</a></small></p>
<h3 id="intrinsic-data-types">Intrinsic Data Types</h3>
<p>Strictly speaking, assembly has no predefined data types like higher-level programming languages. Any general purpose register can hold any sequence of two or four bytes, whether these bytes represent numbers, letters, or other data. In the same way, there are no concrete types assigned to blocks of memory; you can assign to them whatever value you like.</p>
<p>That said, one can group data in assembly into two categories: integer and floating point. While you could load a floating point value into a register and treat it like an integer, the results would be unexpected, so it is best to keep them separate.</p>
<h4 id="integer">Integer</h4>
<p>An integer represents a whole number, either positive or negative.</p>
<ul>
<li>Under the 8086 architecture, it originally came in 8-bit and 16-bit sizes, which served the most basic operations.</li>
<li>Later, starting with the 80386, the data bus was expanded to support 32-bit operations and thus allow operations on integers of that size.</li>
<li>The newest systems under the x86 architecture support 64-bit instructions; however, this requires a 64-bit operating system for optimal effect.</li>
</ul>
<p>Some assembly instructions behave slightly differently in regards to the sign bit; as such, there is a minor distinction between signed and unsigned integers.</p>
<h4 id="floating-point-numbers">Floating Point Numbers</h4>
<p>Floating point numbers are used to approximate the <strong>real numbers</strong> that usually contain digits before and after the decimal point (like π, 3.14159...). Unlike integers where the decimal point is understood to be after all digits, in floating point numbers the decimal point floats anywhere in the sequence of digits. The precision of floating point numbers is limited and thus a number like π can only be represented approximately.</p>
<p>Originally, floating point was not part of the main processor, requiring the use of emulating software. However, there were floating point coprocessors that allowed operations on this data-type, and starting with the 486DX, were integrated directly with the CPU.</p>
<p>As such, floating point operations are not necessarily compatible with all processors. If you need to perform this type of arithmetic, you may want to use a software library as a backup code path.</p>
<h3 id="x86-instructions">x86 Instructions</h3>
<h4 id="conventions">Conventions</h4>
<ul>
<li><a href="https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax">GAS Syntax</a></li>
<li><a href="https://en.wikibooks.org/wiki/X86_Assembly/MASM_Syntax">MASM Syntax</a></li>
</ul>
<p>Instructions that take no operands:</p>
<pre>
<b>Instr</b>
</pre>

<p>Instructions that take 1 operand:</p>
<pre>
<b>Instr</b> arg
</pre>

<p>Instructions that take 2 operands. Notice how the format of the instruction is different for different assemblers.</p>
<pre>
<b>Instr</b> src, dest    # <a href="https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax">GAS Syntax</a>
<b>Instr</b> dest, src    ; <a href="MASM Syntax">Intel syntax</a>
</pre>

<p>Instructions that take 3 operands. Notice how the format of the instruction is different for different assemblers.</p>
<pre>
<b>Instr</b> aux, src, dest   # <a href="https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax">GAS Syntax</a>
<b>Instr</b> dest, src, aux   ; <a href="MASM Syntax">Intel syntax</a>
</pre>

<h4 id="suffixes">Suffixes</h4>
<p><small><a href="https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax#Operation_Suffixes">Operation Suffixes</a></small></p>
<p>Some instructions require the use of suffixes to specify the size of the data which will be the subject of the operation, such as:</p>
<ul>
<li>b (byte) = 8 bits</li>
<li>w (word) = 16 bits</li>
<li>l (long) = 32 bits</li>
<li>q (quad) = 64 bits</li>
</ul>
<p>An example of the usage with the <code>mov</code> instruction on a 32-bit architecture, GAS syntax:</p>
<div class="codehilite"><pre><span class="nf">movl</span> <span class="no">$0x000F</span><span class="p">,</span> <span class="nv">%eax</span>          <span class="c"># Store the value F into the eax register</span>
</pre></div>


<h3 id="data-transfer-instructions">Data Transfer Instructions</h3>
<h4 id="move-mov">Move: <code>mov</code></h4>
<div class="codehilite"><pre><span class="nf">mov</span> <span class="no">src</span><span class="p">,</span> <span class="no">dest</span>  <span class="c"># GAS Synatx</span>
</pre></div>


<div class="codehilite"><pre><span class="nf">mov</span> <span class="nv">dest</span><span class="p">,</span> <span class="nv">src</span>  <span class="c1">; Intel Syntax</span>
</pre></div>


<p>The <code>mov</code> instruction copies the <code>src</code> operand into the <code>dest</code> operand.</p>
<p><strong>Operands</strong></p>
<ul>
<li><code>src</code>:<ul>
<li>Immediate</li>
<li>Register</li>
<li>Memory</li>
</ul>
</li>
<li><code>dest</code>:<ul>
<li>Register</li>
<li>Memory</li>
</ul>
</li>
</ul>
<p><strong>Modified flags</strong>: No FLAGS are modified by this instruction.</p>
<h4 id="data-swap-xchg-and-cmpxchg">Data swap: <code>xchg</code> and <code>cmpxchg</code></h4>
<div class="codehilite"><pre><span class="nf">xchg</span> <span class="no">src</span><span class="p">,</span> <span class="no">dest</span>
</pre></div>


<div class="codehilite"><pre><span class="nf">xchg</span> <span class="nv">dest</span><span class="p">,</span> <span class="nv">src</span>
</pre></div>


<p>The <code>xchg</code> instruction swaps the <code>src</code> operand with the dest operand. It's like doing three move operations: from dest to a temporary (another register), then from <code>src</code> to dest, then from the temporary to <code>src</code>, except that no register needs to be reserved for temporary storage.</p>
<p>If one of the operands is a memory address, then the operation has an implicit <code>LOCK</code> prefix, that is, the exchange operation is atomic. This can have a large performance penalty.</p>
<p>It's also worth noting that the common <code>NOP</code> (no op) instruction, <code>0x90</code>, is the opcode for <code>xchgl %eax, %eax</code>.</p>
<p><strong>Operands</strong>.</p>
<ul>
<li><code>src</code><ul>
<li>Register</li>
<li>Memory</li>
</ul>
</li>
<li><code>dest</code><ul>
<li>Register</li>
<li>Memory (only one operand can be in memory: the other must be a register)</li>
</ul>
</li>
</ul>
<p><strong>Modified flags</strong>: No FLAGS are modified by this instruction.</p>
<div class="codehilite"><pre><span class="nf">cmpxchg</span> <span class="no">arg2</span><span class="p">,</span> <span class="no">arg1</span>
</pre></div>


<div class="codehilite"><pre><span class="nf">cmpxchg</span> <span class="nv">arg1</span><span class="p">,</span> <span class="nv">arg2</span>
</pre></div>


<p>Compare and exchange.</p>
<h4 id="move-with-zero-extend">Move with zero extend</h4>
<div class="codehilite"><pre><span class="nf">movz</span> <span class="no">src</span><span class="p">,</span> <span class="no">dest</span>
</pre></div>


<div class="codehilite"><pre><span class="nf">movzx</span> <span class="nv">dest</span><span class="p">,</span> <span class="nv">src</span>
</pre></div>


<h4 id="sign-extend">Sign Extend</h4>
<div class="codehilite"><pre><span class="nf">movs</span> <span class="no">src</span><span class="p">,</span> <span class="no">dest</span>
</pre></div>


<div class="codehilite"><pre><span class="nf">movsx</span> <span class="nv">dest</span><span class="p">,</span> <span class="nv">src</span>
</pre></div>


<h4 id="move-string">Move String</h4>
<div class="codehilite"><pre><span class="nf">movsb</span>
</pre></div>


<p><code>movsb</code>: Move byte</p>
<div class="codehilite"><pre><span class="nf">movsw</span>
</pre></div>


<p><code>movsw</code>: Move word</p>
<h4 id="load-effective-address">Load Effective Address</h4>
<div class="codehilite"><pre><span class="nf">lea</span> <span class="no">src</span><span class="p">,</span> <span class="no">dest</span>
</pre></div>


<div class="codehilite"><pre><span class="nf">lea</span> <span class="nv">dest</span><span class="p">,</span> <span class="nv">src</span>
</pre></div>


<h3 id="control-flow-instructions">Control Flow Instructions</h3>
<p>Almost all programming languages have the ability to change the order in which statements are evaluated, and assembly is no exception. The instruction pointer (EIP) register contains the address of the next instruction to be executed. To change the flow of control, the programmer must be able to modify the value of EIP. This is where control flow functions come in.</p>
<h4 id="comparison-test-and-cmp">Comparison: <code>test</code> and <code>cmp</code></h4>
<div class="codehilite"><pre><span class="nf">test</span> <span class="no">arg1</span><span class="p">,</span> <span class="no">arg2</span>
</pre></div>


<div class="codehilite"><pre><span class="nf">test</span> <span class="nv">arg2</span><span class="p">,</span> <span class="nv">arg1</span>
</pre></div>


<p>Performs a bit-wise logical AND on <code>arg1</code> and <code>arg2</code> the result of which we will refer to as Temp and sets the ZF (zero), SF (sign) and PF (parity) flags based on <code>Temp</code>. <code>Temp</code> is then discarded.</p>
<div class="codehilite"><pre><span class="nf">cmp</span> <span class="no">arg2</span><span class="p">,</span> <span class="no">arg1</span>
</pre></div>


<div class="codehilite"><pre><span class="nf">cmp</span> <span class="nv">arg1</span><span class="p">,</span> <span class="nv">arg2</span>
</pre></div>


<h4 id="jump-instructions">Jump Instructions</h4>
<h5 id="unconditional-jumps"><strong>Unconditional Jumps</strong></h5>
<div class="codehilite"><pre><span class="nf">jmp</span> <span class="nv">loc</span>
</pre></div>


<h5 id="jump-on-equality"><strong>Jump on Equality</strong></h5>
<div class="codehilite"><pre><span class="nf">je</span> <span class="nv">loc</span>
</pre></div>


<h5 id="jump-on-inequality"><strong>Jump on Inequality</strong></h5>
<div class="codehilite"><pre><span class="nf">jne</span> <span class="nv">loc</span>
</pre></div>


<h5 id="jump-if-greater"><strong>Jump if Greater</strong></h5>
<h5 id="jump-if-less"><strong>Jump if Less</strong></h5>
<h5 id="jump-on-zero"><strong>Jump on Zero</strong></h5>
<h5 id="jump-on-sign"><strong>Jump on Sign</strong></h5>
<h4 id="function-calls">Function Calls</h4>
<div class="codehilite"><pre><span class="nf">call</span> <span class="nv">proc</span>
</pre></div>


<p>Pushes the address of the next opcode onto the top of the stack, and jumps to the specified location. This is used mostly for subroutines.</p>
<div class="codehilite"><pre><span class="nf">ret</span> <span class="p">[</span><span class="nv">val</span><span class="p">]</span>
</pre></div>


<p>Loads the next value on the stack into EIP, and then pops the specified number of bytes off the stack. If <code>val</code> is not supplied, the instruction will not pop any values off the stack after returning.</p>
<h4 id="loop-instructions">Loop Instructions</h4>
<div class="codehilite"><pre><span class="nf">loop</span> <span class="nv">arg</span>
</pre></div>


<p>The loop instruction decrements ECX and jumps to the address specified by arg unless decrementing ECX caused its value to become zero. For example:</p>
<div class="codehilite"><pre><span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="mi">5</span>
<span class="nl">start_loop:</span>
<span class="c1">; the code here would be executed 5 times</span>
<span class="nf">loop</span> <span class="nv">start_loop</span>
</pre></div>


<h4 id="enter-and-leave">Enter and Leave</h4>
<div class="codehilite"><pre><span class="nf">enter</span> <span class="nv">arg</span>
</pre></div>


<p><code>enter</code> creates a stack frame with the specified amount of space allocated on the stack.</p>
<div class="codehilite"><pre><span class="nf">leave</span>
</pre></div>


<p><code>leave</code> destroys the current stack frame, and restores the previous frame. Using Intel syntax this is equivalent to:</p>
<div class="codehilite"><pre><span class="nf">mov</span> <span class="nb">esp</span><span class="p">,</span> <span class="nb">ebp</span>
<span class="nf">pop</span> <span class="nb">ebp</span>
</pre></div>


<h4 id="other-control-instructions">Other Control Instructions</h4>
<div class="codehilite"><pre><span class="nf">hlt</span>
</pre></div>


<p>Halts the processor. Execution will be resumed after processing next hardware interrupt, unless IF is cleared.</p>
<div class="codehilite"><pre><span class="nf">nop</span>
</pre></div>


<p>No operation. This instruction doesn't do anything, but wastes an instruction cycle in the processor. This instruction is often represented as an XCHG operation with the operands EAX and EAX.</p>
<div class="codehilite"><pre><span class="nf">lock</span>
</pre></div>


<p>Asserts #LOCK prefix on next instruction.</p>
<div class="codehilite"><pre><span class="nf">wait</span>
</pre></div>


<p>Waits for the FPU to finish its last calculation.</p>
<h3 id="arithmetic-instructions">Arithmetic Instructions</h3>
<h3 id="logic-instructions">Logic Instructions</h3>
<h3 id="shift-and-rotate-instructions">Shift and Rotate Instructions</h3>
<h3 id="other-instructions">Other Instructions</h3>
<h4 id="stack-instructions">Stack Instructions</h4>
<div class="codehilite"><pre><span class="nf">push</span> <span class="nv">arg</span>
</pre></div>


<p>This instruction decrements the stack pointer and stores the data specified as the argument into the location pointed to by the stack pointer.</p>
<div class="codehilite"><pre><span class="nf">pop</span> <span class="nv">arg</span>
</pre></div>


<p>This instruction loads the data stored in the location pointed to by the stack pointer into the argument specified and then increments the stack pointer.</p>
<h4 id="flags-instructions">Flags instructions</h4>
<h3 id="x86-interrupts">x86 Interrupts</h3>
<p>Interrupts are special routines that are defined on a per-system basis. This means that the interrupts on one system might be different from the interrupts on another system. Therefore, it is usually a bad idea to rely heavily on interrupts when you are writing code that needs to be portable.</p>
<h4 id="interrupt-instruction">Interrupt Instruction</h4>
<div class="codehilite"><pre><span class="nf">int</span> <span class="nv">arg</span>
</pre></div>


<p>This instruction issues the specified interrupt. For instance:</p>
<div class="codehilite"><pre><span class="nf">int</span> <span class="mh">0x0A</span>
</pre></div>


<p>Calls interrupt 10 (0x0A (hex) = 10 (decimal)).</p>
<h4 id="types-of-interrupts">Types of Interrupts</h4>
<p>There are 3 types of interrupts: Hardware Interrupts, Software Interrupts and Exceptions.</p>
<h5 id="hardware-interrupts"><strong>Hardware Interrupts</strong></h5>
<p>Hardware interrupts are triggered by hardware devices. Hardware interrupts are typically asynchronous: their occurrence is unrelated to the instructions being executed at the time they are raised.</p>
<h5 id="software-interrupts"><strong>Software Interrupts</strong></h5>
<p>Software interrupts are usually used to transfer control to a function in the operating system kernel. Software interrupts are triggered by the instruction <code>int</code>. For example, the instruction <code>int 14h</code> triggers interrupt <code>0x14</code>. The processor then stops the current program, and jumps to the code to handle interrupt 14. When interrupt handling is complete, the processor returns flow to the original program.</p>
<h5 id="exceptions"><strong>Exceptions</strong></h5>
<p>Exceptions are caused by exceptional conditions in the code which is executing, for example an attempt to divide by zero or access a protected memory area. The processor will detect this problem, and transfer control to a handler to service the exception. This handler may re-execute the offending code after changing some value (for example, the zero dividend), or if this cannot be done, the program causing the exception may be terminated.</p>
<h3 id="x86-assemblers">x86 Assemblers</h3>
<h3 id="gas-syntax">GAS Syntax</h3>
<h3 id="masm-syntax">MASM Syntax</h3>
<h3 id="interfacing-with-linux-system-calls">Interfacing with Linux: System Calls</h3>
<p><small><a href="https://en.wikibooks.org/wiki/X86_Assembly/Interfacing_with_Linux">Interfacing with Linux</a></small></p>
<h4 id="syscalls">Syscalls</h4>
<p>Syscalls are the interface between user programs and the Linux kernel. They are used to let the kernel perform various system tasks, such as file access, process management and networking. In the C programming language, you would normally call a wrapper function which executes all required steps or even use high-level features such as the standard IO library.</p>
<p>On Linux, there are several ways to make a syscall. This page will focus on making syscalls by calling a software interrupt using <code>int $0x80</code> (x86 and x86_64) or <code>syscall</code> (x86_64). This is an easy and intuitive method of making syscalls in assembly-only programs.</p>
<h4 id="making-a-syscalls">Making a syscalls</h4>
<p>To make a syscall using an interrupt, you have to pass all required information to the kernel by copying them into general purpose registers. Each syscall has a fixed number (note the numbers differ between <code>int $0x80</code> and <code>syscall</code> in the following text). You specify the syscall by writing the number into the <code>eax</code>/<code>rax</code> register and pass the parameters by writing them in the appropriate registers before making the actual calls. Parameters are passed in the order they appear in the function signature of the corresponding C wrapper function.</p>
<p>After everything is set up correctly, you call the interrupt using <code>int $0x80</code> or <code>syscall</code> and the kernel performs the task.</p>
<p>The return or error value of a syscall is written to <code>eax</code> or <code>rax</code>.</p>
<p>The kernel uses its own stack to perform the actions. The user stack is not touched in any way.</p>
<h4 id="int-0x80"><code>int 0x80</code></h4>
<p>On both Linux x86 and Linux x86_64 systems you can make a syscall by calling interrupt 0x80 using the <code>int $0x80</code> command. Parameters are passed by setting the general purpose registers as following:</p>
<table>
<thead>
<tr>
<th>Syscall #</th>
<th>Param 1</th>
<th>Param 2</th>
<th>Param 3</th>
<th>Param 4</th>
<th>Param 5</th>
<th>Param 6</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>eax</code></td>
<td><code>ebx</code></td>
<td><code>ecx</code></td>
<td><code>edx</code></td>
<td><code>esi</code></td>
<td><code>edi</code></td>
<td><code>ebp</code></td>
</tr>
</tbody>
</table>
<p>The return value is in the <code>eax</code> register.</p>
<p>The syscall numbers are described in the Linux source file <a href="https://github.com/shichao-an/linux/blob/v2.6.34/arch/x86/include/asm/unistd_32.h">arch/x86/include/asm/unistd_32.h</a>.</p>
<p>All registers are preserved during the syscall.</p>
<h4 id="syscall"><code>syscall</code></h4>
<p>The x86_64 architecture introduced a dedicated instruction to make a syscall. It does not access the interrupt descriptor table and is faster. Parameters are passed by setting the general purpose registers as following:</p>
<p>The syscall numbers are described in the Linux source file <a href="https://github.com/shichao-an/linux/blob/v2.6.34/arch/x86/include/asm/unistd_64.h">arch/x86/include/asm/unistd_64.h</a>.</p>
<table>
<thead>
<tr>
<th>Syscall #</th>
<th>Param 1</th>
<th>Param 2</th>
<th>Param 3</th>
<th>Param 4</th>
<th>Param 5</th>
<th>Param 6</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rax</code></td>
<td><code>rdi</code></td>
<td><code>rsi</code></td>
<td><code>rdx</code></td>
<td><code>rcx</code></td>
<td><code>r8</code></td>
<td><code>r9</code></td>
</tr>
</tbody>
</table>
<p>The return value is in the <code>rax</code> register.</p>
<p>All registers, except <code>rcx</code> and <code>r11</code>, are preserved during the syscall.</p>
<h4 id="hello-world-example">Hello World example</h4>
<p>This example will write the text "Hello World" to stdout using the <code>write</code> syscall and quit the program using the <code>_exit</code> syscall.</p>
<p>Syscall signatures:</p>
<div class="codehilite"><pre><span class="kt">ssize_t</span> <span class="nf">write</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">_exit</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">);</span>
</pre></div>


<p>The following is the C program of this example:</p>
<div class="codehilite"><pre><span class="cp">#include &lt;unistd.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Hello World</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span> <span class="cm">/* write &quot;Hello World&quot; to stdout */</span>
    <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>                      <span class="cm">/* exit with error code 0 (no error) */</span>
<span class="p">}</span>
</pre></div>


<p>Both of the assembly examples start alike: a string stored in the data segment and <code>_start</code> as a global symbol.</p>
<div class="codehilite"><pre><span class="na">.data</span>
<span class="nl">msg:</span> <span class="na">.ascii</span> <span class="s">&quot;Hello World\n&quot;</span>

<span class="na">.text</span>
<span class="na">.global</span> <span class="no">_start</span>
</pre></div>


<h5 id="int-0x80_1"><strong><code>int 0x80</code></strong></h5>
<p>As defined in <code>arch/x86/include/asm/unistd_32.h</code>, the syscall numbers for <code>write</code> and <code>_exit</code> are:</p>
<div class="codehilite"><pre><span class="cp">#define __NR_exit 1</span>
<span class="cp">#define __NR_write 4</span>
</pre></div>


<p>The parameters are passed exactly as one would in a C program, using the correct registers. After everything is set up, the syscall is made using <code>int $0x80</code>.</p>
<div class="codehilite"><pre><span class="nl">_start:</span>
    <span class="nf">movl</span> <span class="no">$4</span><span class="p">,</span> <span class="nv">%eax</span>   <span class="c"># use the write syscall</span>
    <span class="nf">movl</span> <span class="no">$1</span><span class="p">,</span> <span class="nv">%ebx</span>   <span class="c"># write to stdout</span>
    <span class="nf">movl</span> <span class="no">$msg</span><span class="p">,</span> <span class="nv">%ecx</span> <span class="c"># use string &quot;Hello World&quot;</span>
    <span class="nf">movl</span> <span class="no">$12</span><span class="p">,</span> <span class="nv">%edx</span>  <span class="c"># write 12 characters</span>
    <span class="nf">int</span> <span class="no">$0x80</span>       <span class="c"># make syscall</span>

    <span class="nf">movl</span> <span class="no">$1</span><span class="p">,</span> <span class="nv">%eax</span>   <span class="c"># use the _exit syscall</span>
    <span class="nf">movl</span> <span class="no">$0</span><span class="p">,</span> <span class="nv">%ebx</span>   <span class="c"># error code 0</span>
    <span class="nf">int</span> <span class="no">$0x80</span>       <span class="c"># make syscall</span>
</pre></div>


<h5 id="syscall_1"><strong><code>syscall</code></strong></h5>
<p>In <code>arch/x86/include/asm/unistd_64.h</code>, the syscall numbers are defined as following:</p>
<div class="codehilite"><pre><span class="cp">#define __NR_write 1</span>
<span class="cp">#define __NR_exit 60</span>
</pre></div>


<p>Parameters are passed just like in the <code>int $0x80</code> example, except that the order of the registers is different. The syscall is made using <code>syscall</code>.</p>
<div class="codehilite"><pre><span class="nl">_start:</span>
    <span class="nf">movq</span> <span class="no">$1</span><span class="p">,</span> <span class="nv">%rax</span>   <span class="c"># use the write syscall</span>
    <span class="nf">movq</span> <span class="no">$1</span><span class="p">,</span> <span class="nv">%rdi</span>   <span class="c"># write to stdout</span>
    <span class="nf">movq</span> <span class="no">$msg</span><span class="p">,</span> <span class="nv">%rsi</span> <span class="c"># use string &quot;Hello World&quot;</span>
    <span class="nf">movq</span> <span class="no">$12</span><span class="p">,</span> <span class="nv">%rdx</span>  <span class="c"># write 12 characters</span>
    <span class="nf">syscall</span>         <span class="c"># make syscall</span>

    <span class="nf">movq</span> <span class="no">$60</span><span class="p">,</span> <span class="nv">%rax</span>  <span class="c"># use the _exit syscall</span>
    <span class="nf">movq</span> <span class="no">$0</span><span class="p">,</span> <span class="nv">%rdi</span>   <span class="c"># error code 0</span>
    <span class="nf">syscall</span>         <span class="c"># make syscall</span>
</pre></div>


<hr />
<h3 id="references">References</h3>
<ul>
<li><a href="https://en.wikibooks.org/wiki/X86_Assembly">x86 Assembly</a>: <a href="https://en.wikibooks.org/wiki/X86_Assembly/Print_Version">X86 Assembly/Print Version</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_assembly_language">x86 assembly language</a></li>
</ul>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script src="../js/base.js"></script>
        <script src="../custom.js"></script>
    </body>
</html>