<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/gopl/ch6/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 6. Methods - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../lkd/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch5/">Chapter 5. System Calls</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch7/">Chapter 7. Interrupts and Interrupt Handlers</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch8/">Chapter 8. Bottom Halves and Deferring Work</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch9/">Chapter 9. An Introduction to Kernel Synchronization</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch10/">Chapter 10. Kernel Synchronization Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch11/">Chapter 11. Timers and Time Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch12/">Chapter 12. Memory Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch13/">Chapter 13. The Virtual Filesystem</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch14/">Chapter 14. The Block I/O Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch15/">Chapter 15. The Process Address Space</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch16/">Chapter 16. The Page Cache and Page Writeback</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li class="active">
                            <a href="./">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/gopl/ch6.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-6-methods">Chapter 6. Methods</a></li>
        
    
        <li class="main "><a href="#method-declarations">Method Declarations</a></li>
        
    
        <li class="main "><a href="#methods-with-a-pointer-receiver">Methods with a Pointer Receiver</a></li>
        
            <li><a href="#summary-of-three-cases">Summary of three cases *</a></li>
        
            <li><a href="#nil-is-a-valid-receiver-value">Nil Is a Valid Receiver Value</a></li>
        
    
        <li class="main "><a href="#composing-types-by-struct-embedding">Composing Types by Struct Embedding</a></li>
        
    
        <li class="main "><a href="#method-values-and-expressions">Method Values and Expressions</a></li>
        
            <li><a href="#method-values">Method Values *</a></li>
        
            <li><a href="#method-expressions">Method Expressions *</a></li>
        
    
        <li class="main "><a href="#example-bit-vector-type">Example: Bit Vector Type</a></li>
        
    
        <li class="main "><a href="#encapsulation">Encapsulation</a></li>
        
            <li><a href="#benefits-of-encapsulation">Benefits of encapsulation *</a></li>
        
    
        <li class="main "><a href="#doubts-and-solution">Doubts and Solution</a></li>
        
            <li><a href="#verbatim">Verbatim</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-6-methods"><strong>Chapter 6. Methods</strong></h3>
<p>An <em>object</em> is a value or variable that has methods, and a <em>method</em> is a function associated with a particular type. An object-oriented program uses methods to express the properties and operations of each data structure so that clients need not access the object's representation directly.</p>
<p>[p155]</p>
<p>This chapter discusses the following topics on methods:</p>
<ul>
<li>How to define and use methods effectively</li>
<li>Encapsulation</li>
<li>Composition</li>
</ul>
<h3 id="method-declarations">Method Declarations</h3>
<p>A method is declared with a variant of the ordinary function declaration in which an extra parameter appears before the function name. The parameter attaches the function to the type of that parameter.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch6/geometry/geometry.go">gopl.io/ch6/geometry/geometry.go</a></small></p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">geometry</span>

<span class="kn">import</span> <span class="s">&quot;math&quot;</span>

<span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="c1">// traditional function</span>
<span class="kd">func</span> <span class="nx">Distance</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Hypot</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// same thing, but as a method of the Point type</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Hypot</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>The extra parameter <code>p</code> is called the method's <em>receiver</em>, a legacy from early object-oriented languages that described calling a method as "sending a message to an object".</p>
<p>In Go, the receiver does not have a special name like <code>this</code> or <code>self</code>; it's naming is similar to any other parameter. Since the receiver name will be frequently used, it's a good idea to choose something short and to be consistent across methods. A common choice is the first letter of the type name, like <code>p</code> for <code>Point</code>.</p>
<p>In a method call, the receiver argument appears before the method name. This parallels the declaration, in which the receiver parameter appears before the method name.</p>
<div class="codehilite"><pre><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span><span class="p">))</span> <span class="c1">// &quot;5&quot;, function call</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">))</span>  <span class="c1">// &quot;5&quot;, method call</span>
</pre></div>


<p>There's no conflict between the two declarations of functions called <code>Distance</code> above:</p>
<ul>
<li>The first declares a package-level function called <code>geometry.Distance</code>.</li>
<li>The second declares a method of the type <code>Point</code> called <code>Point.Distance</code>.</li>
</ul>
<p>Since each type has its own name space for methods, we can use the name <code>Distance</code> for other methods as long as they belong to different types. The following example defines a type <code>Path</code> that represents a sequence of line segments and a <code>Distance</code> method:</p>
<div class="codehilite"><pre><span class="c1">// A Path is a journey connecting the points with straight lines.</span>
<span class="kd">type</span> <span class="nx">Path</span> <span class="p">[]</span><span class="nx">Point</span>

<span class="c1">// Distance returns the distance traveled along the path.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">path</span> <span class="nx">Path</span><span class="p">)</span> <span class="nx">Distance</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">:=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">path</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">path</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">path</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">sum</span>
<span class="p">}</span>
</pre></div>


<p>Although <code>Path</code> is a named slice type, not a struct type like <code>Point</code>, we can still define methods for it.</p>
<p>Unlike many other object-oriented languages, <u>Go allows methods to be associated with any type, such as numbers, strings, slices, maps, and even functions.</u> Methods may be declared on any named type defined in the same package, so long as its underlying type is neither a pointer nor an interface.</p>
<p>The two <code>Distance</code> methods have different types. They're not related to each other at all, though <code>Path.Distance</code> uses <code>Point.Distance</code> internally to compute the length of each segment that connects adjacent points.</p>
<p>The following code calls the new method to compute the perimeter of a right triangle:</p>
<div class="codehilite"><pre><span class="nx">perim</span> <span class="o">:=</span> <span class="nx">Path</span><span class="p">{</span>
    <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">perim</span><span class="p">.</span><span class="nx">Distance</span><span class="p">())</span> <span class="c1">// &quot;12&quot;</span>
</pre></div>


<p>In the two examples above, there are two calls to methods named <code>Distance</code>. <u>The compiler determines which function to call based on both the method name and the type of the receiver.</u></p>
<ul>
<li>In the first, <code>path[i-1]</code> has type <code>Point</code> so <code>Point.Distance</code> is called.</li>
<li>In the second, <code>perim</code> has type <code>Path</code>, so <code>Path.Distance</code> is called.</li>
</ul>
<p>All methods of a given type must have unique names, but different types can use the same name for a method, like the <code>Distance</code> methods for <code>Point</code> and <code>Path</code>; there's no need to qualify function names (for example, <code>PathDistance</code>) to disambiguate. The first benefit to using methods over ordinary functions is: method names can be shorter. This benefit is magnified for calls originating outside the package, since they can use the shorter name and omit the package name:</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="s">&quot;gopl.io/ch6/geometry&quot;</span>
<span class="nx">perim</span> <span class="o">:=</span> <span class="nx">geometry</span><span class="p">.</span><span class="nx">Path</span><span class="p">{{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">geometry</span><span class="p">.</span><span class="nx">PathDistance</span><span class="p">(</span><span class="nx">perim</span><span class="p">))</span> <span class="c1">// &quot;12&quot;, standalone function</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">perim</span><span class="p">.</span><span class="nx">Distance</span><span class="p">())</span>             <span class="c1">// &quot;12&quot;, method of geometry.Path</span>
</pre></div>


<h3 id="methods-with-a-pointer-receiver">Methods with a Pointer Receiver</h3>
<p>Calling a function makes a copy of each argument value. If either of the following occurs, we must pass the address of the variable using a pointer:</p>
<ul>
<li>The function needs to update a variable.</li>
<li>An argument is so large that we wish to avoid copying it.</li>
</ul>
<p>The same goes for methods that need to update the receiver variable: we attach them to the pointer type, such as <code>*Point</code>. For example:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Point</span><span class="p">)</span> <span class="nx">ScaleBy</span><span class="p">(</span><span class="nx">factor</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">*=</span> <span class="nx">factor</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">*=</span> <span class="nx">factor</span>
<span class="p">}</span>
</pre></div>


<p>The name of this method is <code>(*Point).ScaleBy</code>. The parentheses are necessary; without them, the expression would be parsed as <code>*(Point.ScaleBy)</code>.</p>
<p>Convention dictates that if any method of <code>Point</code> has a pointer receiver, then all methods of <code>Point</code> should have a pointer receiver, even ones that don't strictly need it.  We've broken this rule for <code>Point</code> so that we can show both kinds of method.</p>
<p>Named types (<code>Point</code>) and pointers to them (<code>*Point</code>) are the only types that may appear in a
receiver declaration. <u>To avoid ambiguities, method declarations are not permitted on named types that are themselves <code>pointer</code> types</u>:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">P</span> <span class="o">*</span><span class="kt">int</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">P</span><span class="p">)</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span> <span class="c1">// compile error: invalid receiver type</span>
</pre></div>


<p>The <code>(*Point).ScaleBy</code> method can be called by providing a <code>*Point</code> receiver. The following three cases are equivalent:</p>
<div class="codehilite"><pre><span class="nx">r</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">r</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">r</span><span class="p">)</span> <span class="c1">// &quot;{2, 4}&quot;</span>
</pre></div>


<div class="codehilite"><pre><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">pptr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">p</span>
<span class="nx">pptr</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// &quot;{2, 4}&quot;</span>
</pre></div>


<div class="codehilite"><pre><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">).</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// &quot;{2, 4}&quot;</span>
</pre></div>


<p>The last two cases are verbose; <u>if the receiver <code>p</code> is a variable of type <code>Point</code> but the method requires a *Point receiver, the compiler will perform an implicit <code>&amp;p</code> on the variable.</u> So we can use the following shorthand:</p>
<div class="codehilite"><pre><span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>


<p>This works only for variables, including struct fields like <code>p.X</code> and array or slice elements like <code>perim[0]</code>. We cannot call a <code>*Point</code> method on a non-addressable <code>Point</code> receiver, because there's no way to obtain the address of a temporary value. For example:</p>
<div class="codehilite"><pre><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// compile error: can&#39;t take address of Point literal</span>
</pre></div>


<p>However, we can call a <code>Point</code> method (e.g. <code>Point.Distance</code>) with a <code>*Point</code> receiver, because there is a way to obtain the value from the address by loading the value pointed to by the receiver. The compiler will perform an implicit <code>*</code> on the variable. These two function calls are equivalent:</p>
<div class="codehilite"><pre><span class="nx">pptr</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
<span class="p">(</span><span class="o">*</span><span class="nx">pptr</span><span class="p">).</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
</pre></div>


<h4 id="summary-of-three-cases">Summary of three cases *</h4>
<p>In every valid method call expression, exactly one of these three statements is true.</p>
<p><strong>Case 1: the receiver argument has the same type as the receiver parameter.</strong> For example, both have type <code>T</code> or both have type <code>*T</code>:</p>
<div class="codehilite"><pre><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span> <span class="c1">// Point</span>
<span class="nx">pptr</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>         <span class="c1">// *Point</span>
</pre></div>


<p><strong>Case 2: the receiver argument is a variable of type <code>T</code> and the receiver parameter has type <code>*T</code>.</strong> The compiler implicitly takes the address of the variable. For example:</p>
<div class="codehilite"><pre><span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// implicit (&amp;p)</span>
</pre></div>


<p><strong>Case 3: the receiver argument has type <code>*T</code> and the receiver parameter has type <code>T</code>.</strong> The compiler implicitly dereferences the receiver, in other words, loads the value. For example:</p>
<div class="codehilite"><pre><span class="nx">pptr</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span> <span class="c1">// implicit (*pptr)</span>
</pre></div>


<p>If all the methods of a named type <code>T</code> have a receiver type of <code>T</code> itself (not <code>*T</code>), it is safe to copy instances of that type; calling any of its methods necessarily makes a copy. For example, <code>time.Duration</code> values are liberally copied, including as arguments to functions.</p>
<p>But if any method has a pointer receiver, you should avoid copying instances of <code>T</code> because doing so may violate internal invariants. For example, copying an instance of <code>bytes.Buffer</code> would cause the original and the copy to alias (<a href="../ch2/#pointers">Section 2.3.2</a>) the same underlying array of bytes. Subsequent method calls would have unpredictable effects.</p>
<h4 id="nil-is-a-valid-receiver-value">Nil Is a Valid Receiver Value</h4>
<p>Some methods allow nil pointers as their receivers, especially if <code>nil</code> is a meaningful zero value of the type (e.g. maps and slices), just as some functions allow nil pointers as arguments. For example, <code>nil</code> represents the empty list:</p>
<div class="codehilite"><pre><span class="c1">// An IntList is a linked list of integers.</span>
<span class="c1">// A nil *IntList represents the empty list.</span>
<span class="kd">type</span> <span class="nx">IntList</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Value</span> <span class="kt">int</span>
    <span class="nx">Tail</span> <span class="o">*</span><span class="nx">IntList</span>
<span class="p">}</span>

<span class="c1">// Sum returns the sum of the list elements.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">list</span> <span class="o">*</span><span class="nx">IntList</span><span class="p">)</span> <span class="nx">Sum</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">list</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">list</span><span class="p">.</span><span class="nx">Value</span> <span class="o">+</span> <span class="nx">list</span><span class="p">.</span><span class="nx">Tail</span><span class="p">.</span><span class="nx">Sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>When you define a type whose methods allow nil as a receiver value, it's worth documenting this explicitly in the comment, as in the example above.</p>
<p>The following is part of the definition of the Values type from the <a href="https://golang.org/pkg/net/url/"><code>net/url</code></a> package:</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">url</span>

<span class="c1">// Values maps a string key to a list of values.</span>
<span class="kd">type</span> <span class="nx">Values</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span>

<span class="c1">// Get returns the first value associated with the given key,</span>
<span class="c1">// or &quot;&quot; if there are none.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Values</span><span class="p">)</span> <span class="nx">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">vs</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nb">len</span><span class="p">(</span><span class="nx">vs</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="s">&quot;&quot;</span>
<span class="p">}</span>

<span class="c1">// Add adds the value to key.</span>
<span class="c1">// It appends to any existing values associated with key.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Values</span><span class="p">)</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">v</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">v</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>It exposes its representation as a map but also provides methods to simplify access to the map, whose values are slices of strings; it's a <a href="https://en.wikipedia.org/wiki/Multimap"><em>multimap</em></a>. Its clients can use its intrinsic operators (<code>make</code>, slice literals, <code>m[key]</code>, and so on), or its methods, or both:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch6/urlvalues/main.go">gopl.io/ch6/urlvalues/main.go</a></small></p>
<div class="codehilite"><pre><span class="nx">m</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">{</span><span class="s">&quot;lang&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;en&quot;</span><span class="p">}}</span> <span class="c1">// direct construction</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">)</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">)</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;lang&quot;</span><span class="p">))</span> <span class="c1">// &quot;en&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;q&quot;</span><span class="p">))</span>    <span class="c1">// &quot;&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">))</span> <span class="c1">// &quot;1&quot;      (first value)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="s">&quot;item&quot;</span><span class="p">])</span>     <span class="c1">// &quot;[1 2]&quot;  (direct map access)</span>

<span class="nx">m</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">))</span> <span class="c1">// &quot;&quot;</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">,</span> <span class="s">&quot;3&quot;</span><span class="p">)</span>         <span class="c1">// panic: assignment to entry in nil map</span>
</pre></div>


<p>In the final call to <code>Get</code>, the nil receiver behaves like an empty map. It is equivalent to being written as <code>Values(nil).Get("item"))</code>, not <code>nil.Get("item")</code>, which will not compile because the type of <code>nil</code> has not been determined (see <a href="https://play.golang.org/p/fW0q7pRRUp">modified version of the example above</a>). By contrast, the final call to <code>Add</code> panics as it tries to update a <code>nil</code> map.</p>
<p>Because <code>url.Values</code> is a map type and a map refers to its key/value pairs indirectly, any updates and deletions that <code>url.Values.Add</code> makes to the map elements are visible to the caller. However, as with ordinary functions, any changes a method makes to the reference itself, like setting it to <code>nil</code> or making it refer to a different map data structure, will not be reflected in the caller.</p>
<h3 id="composing-types-by-struct-embedding">Composing Types by Struct Embedding</h3>
<p>The following example defines a <code>ColoredPoint</code> type:</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="s">&quot;image/color&quot;</span>

<span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">ColoredPoint</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Point</span>
    <span class="nx">Color</span> <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span>
<span class="p">}</span>
</pre></div>


<p>We could have defined <code>ColoredPoint</code> as a struct of three fields, but instead we embedded a <code>Point</code> to provide the <code>X</code> and <code>Y</code> fields. As discussed in <a href="../ch4/#struct-embedding-and-anonymous-fields">Section 4.4.3</a>, embedding enables us to take a syntactic shortcut to defining a <code>ColoredPoint</code> that contains all the fields of <code>Point</code>, plus some more. We can select the fields of <code>ColoredPoint</code> that were contributed by the embedded <code>Point</code> without mentioning <code>Point</code>:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">cp</span> <span class="nx">ColoredPoint</span>
<span class="nx">cp</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">1</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">cp</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nx">X</span><span class="p">)</span> <span class="c1">// &quot;1&quot;</span>
<span class="nx">cp</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="mi">2</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">cp</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span> <span class="c1">// &quot;2&quot;</span>
</pre></div>


<p>A similar mechanism applies to the methods of <code>Point</code>. We can call methods of the embedded <code>Point</code> field using a receiver of type <code>ColoredPoint</code>, even though <code>ColoredPoint</code> has no declared methods:</p>
<div class="codehilite"><pre><span class="nx">red</span> <span class="o">:=</span> <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">}</span>
<span class="nx">blue</span> <span class="o">:=</span> <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="p">=</span> <span class="nx">ColoredPoint</span><span class="p">{</span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="nx">red</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">q</span> <span class="p">=</span> <span class="nx">ColoredPoint</span><span class="p">{</span><span class="nx">Point</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="nx">blue</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">Point</span><span class="p">))</span> <span class="c1">// &quot;5&quot;</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">q</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">Point</span><span class="p">))</span> <span class="c1">// &quot;10&quot;</span>
</pre></div>


<p>The methods of <code>Point</code> have been <em>promoted</em> to <code>ColoredPoint</code>. In this way, <u>embedding allows complex types with many methods to be built up by the <em>composition</em> of several fields, each providing a few methods.</u></p>
<p>Note that it is a mistake to view <code>Point</code> as a base class and <code>ColoredPoint</code> as a subclass or derived class, or to interpret the relationship between these types as if a <code>ColoredPoint</code> "is a" Point, from a object-oriented language perspective. Notice the calls to <code>Distance</code> above. <code>Distance</code> has a parameter of type <code>Point</code>, and <code>q</code> is not a <code>Point</code>, so although <code>q</code> does have an embedded field of that type, we must explicitly select it. Attempting to pass <code>q</code> would be an error:</p>
<div class="codehilite"><pre><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span> <span class="c1">// compile error: cannot use q (ColoredPoint) as Point</span>
</pre></div>


<p>A <code>ColoredPoint</code> is not a <code>Point</code>, but it "has a" <code>Point</code>, and it has two additional methods <code>Distance</code> and <code>ScaleBy</code> promoted from <code>Point</code>. In terms of implementation, the embedded field instructs the compiler to generate additional wrapper methods that delegate to the declared methods, equivalent to these:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">ColoredPoint</span><span class="p">)</span> <span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">ColoredPoint</span><span class="p">)</span> <span class="nx">ScaleBy</span><span class="p">(</span><span class="nx">factor</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="nx">factor</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>When <code>Point.Distance</code> is called by the first of these wrapper methods, its receiver value is <code>p.Point</code>, not <code>p</code>. <u>There is no way for the <code>Point.Distance</code> method to access the <code>ColoredPoint</code> in which the <code>Point</code> is embedded.</u></p>
<p>The type of an anonymous field may be a pointer to a named type, in which case fields and methods are promoted indirectly from the pointed-to object. Adding another level of indirection enables us to share common structures and vary the relationships between objects dynamically. The declaration of <code>ColoredPoint</code> below embeds a <code>*Point</code>:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">ColoredPoint</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">Point</span>
    <span class="nx">Color</span> <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span>
<span class="p">}</span>

<span class="nx">p</span> <span class="o">:=</span> <span class="nx">ColoredPoint</span><span class="p">{</span><span class="o">&amp;</span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="nx">red</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">ColoredPoint</span><span class="p">{</span><span class="o">&amp;</span><span class="nx">Point</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="nx">blue</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="o">*</span><span class="nx">q</span><span class="p">.</span><span class="nx">Point</span><span class="p">))</span> <span class="c1">// &quot;5&quot;</span>
<span class="nx">q</span><span class="p">.</span><span class="nx">Point</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Point</span>                 <span class="c1">// p and q now share the same Point</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">.</span><span class="nx">Point</span><span class="p">,</span> <span class="o">*</span><span class="nx">q</span><span class="p">.</span><span class="nx">Point</span><span class="p">)</span> <span class="c1">// &quot;{2 2} {2 2}&quot;</span>
</pre></div>


<p>A struct type may have more than one anonymous field. If the declaration of <code>ColoredPoint</code> is:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">ColoredPoint</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Point</span>
    <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span>
<span class="p">}</span>
</pre></div>


<p>Then a value of this type would have the following:</p>
<ul>
<li>All the methods of <code>Point</code></li>
<li>All the methods of <code>RGBA</code></li>
<li>Any additional methods declared on <code>ColoredPoint</code> directly</li>
</ul>
<p>When the compiler resolves a selector such as <code>p.ScaleBy</code> to a method, it looks for that method in the following order:</p>
<ol>
<li>Directly declared method named <code>ScaleBy</code></li>
<li>Methods promoted once from <code>ColoredPoint</code>'s embedded fields</li>
<li>Methods promoted twice from embedded fields within <code>Point</code> and <code>RGBA</code>, and so on</li>
</ol>
<p>The compiler reports an error if the selector was ambiguous because two methods were promoted from the same rank.</p>
<p>Methods can be declared only on named types (e.g. <code>Point</code>) and pointers to them (e.g. <code>*Point</code>). With embedding, it's possible and sometimes useful for <em>unnamed</em> struct types to have methods.</p>
<p>The following example shows part of a simple cache implemented using two package-level variables, a mutex (<a href="ch9.md##mutual-exclusion-syncmutex">Section 9.2</a>) and the map that it guards:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// guards mapping</span>
    <span class="nx">mapping</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">Lookup</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="nx">v</span> <span class="o">:=</span> <span class="nx">mapping</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
    <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>
</pre></div>


<p>The version below is functionally equivalent but groups together the two related variables in a single package-level variable, cache:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">cache</span> <span class="p">=</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="nx">mapping</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
<span class="p">}</span> <span class="p">{</span>
    <span class="nx">mapping</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Lookup</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">cache</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="nx">v</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">mapping</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
    <span class="nx">cache</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>
</pre></div>


<p>The new variable gives more expressive names to the variables related to the cache, and because the <code>sync.Mutex</code> field is embedded within it, its <code>Lock</code> and <code>Unlock</code> methods are promoted to the unnamed struct type, allowing us to lock the <code>cache</code> with a self-explanatory syntax.</p>
<h3 id="method-values-and-expressions">Method Values and Expressions</h3>
<h4 id="method-values">Method Values *</h4>
<p>Usually, we select and call a method in the same expression, as in <code>p.Distance()</code>, but it's possible to separate these two operations. The selector <code>p.Distance</code> yields a <strong>method value</strong>, a function that binds a method (<code>Point.Distance</code>) to a specific receiver value <code>p</code>. This function can then be invoked without a receiver value; it needs only the non-receiver arguments.</p>
<div class="codehilite"><pre><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="nx">distanceFromP</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span> <span class="c1">// method value</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">distanceFromP</span><span class="p">(</span><span class="nx">q</span><span class="p">))</span> <span class="c1">// &quot;5&quot;</span>
<span class="kd">var</span> <span class="nx">origin</span> <span class="nx">Point</span> <span class="c1">// {0, 0}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">distanceFromP</span><span class="p">(</span><span class="nx">origin</span><span class="p">))</span> <span class="c1">// &quot;2.23606797749979&quot;, 5</span>
<span class="nx">scaleP</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span> <span class="c1">// method value</span>
<span class="nx">scaleP</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// p becomes (2, 4)</span>
<span class="nx">scaleP</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// then (6, 12)</span>
<span class="nx">scaleP</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1">// then (60, 120)</span>
</pre></div>


<p>Method values are useful when a package's API requires a function value and the clients' desired behavior for that function is to call a method on a specific receiver.</p>
<p>For example, the function <a href="https://golang.org/pkg/time/#AfterFunc"><code>time.AfterFunc</code></a> calls a function value after a specified delay. The following program uses it to launch the rocket <code>r</code> after 10 seconds:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">Rocket</span> <span class="kd">struct</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Rocket</span><span class="p">)</span> <span class="nx">Launch</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="nx">r</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Rocket</span><span class="p">)</span>
<span class="nx">time</span><span class="p">.</span><span class="nx">AfterFunc</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Launch</span><span class="p">()</span> <span class="p">})</span>
</pre></div>


<p>The last line above can be replaced with a shorter equivalent method value synatx:</p>
<div class="codehilite"><pre><span class="nx">time</span><span class="p">.</span><span class="nx">AfterFunc</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Launch</span><span class="p">)</span>
</pre></div>


<h4 id="method-expressions">Method Expressions *</h4>
<p>Related to the method value is the <strong>method expression</strong>. When calling a method, as opposed to an ordinary function, we must supply the receiver in a special way using the selector syntax. A method expression, written <code>T.f</code> or <code>(*T).f</code> where <code>T</code> is a type, yields a function value with a regular first parameter taking the place of the receiver, so it can be called in the usual way.</p>
<div class="codehilite"><pre><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="nx">distance</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">.</span><span class="nx">Distance</span> <span class="c1">// method expression</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">distance</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span><span class="p">))</span> <span class="c1">// &quot;5&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">distance</span><span class="p">)</span> <span class="c1">// &quot;func(Point, Point) float64&quot;</span>
<span class="nx">scale</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">Point</span><span class="p">).</span><span class="nx">ScaleBy</span>
<span class="nx">scale</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// &quot;{2 4}&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">scale</span><span class="p">)</span> <span class="c1">// &quot;func(*Point, float64)&quot;</span>
</pre></div>


<p>Method expressions can be helpful when you need a value to represent a choice among several methods belonging to the same type so that you can call the chosen method with many different receivers.</p>
<p>In the following example, the variable <code>op</code> represents either the addition or the subtraction method of type <code>Point</code>, and <code>Path.TranslateBy</code> calls it for each point in the <code>Path</code>:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Point</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Point</span><span class="p">{</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">+</span> <span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">+</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="p">}</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Sub</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Point</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Point</span><span class="p">{</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">-</span> <span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">-</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="p">}</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">Path</span> <span class="p">[]</span><span class="nx">Point</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">path</span> <span class="nx">Path</span><span class="p">)</span> <span class="nx">TranslateBy</span><span class="p">(</span><span class="nx">offset</span> <span class="nx">Point</span><span class="p">,</span> <span class="nx">add</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">op</span> <span class="kd">func</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Point</span>
    <span class="k">if</span> <span class="nx">add</span> <span class="p">{</span>
        <span class="nx">op</span> <span class="p">=</span> <span class="nx">Point</span><span class="p">.</span><span class="nx">Add</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">op</span> <span class="p">=</span> <span class="nx">Point</span><span class="p">.</span><span class="nx">Sub</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">path</span> <span class="p">{</span>
        <span class="c1">// Call either path[i].Add(offset) or path[i].Sub(offset).</span>
        <span class="nx">path</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">op</span><span class="p">(</span><span class="nx">path</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">offset</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h3 id="example-bit-vector-type">Example: Bit Vector Type</h3>
<p>Sets in Go are usually implemented as a <code>map[T]bool</code>, where <code>T</code> is the element type. Although a set represented by a map is very flexible, a specialized representation may outperform it. A <a href="https://en.wikipedia.org/wiki/Bit_array"><strong>bit vector</strong></a> is ideal in the following example cases:</p>
<ul>
<li>Dataflow analysis where set elements are small non-negative integers.</li>
<li>Sets have many elements.</li>
<li>Set operations like union and intersection are common.</li>
</ul>
<p>A bit vector uses a slice of unsigned integer values or "words", each bit of which represents a possible element of the set. The set contains <code>i</code> if the <code>i</code>-th bit is set. The following program demonstrates a simple bit vector type with three methods:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch6/intset/intset.go">gopl.io/ch6/intset/intset.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// An IntSet is a set of small non-negative integers.</span>
<span class="c1">// Its zero value represents the empty set.</span>
<span class="kd">type</span> <span class="nx">IntSet</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">words</span> <span class="p">[]</span><span class="kt">uint64</span>
<span class="p">}</span>

<span class="c1">// Has reports whether the set contains the non-negative value x.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">Has</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="nx">word</span><span class="p">,</span> <span class="nx">bit</span> <span class="o">:=</span> <span class="nx">x</span><span class="o">/</span><span class="mi">64</span><span class="p">,</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">x</span><span class="o">%</span><span class="mi">64</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">word</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">[</span><span class="nx">word</span><span class="p">]</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">bit</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// Add adds the non-negative value x to the set.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">word</span><span class="p">,</span> <span class="nx">bit</span> <span class="o">:=</span> <span class="nx">x</span><span class="o">/</span><span class="mi">64</span><span class="p">,</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">x</span><span class="o">%</span><span class="mi">64</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">word</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">s</span><span class="p">.</span><span class="nx">words</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">[</span><span class="nx">word</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">bit</span>
<span class="p">}</span>

<span class="c1">// UnionWith sets s to the union of s and t.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">UnionWith</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">tword</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">t</span><span class="p">.</span><span class="nx">words</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">|=</span> <span class="nx">tword</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">s</span><span class="p">.</span><span class="nx">words</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">,</span> <span class="nx">tword</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Since each word has 64 bits, to locate the bit for <code>x</code>, we use the quotient <code>x/64</code> as the word index and the remainder <code>x%64</code> as the bit index within that word. The <code>UnionWith</code> operation uses the bitwise OR operator <code>|</code> to compute the union 64 elements at a time.</p>
<p>The following code defines a method to print an <code>IntSet</code> as a string:</p>
<div class="codehilite"><pre><span class="c1">// String returns the set as a string of the form &quot;{1 2 3}&quot;.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;{&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">word</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">words</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">word</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">word</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nb">uint</span><span class="p">(</span><span class="nx">j</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="s">&quot;{&quot;</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="mi">64</span><span class="o">*</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;}&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>Notice the similarity of the <code>String</code> method above with <a href="https://github.com/shichao-an/gopl.io/blob/master/ch3/printints/main.go"><code>intsToString</code></a> in <a href="../ch3/#strings-and-byte-slices">Section 3.5.4</a>:</p>
<ul>
<li><code>bytes.Buffer</code> is often used this way in <code>String</code> methods.</li>
<li>The <code>fmt</code> package treats types with a <code>String</code> method specially so that values of complicated types can display themselves in a user-friendly manner. Instead of printing the raw representation of the value (a struct in this case), <code>fmt</code> calls the <code>String</code> method.</li>
<li>The mechanism relies on interfaces and type assertions, which is explained in <a href="../ch7/">Chapter 7</a>.</li>
</ul>
<p>The following code demonstrates the use of <code>IntSet</code>:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="nx">IntSet</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">144</span><span class="p">)</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &quot;{1 9 144}&quot;</span>

<span class="nx">y</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="nx">y</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &quot;{9 42}&quot;</span>

<span class="nx">x</span><span class="p">.</span><span class="nx">UnionWith</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">y</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &quot;{1 9 42 144}&quot;</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">Has</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Has</span><span class="p">(</span><span class="mi">123</span><span class="p">))</span> <span class="c1">// &quot;true false&quot;</span>
</pre></div>


<p>Note that we declared <code>String</code> and <code>Has</code> as methods of the pointer type <code>*IntSet</code> not out of necessity, but for consistency with the other two methods (<code>Add</code> and <code>UnionWith</code>), which need a pointer receiver because they assign to <code>s.words</code>. Consequently, an <code>IntSet</code> value does not have a <code>String</code> method:</p>
<div class="codehilite"><pre><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">)</span>         <span class="c1">// &quot;{1 9 42 144}&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &quot;{1 9 42 144}&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>          <span class="c1">// &quot;{[4398046511618 0 65536]}&quot;</span>
</pre></div>


<ol>
<li>In the first case, we print an <code>*IntSet</code> pointer, which does have a <code>String</code> method.</li>
<li>In the second case, we call <code>String()</code> on an <code>IntSet</code> variable; the compiler inserts the implicit <code>&amp;</code> operation, giving us a pointer, which has the <code>String</code> method.</li>
<li>In the third case, because the <code>IntSet</code> value does not have a <code>String</code> method, <code>fmt.Println</code> prints the representation of the struct instead. It's important not to forget the <code>&amp;</code> operator. Making <code>String</code> a method of <code>IntSet</code>, not <code>*IntSet</code>, might be a good idea, but this is a case-by-case judgment.</li>
</ol>
<h3 id="encapsulation">Encapsulation</h3>
<p>A variable or method of an object is said to be <em>encapsulated</em> if it is inaccessible to clients of the object. <a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)">Encapsulation</a>, sometimes called <a href="https://en.wikipedia.org/wiki/Information_hiding"><em>information hiding</em></a>, is a key aspect of object-oriented programming.</p>
<p>Go has only one mechanism to control the visibility of names: capitalized identifiers are exported from the package in which they are defined, and uncapitalized names are not. This mechanism not only limits access to members of a package, but also limits access to the fields of a struct or the methods of a type. As a consequence, to encapsulate an object, it must be made into a struct.</p>
<p>That's the reason the <code>IntSet</code> type from the previous section was declared as a struct type, even though it has only a single field:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">IntSet</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">words</span> <span class="p">[]</span><span class="kt">uint64</span>
<span class="p">}</span>
</pre></div>


<p><code>IntSet</code> could be defined as a slice type as follows (we also have to replace each occurrence of <code>s.words</code> by <code>*s</code> in its methods):</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">IntSet</span> <span class="p">[]</span><span class="kt">uint64</span>
</pre></div>


<p>Although this version of <code>IntSet</code> would be essentially equivalent, it would allow clients from other packages to read and modify the slice directly. In other words, whereas the expression <code>*s</code> could be used in any package, <code>s.words</code> may appear only in the package that defines <code>IntSet</code>.</p>
<p>Another consequence of this name-based mechanism is that the unit of encapsulation is the package, not the type as in many other languages. <u>The fields of a struct type are visible to all code within the same package.</u> Whether the code appears in a function or a method makes no difference.</p>
<h4 id="benefits-of-encapsulation">Benefits of encapsulation *</h4>
<p>Encapsulation provides three benefits.</p>
<p>First, because clients cannot directly modify the object's variables, one need inspect fewer statements to understand the possible values of those variables.</p>
<p>Second, hiding implementation details prevents clients from depending on things that might change, which gives the designer greater freedom to evolve the implementation without breaking API compatibility.</p>
<p>For example, the <code>bytes.Buffer</code> type is frequently used to accumulate very short strings. For optimization, it reserves a little extra space in the object to avoid memory allocation in this common case. Since <code>Buffer</code> is a struct type, this space takes the form of an extra field of type <code>[64]byte</code> with an uncapitalized name. When this field was added, because it was not exported, clients of <code>Buffer</code> outside the bytes package were unaware of any change except improved performance. <code>Buffer</code> and its <code>Grow</code> method are shown below (simplified for clarity):</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">Buffer</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">buf</span> <span class="p">[]</span><span class="kt">byte</span>
    <span class="nx">initial</span> <span class="p">[</span><span class="mi">64</span><span class="p">]</span><span class="kt">byte</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>

<span class="c1">// Grow expands the buffer&#39;s capacity, if necessary,</span>
<span class="c1">// to guarantee space for another n bytes. [...]</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="nx">Grow</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">initial</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// use preallocated space initially</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span><span class="o">+</span><span class="nx">n</span> <span class="p">&gt;</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">Len</span><span class="p">(),</span> <span class="mi">2</span><span class="o">*</span><span class="nb">cap</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span> <span class="o">+</span> <span class="nx">n</span><span class="p">)</span>
        <span class="nb">copy</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span>
        <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">buf</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h3 id="doubts-and-solution">Doubts and Solution</h3>
<h4 id="verbatim">Verbatim</h4>
<h5 id="p161-pointer-receiver"><strong>p161 pointer receiver</strong></h5>
<blockquote>
<p>Any changes a method makes to the reference itself, like setting it to <code>nil</code> or making it refer to a different map data structure, will not be reflected in the caller.</p>
</blockquote>
<p><span class="text-danger">Question</span>: What does it mean?</p>
<p><span class="text-info">Solution</span>:</p>
<p>The "will not be reflected in the caller" probably means "no effect" in the caller function. This is similar to setting an argument (within the callee function) to <code>nil</code> or making it refer to another object.</p>
<h5 id="p168-pointer-receiver"><strong>p168 pointer receiver</strong></h5>
<blockquote>
<p>First, because clients cannot directly modify the object's variables, one need inspect fewer statements to understand the possible values of those variables.</p>
</blockquote>
<p><span class="text-danger">Question</span>: Not sure what it means.</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>