<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/gopl/ch8/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 8. Goroutines and Channels - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../lkd/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch5/">Chapter 5. System Calls</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch7/">Chapter 7. Interrupts and Interrupt Handlers</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch8/">Chapter 8. Bottom Halves and Deferring Work</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch9/">Chapter 9. An Introduction to Kernel Synchronization</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch10/">Chapter 10. Kernel Synchronization Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch11/">Chapter 11. Timers and Time Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch12/">Chapter 12. Memory Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch13/">Chapter 13. The Virtual Filesystem</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch14/">Chapter 14. The Block I/O Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch15/">Chapter 15. The Process Address Space</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch16/">Chapter 16. The Page Cache and Page Writeback</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li class="active">
                            <a href="./">Chapter 8. Goroutines and Channels</a>
                        </li>
                      
                        <li>
                            <a href="../ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part2/">Part 2: Advanced</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/gopl/ch8.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-8-goroutines-and-channels">Chapter 8. Goroutines and Channels</a></li>
        
    
        <li class="main "><a href="#goroutines">Goroutines</a></li>
        
    
        <li class="main "><a href="#example-concurrent-clock-server">Example: Concurrent Clock Server</a></li>
        
    
        <li class="main "><a href="#example-concurrent-echo-server">Example: Concurrent Echo Server</a></li>
        
    
        <li class="main "><a href="#channels">Channels</a></li>
        
            <li><a href="#unbuffered-channels">Unbuffered Channels</a></li>
        
            <li><a href="#pipelines">Pipelines</a></li>
        
            <li><a href="#unidirectional-channel-types">Unidirectional Channel Types</a></li>
        
            <li><a href="#buffered-channels">Buffered Channels</a></li>
        
    
        <li class="main "><a href="#looping-in-parallel">Looping in Parallel</a></li>
        
    
        <li class="main "><a href="#example-concurrent-web-crawler">Example: Concurrent Web Crawler</a></li>
        
    
        <li class="main "><a href="#multiplexing-with-select">Multiplexing with select</a></li>
        
    
        <li class="main "><a href="#example-concurrent-directory-traversal">Example: Concurrent Directory Traversal</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-8-goroutines-and-channels"><strong>Chapter 8. Goroutines and Channels</strong></h3>
<p>Concurrent programming, the expression of a program as a composition of several autonomous activities, has never been more important than it is today.</p>
<p>Go enables two styles of concurrent programming.</p>
<ul>
<li>This chapter presents goroutines and channels, which support <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">communicating sequential processes</a> (CSP), a model of concurrency in which values are passed between independent activities (goroutines) but variables are for the most part confined to a single activity.</li>
<li><a href="ch9.md">Chapter 9</a> covers some aspects of the more traditional model of <strong>shared memory multithreading</strong>, which will be familiar to those who used threads in other mainstream languages.</li>
</ul>
<h3 id="goroutines">Goroutines</h3>
<p>In Go, each concurrently executing activity is called a <em>goroutine</em>. If you have used operating system threads or threads in other languages, then you can assume for now that a goroutine is similar to a thread.  The differences between threads and goroutines are essentially quantitative, not qualitative, and will be described in <a href="ch9.md#goroutines-and-threads">Section 9.8</a>.</p>
<p>When a program starts, its only goroutine is the one that calls the <code>main</code> function, so we call it the <em>main goroutine</em>. New goroutines are created by the <code>go</code> statement:</p>
<ul>
<li>Syntactically, a <code>go</code> statement is an ordinary function or method call prefixed by the keyword <code>go</code>.</li>
<li>A <code>go</code> statement causes the function to be called in a newly created goroutine. The go statement itself completes immediately.</li>
</ul>
<div class="codehilite"><pre><span class="nx">f</span><span class="p">()</span>    <span class="c1">// call f(); wait for it to return</span>
<span class="k">go</span> <span class="nx">f</span><span class="p">()</span> <span class="c1">// create a new goroutine that calls f(); don&#39;t wait</span>
</pre></div>


<p>In the example below, the main goroutine computes the 45th Fibonacci number using an inefficient recursive algorithm, which runs for an appreciable time, during which we provide the user with a visual indication that the program is still running, by displaying an animated textual "spinner".</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/spinner/main.go">gopl.io/ch8/spinner/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nx">spinner</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
    <span class="kd">const</span> <span class="nx">n</span> <span class="p">=</span> <span class="mi">45</span>
    <span class="nx">fibN</span> <span class="o">:=</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="c1">// slow</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;\rFibonacci(%d) = %d\n&quot;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">fibN</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">spinner</span><span class="p">(</span><span class="nx">delay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="s">`-\|/`</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;\r%c&quot;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
            <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">x</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>After several seconds of animation, the <code>fib(45)</code> call returns and the main function prints its result:</p>
<div class="codehilite"><pre>Fibonacci(45) = 1134903170
</pre></div>


<p>The <code>main</code> function then returns. When this happens, all goroutines are abruptly terminated and the program exits. Other than by returning from <code>main</code> or exiting the program, there is no programmatic way for one goroutine to stop another, but as we will see later, there are ways to communicate with a goroutine to request that it stop itself.</p>
<p>Notice how the program is expressed as the composition of two autonomous activities, spinning and Fibonacci computation. Each is written as a separate function but both make progress concurrently.</p>
<h3 id="example-concurrent-clock-server">Example: Concurrent Clock Server</h3>
<p>Networking is a natural domain to use concurrency since servers typically handle many connections from their clients at once, each client being essentially independent of the others. This section introduces the <a href="https://golang.org/pkg/net/"><code>net</code></a> package, which provides the components for building networked client and server programs that communicate over TCP, UDP, or Unix domain sockets. The <a href="https://golang.org/pkg/net/http/"><code>net/http</code></a> package introduced since <a href="../ch1/">Chapter 1</a> is built on top of functions from the <code>net</code> package.</p>
<p>The first example is a sequential clock server that writes the current time to the client once per second:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/clock1/clock.go">gopl.io/ch8/clock1/clock.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// Clock1 is a TCP server that periodically writes the time.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;io&quot;</span>
    <span class="s">&quot;log&quot;</span>
    <span class="s">&quot;net&quot;</span>
    <span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">listener</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listen</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;localhost:8000&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">listener</span><span class="p">.</span><span class="nx">Accept</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// e.g., connection aborted</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="nx">handleConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span> <span class="c1">// handle one connection at a time</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">Format</span><span class="p">(</span><span class="s">&quot;15:04:05\n&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="c1">// e.g., client disconnected</span>
        <span class="p">}</span>
        <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>The <code>Listen</code> function creates a <a href="https://golang.org/pkg/net/#Listener"><code>net.Listener</code></a>, an object that listens for incoming connections on a network port, in this case TCP port <code>localhost:8000</code>. The listener's <code>Accept</code> method blocks until an incoming connection request is made, then returns a <a href="https://golang.org/pkg/net/#Conn"><code>net.Conn</code></a> object representing the connection.</li>
<li>The <code>handleConn</code> function handles one complete client connection.<ul>
<li>In a loop, it writes the current time, <code>time.Now()</code>, to the client.</li>
<li>Since <code>net.Conn</code> satisfies the <code>io.Writer</code> interface, we can write directly to it.</li>
<li>The loop ends when the write fails, most likely because the client has disconnected, at which point <code>handleConn</code> closes its side of the connection using a deferred call to <code>Close</code> and goes back to waiting for another connection request.</li>
</ul>
</li>
<li>The <code>time.Time.Format</code> method provides a way to format date and time information by example. Its argument is a template indicating how to format a reference time, specifically <code>Mon Jan 2 03:04:05PM 2006 UTC-0700</code>.<ul>
<li>The reference time has eight components. Any collection of them can appear in the <code>Format</code> string in any order and in a number of formats; the selected components of the date and time will be displayed in the selected formats. This example uses the hour, minute, and second of the time.</li>
<li>The <code>time</code> package defines templates for many standard time formats, such as <a href="https://golang.org/pkg/time/#pkg-constants"><code>time.RFC1123</code></a>. The same mechanism is used in reverse when parsing a time using <code>time.Parse</code>.</li>
</ul>
</li>
</ul>
<p>To connect to the server, we need a client program such as <code>nc</code> ("netcat"), a standard utility program for manipulating network connections:</p>
<div class="codehilite"><pre><span class="gp">$</span> go build gopl.io/ch8/clock1
<span class="gp">$</span> ./clock1 <span class="p">&amp;</span>
<span class="gp">$</span> nc localhost 8000
<span class="go">13:58:54</span>
<span class="go">13:58:55</span>
<span class="go">13:58:56</span>
<span class="go">13:58:57</span>
<span class="go">^C</span>
</pre></div>


<p>The client displays the time sent by the server each second until we interrupt the client with Control-C, which on Unix systems is echoed as <code>^C</code> by the shell. We can also use <code>telnet</code>, or the following simple Go version of <code>netcat</code> that uses <code>net.Dial</code> to connect to a TCP server:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/netcat2/netcat.go">gopl.io/ch8/netcat1/netcat.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// Netcat1 is a read-only TCP client.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;io&quot;</span>
    <span class="s">&quot;log&quot;</span>
    <span class="s">&quot;net&quot;</span>
    <span class="s">&quot;os&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;localhost:8000&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">dst</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">src</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>This program reads data from the connection and writes it to the standard output until an end-of-file condition or an error occurs. The <code>mustCopy</code> function is a utility used in several examples in this section.</p>
<p>We run two clients at the same time on different terminals, one shown to the left and one to the right:</p>
<div class="codehilite"><pre>$ go build gopl.io/ch8/netcat1
$ ./netcat1
13:58:54                        $ ./netcat1
13:58:55
13:58:56
^C
                                13:58:57
                                13:58:58
                                13:58:59
                                ^C
$ killall clock1
</pre></div>


<p>The second client must wait until the first client is finished because the server is sequential; it deals with only one client at a time.  Only one small change is needed to make the server concurrent: adding the <code>go</code> keyword to the call to <code>handleConn</code> causes each call to run in its own goroutine.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/clock2/clock.go">gopl.io/ch8/clock2/clock.go</a></small></p>
<div class="codehilite"><pre><span class="k">for</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">listener</span><span class="p">.</span><span class="nx">Accept</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// e.g., connection aborted</span>
        <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">go</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span> <span class="c1">// handle connections concurrently</span>
<span class="p">}</span>
</pre></div>


<p>Now, multiple clients can receive the time at once.</p>
<div class="codehilite"><pre>$ go build gopl.io/ch8/clock2
$ ./clock2 &amp;
$ go build gopl.io/ch8/netcat1
$ ./netcat1
14:02:54                     $ ./netcat1
14:02:55                     14:02:55
14:02:56                     14:02:56
14:02:57                     ^C
14:02:58
14:02:59                     $ ./netcat1
14:03:00                     14:03:00
14:03:01                     14:03:01
^C                           14:03:02
                             ^C
</pre></div>


<h3 id="example-concurrent-echo-server">Example: Concurrent Echo Server</h3>
<p>The clock server used one goroutine per connection. In this section, we'll build an echo server that uses multiple goroutines per connection. Most echo servers merely write whatever they read, which can be done with this trivial version of <code>handleConn</code>:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="c1">// NOTE: ignoring errors</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>This version of echo server simulates the reverberations of a real echo, with the response loud at first ("HELLO!"), then moderate ("Hello!") after a delay, then quiet ("hello!") before fading to nothing:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/reverb1/reverb.go">gopl.io/ch8/reverb1/reverb.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">echo</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">shout</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">delay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&quot;\t&quot;</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ToUpper</span><span class="p">(</span><span class="nx">shout</span><span class="p">))</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&quot;\t&quot;</span><span class="p">,</span> <span class="nx">shout</span><span class="p">)</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&quot;\t&quot;</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nx">shout</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">echo</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">(),</span> <span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// NOTE: ignoring potential errors from input.Err()</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>The following client program sends terminal input to the server while also copying the server response to the output:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/netcat2/netcat.go">gopl.io/ch8/netcat2/netcat.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;localhost:8000&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">go</span> <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span>
    <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>While the main goroutine reads the standard input and sends it to the server, a second goroutine reads and prints the server's response. When the main goroutine encounters the end of the input (for example, after the user types Control-D (<code>^D</code>)) at the terminal, the program stops, even if the other goroutine still has work to do. (<a href="#unbuffered-channels">Section 8.4.1</a> discusses how to make the program wait for both sides to finish)</p>
<div class="codehilite"><pre>$ go build gopl.io/ch8/reverb1
$ ./reverb1 &amp;
$ go build gopl.io/ch8/netcat2
$ ./netcat2
Hello?
    HELLO?
    Hello?
    hello?
Is there anybody there?
    IS THERE ANYBODY THERE?
Yooo-hooo!
    Is there anybody there?
    is there anybody there?
    YOOO-HOOO!
    Yooo-hooo!
    yooo-hooo!
^D
$ killall reverb1
</pre></div>


<p>Notice that the third shout from the client is not dealt with until the second shout has petered out, which is not very realistic. A real echo would consist of the <em>composition</em> of the three independent shouts. To simulate it, more goroutines are needed; all we need to do is add the <code>go</code> keyword, this time to the call to <code>echo</code>:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/reverb2/reverb.go">gopl.io/ch8/reverb2/reverb.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nx">echo</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">(),</span> <span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// NOTE: ignoring potential errors from input.Err()</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>The arguments to the function started by <code>go</code> are evaluated when the <code>go</code> statement itself is executed; thus <code>input.Text()</code> is evaluated in the main goroutine.</p>
<p>Now the echoes are concurrent and overlap in time:</p>
<div class="codehilite"><pre>$ go build gopl.io/ch8/reverb2
$ ./reverb2 &amp;
$ ./netcat2
Is there anybody there?
    IS THERE ANYBODY THERE?
Yooo-hooo!
    Is there anybody there?
    YOOO-HOOO!
    is there anybody there?
    Yooo-hooo!
    yooo-hooo!
^D
$ killall reverb2
</pre></div>


<p><u>All that was required to make the server use concurrency, not just to handle connections from multiple clients but even within a single connection, was the insertion of two <code>go</code> keywords.</u></p>
<p>However in adding these keywords, we had to consider carefully that it is safe to call methods of <code>net.Conn</code> concurrently, which is not true for most types. The next chapter discusses the crucial concept of concurrency safety in the.</p>
<h3 id="channels">Channels</h3>
<p>If goroutines are the activities of a concurrent Go program, channels are the connections between them.</p>
<ul>
<li>A channel is a communication mechanism that enables one goroutine to send values to another goroutine.</li>
<li>Each channel is a conduit for values of a particular type, called the channel's <em>element type</em>. The type of a channel whose elements have type int is written <code>chan int</code>.</li>
</ul>
<p>To create a channel, use the built-in <code>make</code> function:</p>
<div class="codehilite"><pre><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// ch has type &#39;chan int&#39;</span>
</pre></div>


<p>A channel is a reference to the data structure created by <code>make</code>.</p>
<ul>
<li>When we copy a channel or pass one as an argument to a function, we are copying a reference, so caller and callee refer to the same data structure.</li>
<li>As with other reference types, the zero value of a channel is <code>nil</code>.</li>
<li>Two channels of the same type may be compared using <code>==</code>. The comparison is <code>true</code> if both are references to the same channel data structure. A channel may also be compared to <code>nil</code>.</li>
</ul>
<p>A channel has two principal operations, <em>send</em> and <em>receive</em>, collectively known as <em>communications</em>. A send statement transmits a value from one goroutine, through the channel, to another goroutine executing a corresponding receive expression.</p>
<p>Both operations are written using the <code>&lt;-</code> operator.</p>
<ul>
<li>In a send statement, the <code>&lt;-</code> separates the channel and value operands.</li>
<li>In a receive expression, <code>&lt;-</code> precedes the channel operand. A receive expression whose result is not used is a valid statement.</li>
</ul>
<div class="codehilite"><pre><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">x</span> <span class="c1">// a send statement</span>

<span class="nx">x</span><span class="p">=</span><span class="o">&lt;-</span><span class="nx">ch</span>  <span class="c1">// a receive expression in an assignment statement</span>
<span class="o">&lt;-</span><span class="nx">ch</span>    <span class="c1">// a receive statement; result is discarded</span>
</pre></div>


<p>Channels support a third operation, <em>close</em>, which sets a flag indicating that no more values will ever be sent on this channel.</p>
<ul>
<li>Send operations on a closed channel will panic.</li>
<li>Receive operations on a closed channel yield the values that have been sent until no more values are left; any receive operations thereafter complete immediately and yield the zero value of the channel's element type.</li>
</ul>
<p>To close a channel, call the built-in <code>close</code> function:</p>
<div class="codehilite"><pre><span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</pre></div>


<p>A channel created with a simple call to <code>make</code> is called an <em>unbuffered</em> channel. <code>make</code> accepts an optional second argument, an integer called the channel's <em>capacity</em>. If the capacity is nonzero, <code>make</code> creates a <code>buffered</code> channel.</p>
<div class="codehilite"><pre><span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>    <span class="c1">// unbuffered channel</span>
<span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// unbuffered channel</span>
<span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// buffered channel with capacity 3</span>
</pre></div>


<p>Unbuffered channels are discussed in <a href="#unbuffered-channels">Section 8.4.1</a> and buffered channels in <a href="#buffered-channels">Section 8.4.4</a>.</p>
<h4 id="unbuffered-channels">Unbuffered Channels</h4>
<ul>
<li>A send operation on an unbuffered channel blocks the sending goroutine until another goroutine executes a corresponding receive on the same channel, at which point the value is transmitted and both goroutines may continue.</li>
<li>Conversely, if the receive operation was attempted first, the receiving goroutine is blocked until another goroutine performs a send on the same channel.</li>
</ul>
<p>Communication over an unbuffered channel causes the sending and receiving goroutines to <em>synchronize</em>. Because of this, unbuffered channels are sometimes called <em>synchronous</em> channels. When a value is sent on an unbuffered channel, the receipt of the value happens <em>before</em> the reawakening of the sending goroutine.</p>
<p>In discussions of concurrency:</p>
<ul>
<li>When we say <em>x happens before y</em>, we don't mean merely that <em>x</em> occurs earlier in time than <em>y</em>. We mean that it is guaranteed to do so and that all its prior effects (e.g. updates to variables) are complete and that you may rely on them.</li>
<li>When we say <em>x is concurrent with y</em>, we mean <em>x</em> neither happens before <em>y</em> nor after <em>y</em>.<ul>
<li>This doesn't mean that <em>x</em> and <em>y</em> are necessarily simultaneous; it merely means that we cannot assume anything about their ordering.</li>
<li>As discussed in the next chapter, it's necessary to order certain events during the program's execution to avoid the problems that arise when two goroutines access the same variable concurrently.</li>
</ul>
</li>
</ul>
<p>The client program in <a href="#example-concurrent-echo-server">Section 8.3</a> copies input to the server in its main goroutine, so the client program terminates as soon as the input stream closes, even if the background goroutine is still working. To make the program wait for the background goroutine to complete before exiting, we use a channel to synchronize the two goroutines:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/netcat3/netcat.go">gopl.io/ch8/netcat3/netcat.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;localhost:8000&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span> <span class="c1">// NOTE: ignoring errors</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;done&quot;</span><span class="p">)</span>
        <span class="nx">done</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span> <span class="c1">// signal the main goroutine</span>
    <span class="p">}()</span>
    <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
    <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="o">&lt;-</span><span class="nx">done</span> <span class="c1">// wait for background goroutine to finish</span>
<span class="p">}</span>
</pre></div>


<p>When the user closes the standard input stream, <code>mustCopy</code> returns and the main goroutine calls <code>conn.Close()</code>, closing both halves of the network connection:</p>
<ul>
<li>Closing the write half of the connection causes the server to see an end-of-file condition.</li>
<li>Closing the read half causes the background goroutine's call to <code>io.Copy</code> to return a "read from closed connection" error, which is why we've removed the error logging. Notice that the go statement calls a literal function, a common construction.</li>
</ul>
<p>Before it returns, the background goroutine logs a message, then sends a value on the done channel. The main goroutine waits until it has received this value before returning. As a result, the program always logs the "<code>done</code>" message before exiting.</p>
<p>Messages sent over channels have two important aspects. Each message has a value, but sometimes the fact of communication and the moment at which it occurs are important. We call messages <em>events</em> when we wish to stress this aspect. When the event carries no additional information, that is, its sole purpose is synchronization, we'll emphasize this by using a channel whose element type is <code>struct{}</code>, though it's common to use a channel of <code>bool</code> or <code>int</code> for the same purpose since <code>done &lt;- 1</code> is shorter than <code>done &lt;- struct{}{}</code>.</p>
<h4 id="pipelines">Pipelines</h4>
<p>Channels can be used to connect goroutines together so that the output of one is the input to another. This is called a <em>pipeline</em>. The program below consists of three goroutines connected by two channels, as shown the following figure.</p>
<p><a href="../figure_8.1.png" title="Figure 8.1. A three-stage pipeline."><img alt="Figure 8.1. A three-stage pipeline." src="../figure_8.1_600.png" /></a></p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/pipeline1/main.go">gopl.io/ch8/pipeline1/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">naturals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="nx">squares</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

    <span class="c1">// Counter</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
            <span class="nx">naturals</span> <span class="o">&lt;-</span> <span class="nx">x</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="c1">// Squarer</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">naturals</span>
            <span class="nx">squares</span> <span class="o">&lt;-</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="c1">// Printer (in main goroutine)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">squares</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The first goroutine, <code>counter</code>, generates the integers 0, 1, 2, ..., and sends them over a channel to the second goroutine, <code>squarer</code>, which receives each value, squares it, and sends the result over another channel to the third goroutine, <code>printer</code>, which receives the squared values and prints them.</p>
<p>This program prints the infinite series of squares 0, 1, 4, 9, and so on. Pipelines like this may be found in long-running server programs where channels are used for lifelong communication between goroutines containing infinite loops.  If the sender knows that no further values will ever be sent on a channel, it is useful to communicate this fact to the receiver goroutines so that they can stop waiting. This is accomplished by closing the channel using the built-in <code>close</code> function:</p>
<div class="codehilite"><pre><span class="nb">close</span><span class="p">(</span><span class="nx">naturals</span><span class="p">)</span>
</pre></div>


<p>After a channel has been closed, any further send operations on it will panic. After the closed channel has been <em>drained</em> (that is, after the last sent element has been received), all subsequent receive operations will proceed without blocking but will yield a zero value. Closing the <code>naturals</code> channel above would cause the <code>squarer</code>'s loop to spin as it receives a never-ending stream of zero values, and to send these zeros to the <code>printer</code>.</p>
<p>There is no way to test directly whether a channel has been closed, but there is a variant of the receive operation that produces two results: the received channel element, plus a boolean value, conventionally called <code>ok</code>, which is <code>true</code> for a successful receive and <code>false</code> for a receive on a closed and drained channel. Using this feature, we can modify the <code>squarer</code>'s loop to stop when the <code>naturals</code> channel is drained and close the <code>squares</code> channel in turn.</p>
<div class="codehilite"><pre><span class="c1">// Squarer</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">x</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">naturals</span>
        <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
            <span class="k">break</span> <span class="c1">// channel was closed and drained</span>
        <span class="p">}</span>
        <span class="nx">squares</span> <span class="o">&lt;-</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>
    <span class="p">}</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">squares</span><span class="p">)</span>
<span class="p">}()</span>
</pre></div>


<p>Since this pattern is common, the language enables us to use a <code>range</code> loop to iterate over channels. This is a more convenient syntax for receiving all the values sent on a channel and terminating the loop after the last one. In the pipeline below, when the <code>counter</code> goroutine finishes its loop after 100 elements, it closes the <code>naturals</code> channel, causing the <code>squarer</code> to finish its loop and close the <code>squares</code> channel. Finally, the main goroutine finishes its loop and the program exits. In a more complex program, it might make sense for the <code>counter</code> and <code>squarer</code> functions to defer the calls to <code>close</code> at the outset.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/pipeline2/main.go">gopl.io/ch8/pipeline2/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">naturals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="nx">squares</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

    <span class="c1">// Counter</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
            <span class="nx">naturals</span> <span class="o">&lt;-</span> <span class="nx">x</span>
        <span class="p">}</span>
        <span class="nb">close</span><span class="p">(</span><span class="nx">naturals</span><span class="p">)</span>
    <span class="p">}()</span>

    <span class="c1">// Squarer</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">naturals</span> <span class="p">{</span>
            <span class="nx">squares</span> <span class="o">&lt;-</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>
        <span class="p">}</span>
        <span class="nb">close</span><span class="p">(</span><span class="nx">squares</span><span class="p">)</span>
    <span class="p">}()</span>

    <span class="c1">// Printer (in main goroutine)</span>
    <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">squares</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Not every channel needs closing. It's only necessary to close a channel when it is important to tell the receiving goroutines that all data have been sent. A channel that the garbage collector determines to be unreachable will have its resources reclaimed whether or not it is closed. (Don't confuse this with the <code>close</code> operation for open files. It is important to call the <code>Close</code> method on every file when you've finished with it.) Attempting to close an already-closed channel causes a panic, as does closing a <code>nil</code> channel. Closing channels has another use as a broadcast mechanism (<a href="#cancellation">Section 8.9</a>).</p>
<h4 id="unidirectional-channel-types">Unidirectional Channel Types</h4>
<p>As programs grow, it is natural to break up large functions into smaller pieces. The previous example program naturally divides into three functions:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">out</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="nx">squarer</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">in</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="nx">printer</span><span class="p">(</span><span class="nx">in</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</pre></div>


<p>The <code>squarer</code> function takes two parameters, the input channel and the output channel: <code>in</code> is only to be received from, and <code>out</code> is only to be sent to. The names <code>in</code> and <code>out</code> convey this intention, but nothing prevents squarer from sending to in or receiving from out.</p>
<p>This arrangement is typical. When a channel is supplied as a function parameter, it is nearly always with the intent that it be used exclusively for sending or exclusively for receiving.</p>
<p>To document this intent and prevent misuse, the Go type system provides <em>unidirectional</em> channel types that expose only one of the send and receive operations:</p>
<ul>
<li>The type <code>chan&lt;- int</code>, a send-only channel of <code>int</code>, allows sends but not receives.</li>
<li>The type <code>&lt;-chan int</code>, a receive-only channel of <code>int</code>, allows receives but not sends.</li>
</ul>
<p>Violations of this discipline are detected at compile time.</p>
<p>Since the <code>close</code> operation asserts that no more sends will occur on a channel, only the sending goroutine is in a position to call it, and for this reason it is a compile-time error to attempt to close a receive-only channel.</p>
<p>The following program is the squaring pipeline with unidirectional channel types:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/pipeline3/main.go">gopl.io/ch8/pipeline3/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">out</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">x</span>
    <span class="p">}</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">squarer</span><span class="p">(</span><span class="nx">out</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
        <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">v</span> <span class="o">*</span> <span class="nx">v</span>
    <span class="p">}</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">printer</span><span class="p">(</span><span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">naturals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="nx">squares</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

    <span class="k">go</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">naturals</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">squarer</span><span class="p">(</span><span class="nx">squares</span><span class="p">,</span> <span class="nx">naturals</span><span class="p">)</span>
    <span class="nx">printer</span><span class="p">(</span><span class="nx">squares</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>The call <code>counter(naturals)</code> implicitly converts naturals, a value of type <code>chan int</code>, to the type of the parameter, <code>chan&lt;- int</code>.</li>
<li>The <code>printer(squares)</code> call does a similar implicit conversion to <code>&lt;-chan int</code>.</li>
</ul>
<p>Conversions from bidirectional to unidirectional channel types are permitted in any assignment, but not backward. Once you have a value of a unidirectional type such as <code>chan&lt;- int</code>, there is no way to obtain from it a value of type <code>chan int</code> that refers to the same channel data structure.</p>
<h4 id="buffered-channels">Buffered Channels</h4>
<p>A buffered channel has a queue of elements. The queue's maximum size is determined  by the capacity argument to <code>make</code> when it is created. The statement below creates a buffered channel capable of holding three string values.</p>
<div class="codehilite"><pre><span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>


<p>The following figure a graphical representation of <code>ch</code> and the channel to which it refers.</p>
<p><a href="../figure_8.2.png" title="Figure 8.2. An empty buffered channel."><img alt="Figure 8.2. An empty buffered channel." src="../figure_8.2.png" /></a></p>
<p>A send operation on a buffered channel inserts an element at the back of the queue, and a receive operation removes an element from the front.</p>
<ul>
<li>If the channel is full, the send operation blocks its goroutine until space is made available by another goroutine's receive.</li>
<li>If the channel is empty, a receive operation blocks until a value is sent by another goroutine.</li>
</ul>
<p>We can send up to three values on this channel without the goroutine blocking:</p>
<div class="codehilite"><pre><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&quot;A&quot;</span>
<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&quot;B&quot;</span>
<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&quot;C&quot;</span>
</pre></div>


<p>At this point, the channel is full, as shown below; a fourth send statement would block.</p>
<p><a href="../figure_8.3.png" title="Figure 8.3. A full buffered channel."><img alt="Figure 8.3. A full buffered channel." src="../figure_8.3.png" /></a></p>
<p>If we receive one value like this:</p>
<div class="codehilite"><pre><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// &quot;A&quot;</span>
</pre></div>


<p>The channel is neither full nor empty (as shown in the figure below), so either a send operation or a receive operation could proceed without blocking. In this way, <u>the channel's buffer decouples the sending and receiving goroutines.</u></p>
<p><a href="../figure_8.4.png" title="Figure 8.4. A partially full buffered channel."><img alt="Figure 8.4. A partially full buffered channel." src="../figure_8.4.png" /></a></p>
<p>The built-in <code>cap</code> function obtains the channel's buffer capacity:</p>
<div class="codehilite"><pre><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">ch</span><span class="p">))</span> <span class="c1">// &quot;3&quot;</span>
</pre></div>


<p>The built-in <code>len</code> function returns the number of elements currently buffered</p>
<div class="codehilite"><pre><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">ch</span><span class="p">))</span> <span class="c1">// &quot;2&quot;</span>
</pre></div>


<p>Since in a concurrent program this information is likely to be stale as soon as it is retrieved, its value is limited, but it could conceivably be useful during fault diagnosis or performance optimization.</p>
<p>After two more receive operations the channel is empty again, and a fourth would block:</p>
<div class="codehilite"><pre><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// &quot;B&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// &quot;C&quot;</span>
</pre></div>


<p>In real programs, the send and receive operations are usually performed by different goroutines. It is a mistake to use buffered channels within a single goroutine as a queue. Channels are deeply connected to goroutine scheduling, and without another goroutine receiving from the channel, a sender (and perhaps the whole program) risks becoming blocked forever.</p>
<p>The example below shows an application of a buffered channel. It makes parallel requests to three mirror sites. It sends their responses over a buffered channel, then receives and returns only the first response, which is the quickest one to arrive. Thus <code>mirroredQuery</code> returns a result even before the two slower servers have responded. (It's quite normal for several goroutines to send values to the same channel concurrently, as in this example, or to receive from the same channel.)</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">mirroredQuery</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">responses</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">responses</span> <span class="o">&lt;-</span> <span class="nx">request</span><span class="p">(</span><span class="s">&quot;asia.gopl.io&quot;</span><span class="p">)</span> <span class="p">}()</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">responses</span> <span class="o">&lt;-</span> <span class="nx">request</span><span class="p">(</span><span class="s">&quot;europe.gopl.io&quot;</span><span class="p">)</span> <span class="p">}()</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">responses</span> <span class="o">&lt;-</span> <span class="nx">request</span><span class="p">(</span><span class="s">&quot;americas.gopl.io&quot;</span><span class="p">)</span> <span class="p">}()</span>
    <span class="k">return</span> <span class="o">&lt;-</span><span class="nx">responses</span> <span class="c1">// return the quickest response</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">request</span><span class="p">(</span><span class="nx">hostname</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">response</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</pre></div>


<p>If we had used an unbuffered channel in the above example, the two slower goroutines would have gotten stuck trying to send their responses on a channel from which no goroutine will ever receive. This situation, called a <em>goroutine leak</em>, would be a bug. <u>Unlike garbage variables, leaked goroutines are not automatically collected, so it is important to make sure that goroutines terminate themselves when no longer needed.</u></p>
<p>The choice between unbuffered and buffered channels, and the choice of a buffered channel's capacity, may both affect the correctness of a program.</p>
<ul>
<li>Unbuffered channels give stronger synchronization guarantees because every send operation is synchronized with its corresponding receive</li>
<li>With buffered channels, the send and receive operations are decoupled.</li>
</ul>
<p>When we know an upper bound on the number of values that will be sent on a channel, it's not unusual to create a buffered channel of that size and perform all the sends before the first value is received. Failure to allocate sufficient buffer capacity would cause the program to deadlock.</p>
<h5 id="packaging-cake-example"><strong>Packaging cake example</strong> *</h5>
<p>Channel buffering may also affect program performance. Imagine three cooks in a cake shop, one baking, one icing, and one inscribing each cake before passing it on to the next cook in the assembly line:</p>
<ul>
<li>In a kitchen with little space, each cook that has finished a cake must wait for the next cook to become ready to accept it. This is analogous to communication over an unbuffered channel.</li>
<li>If there is space for one cake between each cook, a cook may place a finished cake there and immediately start work on the next. This is analogous to a buffered channel with capacity 1.<ul>
<li>As long as the cooks work at about the same rate on average, most of these handovers proceed quickly, smoothing out transient differences in their respective rates.</li>
<li>More space between cooks (larger buffers) can smooth out bigger transient variations in their rates without stalling the assembly line, such as happens when one cook takes a short break, then later rushes to catch up.</li>
</ul>
</li>
</ul>
<p>On the other hand, a buffer provides no benefit in either of the following case:</p>
<ul>
<li>When an earlier stage of the assembly line is consistently faster than the following stage, the buffer between them will spend most of its time full.</li>
<li>When a later stage is faster, the buffer will usually be empty.</li>
</ul>
<p>If the second stage is more elaborate, a single cook may not be able to keep up with the supply from the first cook or meet the demand from the third. To solve the problem, we could hire another cook to help the second, performing the same task but working independently. This is analogous to creating another goroutine communicating over the same channels.</p>
<p>The <a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/cake/cake.go">gopl.io/ch8/cake</a> package simulates this cake shop, with several parameters.</p>
<h3 id="looping-in-parallel">Looping in Parallel</h3>
<p>This section explores some common concurrency patterns for executing all the iterations of a loop in parallel. The following examples consider the problem of producing thumbnail-size images from a set of full-size ones. The <a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/thumbnail/thumbnail.go">gopl.io/ch8/thumbnail</a> package provides an <code>ImageFile</code> function that can scale a single image.</p>
<p>The program below loops over a list of image file names and produces a thumbnail for each one:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/thumbnail/thumbnail_test.go">gopl.io/ch8/thumbnail/thumbnail_test.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// makeThumbnails makes thumbnails of the specified files.</span>
<span class="kd">func</span> <span class="nx">makeThumbnails</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The order in which we process the files doesn't matter, since each scaling operation is independent of all the others. Problems like this that consist entirely of subproblems that are completely independent of each other are described as <a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel"><em>embarrassingly parallel</em></a>. Embarrassingly parallel problems are the easiest kind to implement concurrently and enjoy performance that scales linearly with the amount of parallelism.</p>
<p>The following first attempt at a concurrent version just adds a <code>go</code> keyword. Let's ignore errors for now and address them later.</p>
<div class="codehilite"><pre><span class="c1">// NOTE: incorrect!</span>
<span class="kd">func</span> <span class="nx">makeThumbnails2</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// NOTE: ignoring errors</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>This version runs too fast, since it takes less time than the original, even when the slice of file names contains only a single element. This is because <code>makeThumbnails</code> returns before it has finished doing what it was supposed to do. It starts all the goroutines, one per file name, but doesn't wait for them to finish.</p>
<p>There is no direct way to wait until a goroutine has finished, but we can change the inner goroutine to report its completion to the outer goroutine by sending an event on a shared channel. Since we know that there are exactly <code>len(filenames)</code> inner goroutines, the outer goroutine need only count that many events before it returns:</p>
<div class="codehilite"><pre><span class="c1">// makeThumbnails3 makes thumbnails of the specified files in parallel.</span>
<span class="kd">func</span> <span class="nx">makeThumbnails3</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">f</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// NOTE: ignoring errors</span>
            <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
        <span class="p">}(</span><span class="nx">f</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// Wait for goroutines to complete.</span>
    <span class="k">for</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
        <span class="o">&lt;-</span><span class="nx">ch</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Notice that we passed the value of <code>f</code> as an explicit argument to the literal function instead of using the declaration of <code>f</code> from the enclosing for loop (as shown below):</p>
<div class="codehilite"><pre><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// NOTE: incorrect!</span>
        <span class="c1">// ...</span>
    <span class="p">}()</span>
<span class="p">}</span>
</pre></div>


<p>Recall the problem of loop variable capture inside an anonymous function, described in <a href="../ch5/#caveat-capturing-iteration-variables">Section 5.6.1</a>. In the above code, the single variable <code>f</code> is shared by all the anonymous function values and updated by successive loop iterations. By the time the new goroutines start executing the literal function, the <code>for</code> loop may have updated <code>f</code> and started another iteration or finished entirely, so when these goroutines read the value of <code>f</code>, they all observe it to have the value of the final element of the slice. By adding an explicit parameter, we ensure that we use the value of <code>f</code> that is current when the go statement is executed.</p>
<p>In the next version of <code>makeThumbnails</code>, if an worker goroutine's call to <code>thumbnail.ImageFile</code> fails to create a file, it returns an error to the main goroutine. <code>makeThumbnails4</code> returns the first error it receives from any of the scaling operations:</p>
<div class="codehilite"><pre><span class="c1">// makeThumbnails4 makes thumbnails for the specified files in parallel.</span>
<span class="c1">// It returns an error if any step failed.</span>
<span class="kd">func</span> <span class="nx">makeThumbnails4</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">errors</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">)</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">f</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
            <span class="nx">errors</span> <span class="o">&lt;-</span> <span class="nx">err</span>
        <span class="p">}(</span><span class="nx">f</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">errors</span><span class="p">;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">err</span> <span class="c1">// NOTE: incorrect: goroutine leak!</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>


<p>This function has a subtle bug. When it encounters the first non-nil error, it returns the error to the caller, leaving no goroutine draining the errors channel. Each remaining worker goroutine will block forever when it tries to send a value on that channel, and will never terminate. This results in a goroutine leak (<a href="#buffered-channels">Section 8.4.4</a>), which may cause the whole program to get stuck or to run out of memory.</p>
<p>The simplest solution is to use a buffered channel with sufficient capacity that no worker goroutine will block when it sends a message. An alternative solution is to create another goroutine to drain the channel while the main goroutine returns the first error without delay.</p>
<p>The next version of <code>makeThumbnails</code> uses a buffered channel to return the names of the generated image files along with any errors.</p>
<div class="codehilite"><pre><span class="c1">// makeThumbnails5 makes thumbnails for the specified files in parallel.</span>
<span class="c1">// It returns the generated file names in an arbitrary order,</span>
<span class="c1">// or an error if any step failed.</span>
<span class="kd">func</span> <span class="nx">makeThumbnails5</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">thumbfiles</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">type</span> <span class="nx">item</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">thumbfile</span> <span class="kt">string</span>
        <span class="nx">err</span>       <span class="kt">error</span>
    <span class="p">}</span>

    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">item</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">filenames</span><span class="p">))</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">f</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">it</span> <span class="nx">item</span>
            <span class="nx">it</span><span class="p">.</span><span class="nx">thumbfile</span><span class="p">,</span> <span class="nx">it</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
            <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">it</span>
        <span class="p">}(</span><span class="nx">f</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
        <span class="nx">it</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
        <span class="k">if</span> <span class="nx">it</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">it</span><span class="p">.</span><span class="nx">err</span>
        <span class="p">}</span>
        <span class="nx">thumbfiles</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">thumbfiles</span><span class="p">,</span> <span class="nx">it</span><span class="p">.</span><span class="nx">thumbfile</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">thumbfiles</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>


<p>The final version of <code>makeThumbnails</code> is shown below. It returns the total number of bytes occupied by the new files. Unlike the previous versions, however, it receives the file names not as a slice but over a channel of strings, so we cannot predict the number of loop iterations.</p>
<p>To know when the last goroutine has finished (which may not be the last one to start), we need to increment a counter before each goroutine starts and decrement it as each goroutine finishes. This demands a special kind of counter that can be safely manipulated from multiple goroutines and that provides a way to wait until it becomes zero. This counter type is known as <a href="https://golang.org/pkg/sync/#WaitGroup"><code>sync.WaitGroup</code></a> as shown in the code below:</p>
<div class="codehilite"><pre><span class="c1">// makeThumbnails6 makes thumbnails for each file received from the channel.</span>
<span class="c1">// It returns the number of bytes occupied by the files it creates.</span>
<span class="kd">func</span> <span class="nx">makeThumbnails6</span><span class="p">(</span><span class="nx">filenames</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
    <span class="nx">sizes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int64</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span> <span class="c1">// number of working goroutines</span>
    <span class="k">for</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">// worker</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">f</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
            <span class="nx">thumb</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="p">}</span>
            <span class="nx">info</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stat</span><span class="p">(</span><span class="nx">thumb</span><span class="p">)</span> <span class="c1">// OK to ignore error</span>
            <span class="nx">sizes</span> <span class="o">&lt;-</span> <span class="nx">info</span><span class="p">.</span><span class="nx">Size</span><span class="p">()</span>
        <span class="p">}(</span><span class="nx">f</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// closer</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
        <span class="nb">close</span><span class="p">(</span><span class="nx">sizes</span><span class="p">)</span>
    <span class="p">}()</span>

    <span class="kd">var</span> <span class="nx">total</span> <span class="kt">int64</span>
    <span class="k">for</span> <span class="nx">size</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sizes</span> <span class="p">{</span>
        <span class="nx">total</span> <span class="o">+=</span> <span class="nx">size</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">total</span>
<span class="p">}</span>
</pre></div>


<p>The structure of the code above is a common and idiomatic pattern for looping in parallel when we don't know the number of iterations:</p>
<ul>
<li>Note the asymmetry in the <code>Add</code> and <code>Done</code> methods.<ul>
<li><code>Add</code> increments the counter and must be called before the worker goroutine starts, not within it; <u>otherwise we would not be sure that the <code>Add</code> happens before the "closer" goroutine calls <code>Wait</code>.</u></li>
<li><code>Add</code> takes a parameter, but <code>Done</code> does not; it's equivalent to <code>Add(-1)</code>. We use <code>defer</code> to ensure that the counter is decremented even in the error case.</li>
</ul>
</li>
<li>The <code>sizes</code> channel carries each file size back to the main goroutine, which receives them using a <code>range</code> loop and computes the sum.</li>
<li>Observe how we create a closer goroutine that waits for the workers to finish before closing the <code>sizes</code> channel. These two operations, <code>wait</code> and <code>close</code>, must be concurrent with the loop over <code>sizes</code>. Consider the alternatives:<ul>
<li>If the <code>wait</code> operation were placed in the main goroutine before the loop, it would never end.</li>
<li>If the <code>wait</code> operation were placed after the loop, it would be unreachable since with nothing closing the channel, the loop would never terminate.</li>
</ul>
</li>
</ul>
<p>The following figure illustrates the sequence of events in the <code>makeThumbnails6</code> function:</p>
<p><a href="../figure_8.5.png" title="Figure 8.5. The sequence of events in makeThumbnails6."><img alt="Figure 8.5. The sequence of events in makeThumbnails6." src="../figure_8.5_600.png" /></a></p>
<ul>
<li>The vertical lines represent goroutines.</li>
<li>The thin segments indicate sleep, the thick segments activity.</li>
<li>The diagonal arrows indicate events that synchronize one goroutine with another.</li>
</ul>
<p>Notice how the main goroutine spends most of its time in the <code>range</code> loop asleep, waiting for a worker to send a value or the closer to close the channel.</p>
<h3 id="example-concurrent-web-crawler">Example: Concurrent Web Crawler</h3>
<p><a href="../ch5/#anonymous-functions">Section 5.6</a> shows a simple web crawler that explored the link graph of the web in breadth-first order. In this section show is concurrent version so that independent calls to <code>crawl</code> can exploit the I/O parallelism available in the web. The <code>crawl</code> function remains exactly as it was in <a href="https://github.com/shichao-an/gopl.io/blob/master/ch5/findlinks3/findlinks.go">gopl.io/ch5/findlinks3</a>:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/crawl1/findlinks.go">gopl.io/ch8/crawl1/findlinks.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="nx">list</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">Extract</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">list</span>
<span class="p">}</span>
</pre></div>


<p>The main function resembles <code>breadthFirst</code> (<a href="../ch5/#anonymous-functions">Section 5.6</a>):</p>
<ul>
<li>As before, a <code>worklist</code> records the queue of items that need processing, each item being a list of URLs to crawl, but this time a channel is used instead of a slice.</li>
<li>Each call to <code>crawl</code> occurs in its own goroutine and sends the links it discovers back to the <code>worklist</code>.</li>
</ul>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">worklist</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>

    <span class="c1">// Start with the command-line arguments.</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">}()</span>

    <span class="c1">// Crawl the web concurrently.</span>
    <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">list</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">worklist</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">list</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">{</span>
                <span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">link</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span>
                <span class="p">}(</span><span class="nx">link</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Notice that the <code>crawl</code> goroutine takes link as an explicit parameter to avoid the problem of loop variable capture  in <a href="../ch5/#caveat-capturing-iteration-variables">Section 5.6.1</a>. Also notice that the initial send of the command-line arguments to the <code>worklist</code> must run in its own goroutine to avoid deadlock, a stuck situation in which both the main goroutine and a crawler goroutine attempt to send to each other while neither is receiving. An alternative solution would be to use a buffered channel.</p>
<p>The crawler is now highly concurrent and prints a storm of URLs, but it has two problems.  The first problem manifests itself as error messages in the log after a few seconds of operation:</p>
<div class="codehilite"><pre>$ go build gopl.io/ch8/crawl1
$ ./crawl1 http://gopl.io/
http://gopl.io/
https://golang.org/help/
https://golang.org/doc/
https://golang.org/blog/
...
2015/07/15 18:22:12 Get ...: dial tcp: lookup blog.golang.org: no such host
2015/07/15 18:22:12 Get ...: dial tcp 23.21.222.120:443: socket:
too many open files
...
</pre></div>


<p>The program created so many network connections at once that it exceeded the per-process limit on the number of open files, causing operations such as DNS lookups and calls to <code>net.Dial</code> to start failing.</p>
<p>The program is too parallel. Unbounded parallelism is rarely a good idea since there is always a limiting factor in the system, such as:</p>
<ul>
<li>The number of CPU cores for compute-bound workloads</li>
<li>The number of spindles and heads for local disk I/O operations</li>
<li>The bandwidth of the network for streaming downloads or the serving capacity of a web service.</li>
</ul>
<p>The solution is to limit the number of parallel uses of the resource to match the level of parallelism that is available. A simple way to do that in our example is to ensure that no more than <em>n</em> calls to <code>links.Extract</code> are active at once, where <em>n</em> is comfortably less than the file descriptor limit.</p>
<p>We can limit parallelism using a buffered channel of capacity <em>n</em> to model a concurrency primitive called a <em>counting semaphore</em>. Conceptually, each of the <em>n</em> vacant slots in the channel buffer represents a token entitling the holder to proceed. Sending a value into the channel acquires a token, and receiving a value from the channel releases a token, creating a new vacant slot. This ensures that at most <em>n</em> sends can occur without an intervening receive.Since the channel element type is not important, we'll use <code>struct{}</code>, which has size zero.</p>
<p>In the following rewritten <code>crawl</code> function, the call to <code>links.Extract</code> is bracketed by operations to acquire and release a token, thus ensuring that at most 20 calls to it are active at one time. It's good practice to keep the semaphore operations as close as possible to the I/O operation they regulate.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/crawl2/findlinks.go">gopl.io/ch8/crawl2/findlinks.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// tokens is a counting semaphore used to</span>
<span class="c1">// enforce a limit of 20 concurrent requests.</span>
<span class="kd">var</span> <span class="nx">tokens</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">20</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="nx">tokens</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span> <span class="c1">// acquire a token</span>
    <span class="nx">list</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">Extract</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="o">&lt;-</span><span class="nx">tokens</span> <span class="c1">// release the token</span>

    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">list</span>
<span class="p">}</span>
</pre></div>


<p>The second problem is that the program never terminates, even when it has discovered all the links reachable from the initial URLs. For the program to terminate, we need to break out of the main loop when the <code>worklist</code> is empty and no crawl goroutines are active.</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">worklist</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">n</span> <span class="kt">int</span> <span class="c1">// number of pending sends to worklist</span>

    <span class="c1">// Start with the command-line arguments.</span>
    <span class="nx">n</span><span class="o">++</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">}()</span>

    <span class="c1">// Crawl the web concurrently.</span>
    <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span><span class="o">--</span> <span class="p">{</span>
        <span class="nx">list</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">worklist</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">list</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">{</span>
                <span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="nx">n</span><span class="o">++</span>
                <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">link</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span>
                <span class="p">}(</span><span class="nx">link</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>In this version, the counter <code>n</code> keeps track of the number of sends to the <code>worklist</code> that are yet to occur. Each time we know that an item needs to be sent to the worklist, we increment <code>n</code>, once before we send the initial command-line arguments, and again each time we start a crawler goroutine. The main loop terminates when <code>n</code> falls to zero, since there is no more work to be done.</p>
<p>This concurrent crawler now runs about 20 times faster than the breadth-first crawler from <a href="../ch5/#anonymous-functions">Section 5.6</a>  and terminates correctly if it should complete its task.</p>
<p>The program below shows an alternative solution to the problem of excessive concurrency. It uses the original <code>crawl</code> function that has no counting semaphore, but calls it from one of 20 long-lived crawler goroutines, thus ensuring that at most 20 HTTP requests are active concurrently.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/crawl3/findlinks.go">gopl.io/ch8/crawl3/findlinks.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">worklist</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>  <span class="c1">// lists of URLs, may have duplicates</span>
    <span class="nx">unseenLinks</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="c1">// de-duplicated URLs</span>

    <span class="c1">// Add command-line arguments to worklist.</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">}()</span>

    <span class="c1">// Create 20 crawler goroutines to fetch each unseen link.</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">for</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">unseenLinks</span> <span class="p">{</span>
                <span class="nx">foundLinks</span> <span class="o">:=</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span>
                <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">foundLinks</span> <span class="p">}()</span>
            <span class="p">}</span>
        <span class="p">}()</span>
    <span class="p">}</span>

    <span class="c1">// The main goroutine de-duplicates worklist items</span>
    <span class="c1">// and sends the unseen ones to the crawlers.</span>
    <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">list</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">worklist</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">list</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">{</span>
                <span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="nx">unseenLinks</span> <span class="o">&lt;-</span> <span class="nx">link</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>In the above program:</p>
<ul>
<li>The crawler goroutines are all fed by the same channel, <code>unseenLinks</code>.</li>
<li>The main goroutine is responsible for de-duplicating items it receives from the worklist, and then sending each unseen one over the <code>unseenLinks</code> channel to a crawler goroutine.</li>
<li>
<p>The <code>seen</code> map is <em>confined</em> within the main goroutine; that is, it can be accessed only by that goroutine. Like other forms of information hiding, confinement helps us reason about the correctness of a program. For example:</p>
<ul>
<li>Local variables cannot be mentioned by name from outside the function in which they are declared.</li>
<li>Variables that do not escape (<a href="../ch2/#lifetime-of-variables">Section 2.3.4</a>) from a function cannot be accessed from outside that function.</li>
<li>Encapsulated fields of an object cannot be accessed except by the methods of that object.</li>
</ul>
<p>In all cases, information hiding helps to limit unintended interactions between parts of the program.</p>
</li>
<li>
<p>Links found by <code>crawl</code> are sent to the worklist from a dedicated goroutine to avoid deadlock.</p>
</li>
<li>To save space, this example does not address the problem of termination.</li>
</ul>
<h3 id="multiplexing-with-select">Multiplexing with <code>select</code></h3>
<p>The program below does the countdown for a rocket launch. The <a href="https://golang.org/pkg/time/#Tick"><code>time.Tick</code></a> function returns a channel on which it sends events periodically, acting like a <a href="https://en.wikipedia.org/wiki/Metronome">metronome</a>. The value of each event is a timestamp, but it is rarely as interesting as the fact of its delivery.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/countdown1/countdown.go">gopl.io/ch8/countdown1/countdown.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Commencing countdown.&quot;</span><span class="p">)</span>
    <span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Tick</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">countdown</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">countdown</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">countdown</span><span class="o">--</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">countdown</span><span class="p">)</span>
        <span class="o">&lt;-</span><span class="nx">tick</span>
    <span class="p">}</span>
    <span class="nx">launch</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>The following code adds the ability to abort the launch sequence by pressing the return key during the countdown. First, it starts a goroutine that tries to read a single byte from the standard input and, if it succeeds, sends a value on a channel called <code>abort</code>.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/countdown2/countdown.go">gopl.io/ch8/countdown2/countdown.go</a></small></p>
<div class="codehilite"><pre><span class="nx">abort</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">// read a single byte</span>
    <span class="nx">abort</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
<span class="p">}()</span>
</pre></div>


<p>Now each iteration of the countdown loop needs to wait for an event to arrive on one of the two channels:</p>
<ul>
<li>The ticker channel if everything is fine ("nominal" in NASA jargon)</li>
<li>An abort event if there was an "anomaly"</li>
</ul>
<p>We can't just receive from each channel because whichever operation we try first will block until completion. We need to multiplex these operations with a <em>select statement</em>.</p>
<p>The general form of a select statement is shown above.</p>
<div class="codehilite"><pre><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ch1</span><span class="p">:</span>
    <span class="c1">// ...</span>
<span class="k">case</span> <span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch2</span><span class="p">:</span>
    <span class="c1">// ...use x...</span>
<span class="k">case</span> <span class="nx">ch3</span> <span class="o">&lt;-</span> <span class="nx">y</span><span class="p">:</span>
    <span class="c1">// ...</span>
<span class="k">default</span><span class="p">:</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>


<p>Like a switch statement, it has a number of cases and an optional default. Each case specifies a <em>communication</em> (a send or receive operation on some channel) and an associated block of statements.</p>
<ul>
<li>In the first case, a receive expression appears on its own.</li>
<li>In the second case, a receive expression appears within a short variable declaration. This enables you to refer to the received value.</li>
</ul>
<p>A <code>select</code> waits until a communication for some case is ready to proceed. It then performs that communication and executes the case's associated statements; the other communications do not happen. A <code>select</code> with no cases, <code>select{}</code>, waits forever.</p>
<p>Let's return to our rocket launch program. The <code>time.After</code> function immediately returns a channel, and starts a new goroutine that sends a single value on that channel after the specified time. The select statement below waits until the first of two events arrives, either an abort event or the event indicating that 10 seconds have elapsed. If 10 seconds go by with no abort, the launch proceeds.</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...create abort channel...</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Commencing countdown.  Press return to abort.&quot;</span><span class="p">)</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nx">After</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">):</span>
        <span class="c1">// Do nothing.</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">abort</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Launch aborted!&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">launch</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>The example below is more subtle. The channel <code>ch</code>, whose buffer size is 1, is alternately empty then full, so only one of the cases can proceed, either the send when <code>i</code> is even, or the receive when <code>i</code> is odd. It always prints <code>0 2 4 6 8</code>.</p>
<div class="codehilite"><pre><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// &quot;0&quot; &quot;2&quot; &quot;4&quot; &quot;6&quot; &quot;8&quot;</span>
    <span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span><span class="p">:</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>If multiple cases are ready, <code>select</code> picks one at random, which ensures that every channel has an equal chance of being selected. Increasing the buffer size of the previous example makes its output nondeterministic, because when the buffer is neither full nor empty, the select statement figuratively tosses a coin.</p>
<p>The following launch program prints the countdown. The select statement below causes each iteration of the loop to wait up to 1 second for an abort, but no longer.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/countdown3/countdown.go">gopl.io/ch8/countdown3/countdown.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...create abort channel...</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Commencing countdown.  Press return to abort.&quot;</span><span class="p">)</span>
    <span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Tick</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">countdown</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">countdown</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">countdown</span><span class="o">--</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">countdown</span><span class="p">)</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tick</span><span class="p">:</span>
            <span class="c1">// Do nothing.</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">abort</span><span class="p">:</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Launch aborted!&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">launch</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>The <code>time.Tick</code> function behaves as if it creates a goroutine that calls <code>time.Sleep</code> in a loop, sending an event each time it wakes up. When the countdown function above returns, it stops receiving events from tick, but the ticker goroutine is still there, trying in vain to send on a channel from which no goroutine is receiving, which is a <strong>goroutine leak</strong> (<a href="#buffered-channels">Section 8.4.4</a>).</p>
<p>The <code>Tick</code> function is convenient, but it's appropriate only when the ticks will be needed throughout the lifetime of the application. Otherwise, we should use this pattern:</p>
<div class="codehilite"><pre><span class="nx">ticker</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">NewTicker</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="o">&lt;-</span><span class="nx">ticker</span><span class="p">.</span><span class="nx">C</span> <span class="c1">// receive from the ticker&#39;s channel</span>
<span class="nx">ticker</span><span class="p">.</span><span class="nx">Stop</span><span class="p">()</span> <span class="c1">// cause the ticker&#39;s goroutine to terminate</span>
</pre></div>


<p>Sometimes we want to try to send or receive on a channel but avoid blocking if the channel is not ready, which a non-blocking communication. A select statement can do that. A select may have a default, which specifies what to do when none of the other communications can proceed immediately.</p>
<p>The select statement below receives a value from the <code>abort</code> channel if there is one to receive; otherwise it does nothing. This is a <em>non-blocking</em> receive operation; doing it repeatedly is called <a href="https://en.wikipedia.org/wiki/Polling_(computer_science)">polling</a> a channel.</p>
<div class="codehilite"><pre><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">abort</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Launch aborted!\n&quot;</span><span class="p">)</span>
    <span class="k">return</span>
<span class="k">default</span><span class="p">:</span>
    <span class="c1">// do nothing</span>
<span class="p">}</span>
</pre></div>


<p>The zero value for a channel is <code>nil</code>, and nil channels are sometimes useful. Because send and receive operations on a nil channel block forever, a case in a select statement whose channel is nil is never selected. This enables us to use nil to enable or disable cases that correspond to features like:</p>
<ul>
<li>Handling timeouts or cancellation</li>
<li>Responding to other input events</li>
<li>Emitting output</li>
</ul>
<p>The next section gives us an example.</p>
<h3 id="example-concurrent-directory-traversal">Example: Concurrent Directory Traversal</h3>
<p>This section builds a program that reports the disk usage of one or more directories specified on the command line, like the Unix <a href="https://en.wikipedia.org/wiki/Du_(Unix)"><code>du</code></a> command. Most of its work is done by the <code>walkDir</code> function below, which enumerates the entries of the directory <code>dir</code> using the <code>dirents</code> helper function.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/du1/main.go">gopl.io/ch8/du1/main.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// walkDir recursively walks the file tree rooted at dir</span>
<span class="c1">// and sends the size of each found file on fileSizes.</span>
<span class="kd">func</span> <span class="nx">walkDir</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fileSizes</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">entry</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">IsDir</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">subdir</span> <span class="o">:=</span> <span class="nx">filepath</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">dir</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Name</span><span class="p">())</span>
            <span class="nx">walkDir</span><span class="p">(</span><span class="nx">subdir</span><span class="p">,</span> <span class="nx">fileSizes</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">fileSizes</span> <span class="o">&lt;-</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Size</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// dirents returns the entries of directory dir.</span>
<span class="kd">func</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span> <span class="p">{</span>
    <span class="nx">entries</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadDir</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;du1: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">entries</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>The <a href="https://golang.org/pkg/io/ioutil/#ReadDir"><code>ioutil.ReadDir</code></a> function returns a slice of <a href="https://golang.org/pkg/os/#FileInfo"><code>os.FileInfo</code></a>, which is the same information that a call to <a href="https://golang.org/pkg/os/#Stat"><code>os.Stat</code></a> returns for a single file.</li>
<li>For each subdirectory, <code>walkDir</code> recursively calls itself, and for each file, <code>walkDir</code> sends a message (the size of the file in bytes) on the <code>fileSizes</code> channel.</li>
</ul>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>