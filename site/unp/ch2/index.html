<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/unp/ch2/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 2. The Transport Layer: TCP, UDP, and SCTP - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../..">Home</a>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UTLK <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../utlk/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../utlk/ch2/">Chapter 2. Memory Addressing</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li class="active">
                            <a href="./">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                    
                        <li >
                            <a href="../ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                    
                        <li >
                            <a href="../ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">ICND <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../icnd1/part1/">ICND1 Part I: Networking Fundamentals</a>
                        </li>
                    
                        <li >
                            <a href="../../icnd2/part1/">ICND2 Part I: LAN Switching</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Others <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../htae/">HTAE</a>
                        </li>
                    
                        <li >
                            <a href="../../golang/">Go</a>
                        </li>
                    
                        <li >
                            <a href="../../bash/">Bash</a>
                        </li>
                    
                        <li >
                            <a href="../../c/">C</a>
                        </li>
                    
                        <li >
                            <a href="../../iptables/">iptables</a>
                        </li>
                    
                        <li >
                            <a href="../../nginx/">Nginx</a>
                        </li>
                    
                        <li >
                            <a href="../../vim/">Vim</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="https://github.com/shichao-an/notes">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-2-the-transport-layer-tcp-udp-and-sctp">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a></li>
        
    
        <li class="main "><a href="#introduction">Introduction</a></li>
        
    
        <li class="main "><a href="#the-big-picture">The Big Picture</a></li>
        
    
        <li class="main "><a href="#user-datagram-protocol-udp">User Datagram Protocol (UDP)</a></li>
        
    
        <li class="main "><a href="#transmission-control-protocol-tcp">Transmission Control Protocol (TCP)</a></li>
        
    
        <li class="main "><a href="#stream-control-transmission-protocol-sctp">Stream Control Transmission Protocol (SCTP)</a></li>
        
    
        <li class="main "><a href="#tcp-connection-establishment-and-termination">TCP Connection Establishment and Termination</a></li>
        
            <li><a href="#three-way-handshake">Three-Way Handshake</a></li>
        
            <li><a href="#tcp-options">TCP Options</a></li>
        
            <li><a href="#tcp-connection-termination">TCP Connection Termination</a></li>
        
            <li><a href="#tcp-state-transition-diagram">TCP State Transition Diagram</a></li>
        
            <li><a href="#watching-the-packets">Watching the Packets</a></li>
        
    
        <li class="main "><a href="#time_wait-state">TIME_WAIT State</a></li>
        
    
        <li class="main "><a href="#port-numbers">Port Numbers</a></li>
        
            <li><a href="#socket-pair">Socket Pair</a></li>
        
    
        <li class="main "><a href="#tcp-port-numbers-and-concurrent-servers">TCP Port Numbers and Concurrent Servers</a></li>
        
    
        <li class="main "><a href="#buffer-sizes-and-limitations">Buffer Sizes and Limitations</a></li>
        
            <li><a href="#tcp-output">TCP Output</a></li>
        
            <li><a href="#udp-output">UDP Output</a></li>
        
    
        <li class="main "><a href="#standard-internet-services">Standard Internet Services</a></li>
        
    
        <li class="main "><a href="#protocol-usage-by-common-internet-applications">Protocol Usage by Common Internet Applications</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h3 id="chapter-2-the-transport-layer-tcp-udp-and-sctp"><strong>Chapter 2. The Transport Layer: TCP, UDP, and SCTP</strong></h3>
<h3 id="introduction">Introduction</h3>
<p>This chapter focuses on the transport layer: TCP, UDP, and Stream Control Transmission Protocol (SCTP). UDP is a simple, unreliable datagram protocol, while TCP is a sophisticated, reliable byte-stream protocol. SCTP is similar to TCP as a reliable transport protocol, but it also provides message boundaries, transport-level support for multihoming, and a way to minimize head-of-line blocking.</p>
<h3 id="the-big-picture">The Big Picture</h3>
<p>Overview of TCP/IP protocols:</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>IPv4</td>
<td>Internet Protocol version 4. IPv4 uses 32-bit addresses and provides packet delivery service for TCP, UDP, SCTP, ICMP, and IGMP.</td>
</tr>
<tr>
<td>IPv6</td>
<td>Internet Protocol version 6. IPv6 uses 128-bit addresses.</td>
</tr>
<tr>
<td>TCP</td>
<td>Transmission Control Protocol. TCP is a connection-oriented protocol that provides a reliable, full-duplex byte stream to its users</td>
</tr>
<tr>
<td>UDP</td>
<td>User Datagram Protocol. UDP is a connectionless protocol, and UDP sockets are an example of datagram sockets.</td>
</tr>
<tr>
<td>SCTP</td>
<td>Stream Control Transmission Protocol. SCTP is a connection-oriented protocol that provides a reliable full-duplex association</td>
</tr>
<tr>
<td>ICMP</td>
<td>Internet Control Message Protocol. ICMP handles error and control information between routers and hosts.</td>
</tr>
<tr>
<td>IGMP</td>
<td>Internet Group Management Protocol. IGMP is used with multicasting.</td>
</tr>
<tr>
<td>ARP</td>
<td>Address Resolution Protocol. ARP maps an IPv4 address into a hardware address (such as an Ethernet address). ARP is normally used on broadcast networks such as Ethernet, <a href="http://en.wikipedia.org/wiki/Token_ring">token ring</a>, and <a href="http://en.wikipedia.org/wiki/Fiber_Distributed_Data_Interface">FDDI</a>, and is not needed on point-to-point networks.</td>
</tr>
<tr>
<td>RARP</td>
<td>Reverse Address Resolution Protocol. RARP maps a hardware address into an IPv4 address. It is sometimes used when a diskless node is booting.</td>
</tr>
<tr>
<td>ICMPv6</td>
<td>Internet Control Message Protocol version 6. ICMPv6 combines the functionality of ICMPv4, IGMP, and ARP.</td>
</tr>
<tr>
<td>BPF</td>
<td><a href="http://en.wikipedia.org/wiki/PF_(firewall)">BSD packet filter</a>. This interface provides access to the datalink layer. It is normally found on Berkeley-derived kernels.</td>
</tr>
<tr>
<td>DLPI</td>
<td><a href="http://en.wikipedia.org/wiki/Data_Link_Provider_Interface">Datalink provider interface</a>.</td>
</tr>
</tbody>
</table>
<h3 id="user-datagram-protocol-udp">User Datagram Protocol (UDP)</h3>
<ul>
<li>Lack of reliability</li>
<li>Each UDP datagram has a length</li>
<li><strong>Connectionless</strong> service</li>
</ul>
<h3 id="transmission-control-protocol-tcp">Transmission Control Protocol (TCP)</h3>
<ul>
<li><strong>Connection</strong>: TCP provides connections between clients and servers. A TCP client establishes a connection with a server, exchanges data across the connection, and then terminates the connection.</li>
<li><strong>Reliability</strong>: TCP requires acknowledgment when sending data. If an acknowledgment is not received, TCP automatically retransmits the data and waits a longer amount of time.</li>
<li><strong>Round-trip time</strong> (RTT): TCP estimates RTT between a client and server dynamically so that it knows how long to wait for an acknowledgment.</li>
<li><strong>Sequencing</strong>: TCP associates a sequence number with every byte (<strong>segment</strong>, unit of data that TCP passes to IP.) it sends. TCP reorders out-of-order segments and discards duplicate segments.</li>
<li><strong>Flow control</strong></li>
<li><strong>Full-duplex</strong>: an application can send and receive data in both directions on a given connection at any time.</li>
</ul>
<h3 id="stream-control-transmission-protocol-sctp">Stream Control Transmission Protocol (SCTP)</h3>
<p>Like TCP, SCTP provides reliability, sequencing, flow control, and full-duplex data transfer.</p>
<p>Unlike TCP, SCTP provides:</p>
<ul>
<li><strong>Association</strong> instead of "connection": An association refers to a communication between two systems, which may involve more than two addresses due to multihoming.</li>
<li><strong>Message-oriented</strong>: provides sequenced delivery of individual records. Like UDP, the length of a record written by the sender is passed to the receiving application.</li>
<li><strong>Multihoming</strong>: allows a single SCTP endpoint to support multiple IP addresses. This feature can provide increased robustness against network failure.</li>
</ul>
<h3 id="tcp-connection-establishment-and-termination">TCP Connection Establishment and Termination</h3>
<h4 id="three-way-handshake">Three-Way Handshake</h4>
<p><a href="../figure_2.2.png" title="Figure 2.2. TCP three-way handshake."><img alt="Figure 2.2. TCP three-way handshake." src="../figure_2.2.png" /></a></p>
<ol>
<li>Server: <strong>passive open</strong>, by calling <code>socket</code>, <code>bind</code>, and <code>listen</code></li>
<li>Client: <strong>active open</strong>, by calling <code>connect</code>. The client TCP to send a "synchronize" (SYN) segment with no data but it contains client's initial sequence number for the data to be sent on the connection.</li>
<li>Server: acknowledges (ACK) client's SYN. The server sends its SYN and the ACK of the client's SYN in a single segment which also contains its own SYN containing the initial sequence number for the data to be sent on the connection.</li>
<li>Client: acknowledges the server's SYN.</li>
</ol>
<p>The client's initial sequence number as <em>J</em> and the server's initial sequence number as <em>K</em>. The acknowledgment number in an ACK is the next expected sequence number for the end sending the ACK. Since a SYN occupies one byte of the sequence number space, the acknowledgment number in the ACK of each SYN is the initial sequence number plus one.</p>
<h4 id="tcp-options">TCP Options</h4>
<ul>
<li>MSS option. The TCP sending the SYN announces its <strong>maximum segment size</strong> (the maximum amount of data that it is willing to accept in each TCP segment)on this connection.</li>
<li>Window scale option. [p38]</li>
<li>Timestamp option</li>
</ul>
<h4 id="tcp-connection-termination">TCP Connection Termination</h4>
<p><a href="../figure_2.3.png" title="Figure 2.3. Packets exchanged when a TCP connection is closed."><img alt="Figure 2.3. Packets exchanged when a TCP connection is closed." src="../figure_2.3.png" /></a></p>
<p>It takes four segments to terminate a connection:</p>
<ol>
<li>One end calls <code>close</code> first by sending a FIN segment to mean it is finished sending data. This is called <strong>active close</strong>.</li>
<li>The other end that receives the FIN performs the <strong>passive close</strong>. The received FIN is acknowledged by TCP (sending an ACK segment). The receipt of the FIN is also passed to the application as an end-of-file.</li>
<li>Sometime later, the application that received the end-of-file will close its socket. This causes its TCP to send a FIN.</li>
<li>The TCP on the system that receives this final FIN (the end that did the active close) acknowledges the FIN</li>
</ol>
<p>A FIN occupies one byte of sequence number space just like a SYN. Therefore, the ACK of each FIN is the sequence number of the FIN plus one.</p>
<h4 id="tcp-state-transition-diagram">TCP State Transition Diagram</h4>
<p><a href="../figure_2.4.png" title="Figure 2.4. TCP state transition diagram."><img alt="Figure 2.4. TCP state transition diagram." src="../figure_2.4_600.png" /></a></p>
<p>There are 11 different states defined for a connection and the rules of TCP dictate the transitions from one state to another, based on the current state and the segment received in that state.</p>
<h4 id="watching-the-packets">Watching the Packets</h4>
<p><a href="../figure_2.5.png" title="Figure 2.5. Packet exchange for TCP connection."><img alt="Figure 2.5. Packet exchange for TCP connection." src="../figure_2.5.png" /></a></p>
<p>The client in this example announces an MSS of 536 (<strong>minimum reassembly buffer size</strong>) and the server announces an MSS of 1,460 (typical for IPv4 on an Ethernet). It is okay for the MSS to be different in each direction. The acknowledgment of the client's request is sent with the server's reply. This is called <strong>piggybacking</strong> and will normally happen when the time it takes the server to process the request and generate the reply is less than around 200 ms. 
With TCP, there would be eight segments of overhead. If UDP was used, only two packets would be exchanged.</p>
<ul>
<li>UDP removes all the reliability that TCP provides to the application.</li>
<li>UDP avoids the overhead of TCP connection establishment and connection termination.</li>
</ul>
<h3 id="time_wait-state">TIME_WAIT State</h3>
<p>The end that performs the active close goes through the TIME_WAIT state. The duration that this endpoint remains in the TIME_WAIT state is twice the <strong>maximum segment lifetime</strong> (MSL), sometimes called 2MSL, which is between 1 and 4 minutes. The MSL is the maximum amount of time that any given IP datagram can live in a network. The IPv4 TTL field  IPv6 hop limit field have a maximum value 255. The assumption is made that a packet with the maximum hop limit of 255 cannot exist in a network for more than MSL seconds. [p43]</p>
<p>TCP must handle <strong>lost duplicates</strong> (or <strong>wandering duplicate</strong>).</p>
<p>There are two reasons for the TIME_WAIT state:</p>
<ul>
<li>To implement TCP's full-duplex connection termination reliably. If TCP is performing all the work necessary to terminate both directions of data flow cleanly for a connection (its full-duplex close), then it must correctly handle the loss of any of these four segments.</li>
<li>To allow old duplicate segments to expire in the network. When we successfully establish a TCP connection, all old duplicates from previous <strong>incarnations</strong> of the connection have expired in the network.</li>
</ul>
<h3 id="port-numbers">Port Numbers</h3>
<p>All three transport layers (UDP, SCTP and TCP) use 16-bit integer port numbers to differentiate between processes.</p>
<ul>
<li>The <strong>well-known ports</strong>: 0 through 1023.</li>
<li>The <strong>registered ports</strong>: 1024 through 49151</li>
<li>The <strong>dynamic ports</strong> or <strong>private ports</strong>, 49152 through 65535. Also called <strong>ephemeral ports</strong>.</li>
</ul>
<p><a href="../figure_2.10.png" title="Figure 2.10. Allocation of port numbers."><img alt="Figure 2.10. Allocation of port numbers." src="../figure_2.10.png" /></a></p>
<p>Some notes from the figure above:</p>
<ul>
<li>On Unix, <strong>reserved port</strong> is any port less than 1024. These ports can only be assigned to a socket by an appropriately privileged process. All the IANA well-known ports are reserved ports. The server allocating this port must have superuser privileges when it starts.</li>
<li>Historically, Berkeley-derived implementations (starting with 4.3BSD) have allocated <strong>ephemeral ports</strong> in the range 1024â€“5000. Many newer systems allocate ephemeral ports differently to provide more ephemeral ports, either using the IANA-defined ephemeral range or a larger range</li>
</ul>
<h4 id="socket-pair">Socket Pair</h4>
<ul>
<li><strong>Socket pair</strong>: the four-tuple that defines the two endpoints of a TCP connection: the local IP address, local port, foreign IP address, and foreign port. A socket pair uniquely identifies every TCP connection on a network.</li>
<li><strong>Socket</strong>: two values (an IP address and a port number) that identify each endpoint.</li>
</ul>
<h3 id="tcp-port-numbers-and-concurrent-servers">TCP Port Numbers and Concurrent Servers</h3>
<p>[p52-55]</p>
<h3 id="buffer-sizes-and-limitations">Buffer Sizes and Limitations</h3>
<p>Figures: <a href="../../tcpv1/ipv4_header.png">IPv4 Header</a>, <a href="../../tcpv1/ipv6_header.png">IPv6 Header</a></p>
<ul>
<li>Maximum size of an IPv4 datagram: 65,535 bytes (including the header), because of the 16-bit total length field.</li>
<li>Maximum size of an IPv6 datagram: 65,575 bytes (including the 40-byte IPv6 header), because of the 16-bit payload length field. IPv6 has a jumbo payload option, which extends the payload length field to 32 bits, but this option is supported only on datalinks with a <strong>maximum transmission unit</strong> (MTU) that exceeds 65,535.</li>
<li><strong>MTU</strong> (maximum transmission unit): dictated by the hardware. Ethernet MTU is 1,500 bytes; Point-to-point links have a configurable MTU.<ul>
<li>Minimum link MTU for IPv4: 68 bytes. This permits a maximum-sized IPv4 header (20 bytes of fixed header, 40 bytes of options)  and minimum-sized fragment (the fragment offset is in units of 8 bytes) <a href="http://www.unpbook.com/errata.html">[errata]</a></li>
<li>Minimum link MTU for IPv6: 1,280 bytes.</li>
</ul>
</li>
<li><strong>Path MTU</strong>: smallest MTU in the path between two hosts. Today, the Ethernet MTU of 1,500 bytes is often the path MTU. The path MTU need not be the same in both directions between any two hosts because routing in the Internet is often asymmetric.</li>
<li><strong>Fragmentation</strong> is performed by both IPv4 and IPv6 when the size of an IP datagram to be sent out an interface exceeds the link MTU. The fragments are not normally <strong>reassembled</strong> until they reach the final destination.<ul>
<li>IPv4: hosts perform fragmentation on datagrams that they generate and routers perform fragmentation on datagrams that they forward</li>
<li>IPv6: only hosts perform fragmentation on datagrams that they generate; routers do not fragment datagrams that they are forwarding</li>
<li>IPv4 header contains fields to handle fragmentation. IPv6 contains an option header with the fragmentation information.</li>
</ul>
</li>
<li>"Don't Fragment" (DF) bit in IPv4 header specifies that this datagram must not be fragmented, either by the sending host or by any router. A router that receives an IPv4 datagram with the DF bit set whose size exceeds the outgoing link's MTU generates an ICMPv4 "destination unreachable, fragmentation needed but DF bit set" error message.<ul>
<li>Since IPv6 routers do not perform fragmentation, there is an implied DF bit with every IPv6 datagram. When an IPv6 router receives a datagram whose size exceeds the outgoing link's MTU, it generates an ICMPv6 "packet too big" error message</li>
<li><strong>Path MTU discovery</strong> uses IPv4 DF bit and its implied IPv6 counterpart. Path MTU discovery is optional with IPv4, but IPv6 implementations all either support path MTU discovery or always send using the minimum MTU. [p55]</li>
</ul>
</li>
<li><strong>Minimum reassembly buffer size</strong>: the minimum datagram size that we are guaranteed any implementation must support.<ul>
<li>IPv4: 576 bytes. We have no idea whether a given destination can accept a 577-byte datagram or not. Therefore, many IPv4 applications that use UDP (e.g., DNS, RIP, TFTP, BOOTP, SNMP) prevent applications from generating IP datagrams that exceed this size.</li>
<li>IPv6: 1,500 bytes</li>
</ul>
</li>
<li>TCP has a <strong>maximum segment size</strong> (MSS) that announces to the peer TCP the maximum amount of TCP data that the peer can send per segment. We saw the MSS option on the SYN segments in <a href="../figure_2.5.png">Figure 2.5</a>. The goal of the MSS is to tell the peer the actual value of the reassembly buffer size and to try to avoid fragmentation. The MSS is often set to the interface MTU minus the fixed sizes of the IP and TCP headers. On an Ethernet using IPv4, this would be 1,460, and on an Ethernet using IPv6, this would be 1,440. (The TCP header is 20 bytes for both, but the IPv4 header is 20 bytes and the IPv6 header is 40 bytes.)<ul>
<li>IPv4: The MSS value in the TCP MSS option is a 16-bit field, limiting the value to 65,535. The maximum amount of TCP data in an IPv4 datagram is 65,495 (65,535 minus the 20-byte IPv4 header and minus the 20-byte TCP header).</li>
<li>IPv6: the maximum amount of TCP data in an IPv6 datagram without the jumbo payload option is 65,515 (65,535 minus the 20-byte TCP header). The MSS value of 65,535 is considered a special case that designates "infinity." This value is used only if the jumbo payload option is being used, which requires an MTU that exceeds 65,535.</li>
</ul>
</li>
</ul>
<h4 id="tcp-output">TCP Output</h4>
<p>Every TCP socket has a send buffer and we can change the size of this buffer with the <code>SO_SNDBUF</code> socket option. When an application calls <code>write</code>, the kernel copies all the data from the application buffer into the socket send buffer. If there is insufficient room in the socket buffer for all the application's data, the process is put to sleep. This assumes the normal default of a blocking socket. The kernel will not return from the write until the final byte in the application buffer has been copied into the socket send buffer. Therefore, <u>the successful return from a write to a TCP socket only tells us that we can reuse our application buffer. It does not tell us that either the peer TCP has received the data or that the peer application has received the data.</u></p>
<p><u>TCP takes the data in the socket send buffer and sends it to the peer TCP.</u> The peer TCP must acknowledge the data, and as the ACKs arrive from the peer, only then can our TCP discard the acknowledged data from the socket send buffer. TCP must keep a copy of our data until it is acknowledged by the peer.</p>
<p>TCP sends the data to IP in MSS-sized or smaller chunks, prepending its TCP header to each segment, where the MSS is the value announced by the peer, or 536 if the peer did not send an MSS option. IP prepends its header, searches the routing table for the destination IP address, and passes the datagram to the appropriate datalink. IP might perform fragmentation before passing the datagram to the datalink, but one goal of the MSS option is to try to avoid fragmentation and newer implementations also use path MTU discovery. Each datalink has an output queue, and if this queue is full, the packet is discarded and an error is returned up the protocol stack [p58]</p>
<h4 id="udp-output">UDP Output</h4>
<p>UDP socket doesn't have a socket send buffer, since it does not need to keep a copy of the application's data. It has a send buffer size (which we can change with the <code>SO_SNDBUF</code> socket option), but this is simply an upper limit on the maximum-sized UDP datagram that can be written to the socket. If an application writes a datagram larger than the socket send buffer size, <code>EMSGSIZE</code> is returned.</p>
<p>UDP simply prepends its 8-byte header and passes the datagram to IP. IP determines the outgoing interface by performing the routing function, and then either adds the datagram to the datalink output queue (if it fits within the MTU) or fragments the datagram and adds each fragment to the datalink output queue (see <a href="../../tcpv1/ch10/#ip-fragmentation">UDP and IP Fragmentation in TCPv1</a>). If a UDP application sends large datagrams, there is a much higher probability of (IP) fragmentation than with TCP.</p>
<h3 id="standard-internet-services">Standard Internet Services</h3>
<h3 id="protocol-usage-by-common-internet-applications">Protocol Usage by Common Internet Applications</h3></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>