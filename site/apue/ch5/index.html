<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/apue/ch5/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 5. Standard I/O Library - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../github.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../..">Home</a>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                    
                        <li >
                            <a href="../ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                    
                        <li >
                            <a href="../ch3/">Chapter 3. File I/O</a>
                        </li>
                    
                        <li >
                            <a href="../ch4/">Chapter 4. Files and Directories</a>
                        </li>
                    
                        <li class="active">
                            <a href="./">Chapter 5. Standard I/O Library</a>
                        </li>
                    
                        <li >
                            <a href="../ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                    
                        <li >
                            <a href="../ch7/">Chapter 7. Process Environment</a>
                        </li>
                    
                        <li >
                            <a href="../ch8/">Chapter 8. Process Control</a>
                        </li>
                    
                        <li >
                            <a href="../ch9/">Chapter 9. Process Relationships</a>
                        </li>
                    
                        <li >
                            <a href="../ch10/">Chapter 10. Signals</a>
                        </li>
                    
                        <li >
                            <a href="../ch11/">Chapter 11. Threads</a>
                        </li>
                    
                        <li >
                            <a href="../ch12/">Chapter 12. Thread Control</a>
                        </li>
                    
                        <li >
                            <a href="../ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                    
                        <li >
                            <a href="../ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                    
                        <li >
                            <a href="../ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch5/">Chapter 5. System Calls</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UTLK <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../utlk/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../utlk/ch2/">Chapter 2. Memory Addressing</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">ICND <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../icnd1/part1/">ICND1 Part I: Networking Fundamentals</a>
                        </li>
                    
                        <li >
                            <a href="../../icnd2/part1/">ICND2 Part I: LAN Switching</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Others <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../clrs/">CLRS</a>
                        </li>
                    
                        <li >
                            <a href="../../htae/">HTAE</a>
                        </li>
                    
                        <li >
                            <a href="../../golang/">Go</a>
                        </li>
                    
                        <li >
                            <a href="../../bash/">Bash</a>
                        </li>
                    
                        <li >
                            <a href="../../c/">C</a>
                        </li>
                    
                        <li >
                            <a href="../../asm/">x86 assembly</a>
                        </li>
                    
                        <li >
                            <a href="../../iptables/">iptables</a>
                        </li>
                    
                        <li >
                            <a href="../../nginx/">Nginx</a>
                        </li>
                    
                        <li >
                            <a href="../../vim/">Vim</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/apue/ch5.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-5-standard-io-library">Chapter 5. Standard I/O Library</a></li>
        
    
        <li class="main "><a href="#streams-and-file-objects">Streams and FILE Objects</a></li>
        
    
        <li class="main "><a href="#standard-input-standard-output-and-standard-error">Standard Input, Standard Output, and Standard Error</a></li>
        
    
        <li class="main "><a href="#buffering">Buffering</a></li>
        
    
        <li class="main "><a href="#opening-a-stream">Opening a Stream</a></li>
        
    
        <li class="main "><a href="#reading-and-writing-a-stream">Reading and Writing a Stream</a></li>
        
            <li><a href="#input-functions">Input Functions</a></li>
        
            <li><a href="#output-functions">Output Functions</a></li>
        
    
        <li class="main "><a href="#line-at-a-time-io">Line-at-a-Time I/O</a></li>
        
    
        <li class="main "><a href="#standard-io-efficiency">Standard I/O Efficiency</a></li>
        
    
        <li class="main "><a href="#binary-io">Binary I/O</a></li>
        
    
        <li class="main "><a href="#positioning-a-stream">Positioning a Stream</a></li>
        
    
        <li class="main "><a href="#formatted-io">Formatted I/O</a></li>
        
            <li><a href="#formatted-output">Formatted Output</a></li>
        
            <li><a href="#formatted-output_1">Formatted Output</a></li>
        
    
        <li class="main "><a href="#implementation-details">Implementation Details</a></li>
        
    
        <li class="main "><a href="#temporary-files">Temporary Files</a></li>
        
    
        <li class="main "><a href="#memory-streams">Memory Streams</a></li>
        
    
        <li class="main "><a href="#alternatives-to-standard-io">Alternatives to Standard I/O</a></li>
        
    
        <li class="main "><a href="#doubts-and-solutions">Doubts and Solutions</a></li>
        
            <li><a href="#verbatim">Verbatim</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-5-standard-io-library"><strong>Chapter 5. Standard I/O Library</strong></h3>
<p>The standard I/O library handles such details as buffer allocation and performing I/O in optimal-sized chunks.</p>
<h3 id="streams-and-file-objects">Streams and <code>FILE</code> Objects</h3>
<p>Standard I/O file streams can be used with both <strong>single-byte</strong> and <strong>multibyte</strong> ("wide") character sets. A stream’s orientation determines whether the characters that are read and written are single byte or multibyte.</p>
<ul>
<li>This book deals only with <strong>byte-oriented</strong> (single byte) streams.</li>
<li>This book refers to a pointer to a <code>FILE</code> object, the type <code>FILE *</code>, as a <em>file pointer</em>.</li>
</ul>
<h3 id="standard-input-standard-output-and-standard-error">Standard Input, Standard Output, and Standard Error</h3>
<p>Three streams are predefined and automatically available to a process. They refer to file descriptors <code>STDIN_FILENO</code>, <code>STDOUT_FILENO</code>, and <code>STDERR_FILENO</code> (defined in <code>&lt;unistd.h&gt;</code>) [p9]. These three standard I/O streams are referenced through the predefined file pointers <code>stdin</code>, <code>stdout</code>,and <code>stderr</code>(defined in <code>&lt;stdio.h&gt;</code>).</p>
<h3 id="buffering">Buffering</h3>
<ol>
<li><strong>Fully buffered</strong></li>
<li><strong>Line buffered</strong></li>
<li><strong>Unbuffered</strong></li>
</ol>
<p>Most implementations default to the following types of buffering:</p>
<ul>
<li>Standard error is always unbuffered.</li>
<li>All other streams are line buffered if they refer to a terminal device; otherwise, they are fully buffered.</li>
</ul>
<p><small><a href="https://gist.github.com/shichao-an/70e28ba25f1b7276e834">apue_setbuf.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">setbuf</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span> <span class="p">);</span>
<span class="kt">int</span> <span class="nf">setvbuf</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, nonzero on error */</span>
</pre></div>


<ul>
<li><code>setbuf</code>: <em>buf</em> must point to a buffer of length <code>BUFSIZ</code>, a constant defined in <code>&lt;stdio.h&gt;</code></li>
<li><code>setvbuf</code>: type of buffering is specified with <code>_IOFBF</code>, <code>_IOLBF</code>, <code>_IONBF</code>.</li>
</ul>
<p>The GNU C librarys use the value from the <code>st_blksize</code> member of the <code>stat</code> structure to determine the optimal standard I/O buffer size.</p>
<p>The <code>fflush</code> function causes any unwritten data for the stream to be passed to the kernel. If <em>fp</em> is <code>NULL</code>, <code>fflush</code> causes all output streams to be flushed.</p>
<h3 id="opening-a-stream">Opening a Stream</h3>
<p><small><a href="https://gist.github.com/shichao-an/3fea32272cd9e1b574c6">apue_fopen.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">FILE</span> <span class="o">*</span><span class="nf">fopen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">pathname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">type</span><span class="p">);</span>
<span class="kt">FILE</span> <span class="o">*</span><span class="nf">freopen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">pathname</span><span class="p">,</span>
              <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">type</span><span class="p">,</span>
              <span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">);</span>
<span class="kt">FILE</span> <span class="o">*</span><span class="nf">fdopen</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cm">/* All three return: file pointer if OK, NULL on error */</span>
</pre></div>


<ul>
<li><code>fdopen</code> function is often used with descriptors returned by the functions that create pipes and network communication channels, because these special types of files cannot be opened with the <code>fopen</code> function.</li>
</ul>
<p><strong>type</strong> argument has 15 values as specifed by ISO C:</p>
<table>
<thead>
<tr>
<th><strong>type</strong></th>
<th>Description</th>
<th><code>open</code>(2) Flags</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>r</code>, <code>rb</code></td>
<td>open for reading</td>
<td><code>O_RDONLY</code></td>
</tr>
<tr>
<td><code>w</code>, <code>wb</code></td>
<td>truncate to 0 length or create for writing</td>
<td><code>O_WRONLY&#124;O_CREAT&#124;O_TRUNC</code></td>
</tr>
<tr>
<td><code>a</code>, <code>ab</code></td>
<td>append; open for writing at end of file, or create for writing</td>
<td><code>O_WRONLY&#124;O_CREAT&#124;O_APPEND</code></td>
</tr>
<tr>
<td><code>r+</code>, <code>r+b</code>, <code>rb+</code></td>
<td>open for reading and writing</td>
<td><code>O_RDWR</code></td>
</tr>
<tr>
<td><code>w+</code>, <code>w+b</code>, <code>wb+</code></td>
<td>truncate to 0 length or create for reading and writing</td>
<td><code>O_RDWR&#124;O_CREAT&#124;O_TRUNC</code></td>
</tr>
<tr>
<td><code>a+</code>, <code>a+b</code>, <code>ab+</code></td>
<td>open or create for reading and writing at end of file</td>
<td><code>O_RDWR&#124;O_CREAT&#124;O_APPEND</code></td>
</tr>
</tbody>
</table>
<p>Character <code>b</code> allows the standard I/O system to differentiate between a text file and a binary file. The UNIX kernel doesn’t differentiate between these types of files, thus character <code>b</code> has no effect.</p>
<ul>
<li><strong>Write</strong>: The <code>fdopen</code> function cannot truncate any file it opens for writing</li>
<li><strong>Append</strong>: each write will take place at the then current end of file. If multiple processes open the same file with the standard I/O append mode, the data from each process will be correctly written to the file</li>
<li><strong>Read and write</strong> (<code>+</code> sign in type): Output cannot be directly followed by input without an intervening <code>fflush</code>, <code>fseek</code>, <code>fsetpos</code>, or <code>rewind</code>. Input cannot be directly followed by output without an intervening <code>fseek</code>, <code>fsetpos</code>, or <code>rewind</code>, or an input operation that encounters an end of file.</li>
</ul>
<p><small><a href="https://gist.github.com/shichao-an/3c8458270dc1f08325f4">apue_fclose.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">fclose</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, EOF on error */</span>
</pre></div>


<p>An open stream is closed by calling <code>fclose</code>:</p>
<ul>
<li>Any buffered output data is flushed before the file is closed</li>
<li>Any input data that may be buffered is discarded</li>
</ul>
<p>When a process terminates normally, either by calling the exit function directly or by returning from the main function, all standard I/O streams with unwritten buffered data are flushed and all open standard I/O streams are closed.</p>
<h3 id="reading-and-writing-a-stream">Reading and Writing a Stream</h3>
<p>Unformatted I/O:</p>
<ul>
<li>Character-at-a-time I/O</li>
<li>Line-at-a-time I/O: <code>fgets</code> and <code>fputs</code>. Each line is terminated with a newline character.</li>
<li>Direct I/O (binary I/O, object-at-a-time I/O, record-oriented I/O, or structure-oriented I/O): <code>fread</code> and <code>fwrite</code>. For each I/O operation, we read or write some number of objects, where each object is of a specified size</li>
</ul>
<h4 id="input-functions">Input Functions</h4>
<p><small><a href="https://gist.github.com/shichao-an/afcad88f5484e55327c4">apue_getc.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">getc</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">fgetc</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">getchar</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* All three return: next character if OK, EOF on end of file or error */</span>
</pre></div>


<ul>
<li>The function <code>getchar</code> is defined to be equivalent to <code>getc(stdin)</code>.</li>
<li><code>getc</code> can be implemented as a macro, whereas <code>fgetc</code> cannot be implemented as a macro.</li>
<li>These three functions return the next character as an <code>unsigned char</code> converted to an <code>int</code>. Thus, all possible character values can be returned, along with an indication that either an error occurred or the end of file has been encountered. The constant EOF in <code>&lt;stdio.h&gt;</code> is required to be a negative value. Its value is often −1.</li>
</ul>
<p>These functions return the same value whether an error occurs or the end of file is reached. To distinguish between the two, we must call either <code>ferror</code> or <code>feof</code>:</p>
<p><small><a href="https://gist.github.com/shichao-an/fe81c6d98b62e487aaf3">apue_ferror.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">ferror</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">feof</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>

<span class="cm">/* Both return: nonzero (true) if condition is true, 0 (false) otherwise */</span>

<span class="kt">void</span> <span class="nf">clearerr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</pre></div>


<p>In most implementations, two flags are maintained for each stream in the <code>FILE</code> object:</p>
<ul>
<li>An error flag</li>
<li>An end-of-file flag</li>
</ul>
<p>Both flags are cleared by calling <code>clearerr</code>.</p>
<h5 id="pushback"><strong>Pushback</strong></h5>
<p>After reading from a stream, we can push back characters by calling <code>ungetc</code>.</p>
<p><small><a href="https://gist.github.com/shichao-an/1de26637c53e6de17b25">apue_ungetc.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">ungetc</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>

<span class="cm">/* Returns: c if OK, EOF on error */</span>
</pre></div>


<ul>
<li>The characters that are pushed back are returned by subsequent reads on the stream in reverse order of their pushing.</li>
<li>The character that is pushed back does not have to be the same character that was read.</li>
<li>When characters are pushed back with <code>ungetc</code>, they are not written back to the underlying file or device. Instead, they are kept incore in the standard I/O library’s buffer for the stream. EOF cannot be pushed back.</li>
<li>Used for peeking characters.</li>
</ul>
<h4 id="output-functions">Output Functions</h4>
<p><small><a href="https://gist.github.com/shichao-an/3aaa0731d3fbbe68da0c">apue_putc.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">putc</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">fputc</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">putchar</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">);</span>

<span class="cm">/* All three return: c if OK, EOF on error */</span>
</pre></div>


<ul>
<li><code>putchar(c)</code> is equivalent to <code>putc(c, stdout)</code></li>
<li><code>putc</code> can be implemented as a macro, whereas <code>fputc</code> cannot be implemented as a macro.</li>
</ul>
<h3 id="line-at-a-time-io">Line-at-a-Time I/O</h3>
<p><small><a href="https://gist.github.com/shichao-an/2c9049288e8634b92734">apue_fgets.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">fgets</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">gets</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="cm">/* Both return: buf if OK, NULL on end of file or error */</span>
</pre></div>


<ul>
<li><code>gets</code> function reads from standard input, whereas <code>fgets</code> reads from the specified stream.</li>
<li><code>fgets</code>: reads <em>n - 1</em> characters (including the newline) or partial line if longer than <em>n - 1</em> into the buffer, then the buffer is (always) null terminated.</li>
<li><code>gets</code>: should never be used. Without specifying buffer size, this may cause buffer to overflow if the line is longer than the buffer, writing over whatever happens to follow the buffer in memory. <code>gets</code> is marked as an obsolescent interface in SUSv4 and has been omitted from the latest version of the ISO C standard</li>
</ul>
<p><small><a href="https://gist.github.com/shichao-an/5a2fdd9294a2e4c37aad">apue_fputs.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">fputs</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">str</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">puts</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>

<span class="cm">/* Both return: non-negative value if OK, EOF on error */</span>
</pre></div>


<ul>
<li><code>fputs</code>: writes the null-terminated string to the specified stream without writing the null byte</li>
<li><code>puts</code>: writes the null-terminated string to the standard output without writing the null byte, and then writes a newline character to the standard output. <code>puts</code> should be avoided being used to prevent having to remember whether it appends a newline.</li>
</ul>
<h3 id="standard-io-efficiency">Standard I/O Efficiency</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>User CPU (seconds)</th>
<th>System CPU (seconds)</th>
<th>Clock time (seconds)</th>
<th>Bytes of program text</th>
</tr>
</thead>
<tbody>
<tr>
<td>best time from Figure 3.6</td>
<td>0.05</td>
<td>0.29</td>
<td>3.18</td>
<td></td>
</tr>
<tr>
<td><code>fgets</code>, <code>fputs</code></td>
<td>2.27</td>
<td>0.30</td>
<td>3.49</td>
<td>143</td>
</tr>
<tr>
<td><code>getc</code>, <code>putc</code></td>
<td>8.45</td>
<td>0.29</td>
<td>10.33</td>
<td>114</td>
</tr>
<tr>
<td><code>fgetc</code>, <code>fputc</code></td>
<td>8.16</td>
<td>0.40</td>
<td>10.18</td>
<td>114</td>
</tr>
<tr>
<td>single byte time from Figure 3.6</td>
<td>134.61</td>
<td>249.94</td>
<td>394.95</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>One advantage of using the standard I/O routines is that we don’t have to worry about buffering or choosing the optimal I/O size.</li>
<li>Usually, <code>getc</code> and <code>putc</code> are implemented as macros, but in the GNU C library implementation the macro simply expands to a function call.</li>
<li>The line-at-a-time functions are implemented using <code>memccpy(3)</code>. Often, the memccpy function is implemented in assembly language instead of C, for efficiency.</li>
</ul>
<h3 id="binary-io">Binary I/O</h3>
<p>If doing binary I/O, we often want to read or write an entire structure at a time. There are problems with the previous functions:</p>
<ul>
<li><code>getc</code>, <code>putc</code>: we have to loop through the entire structure one byte a time</li>
<li><code>fputs</code>: stops writing when it hits a null byte</li>
<li><code>fgets</code>: won't work correctly on input if any data bytes are null or newlines</li>
</ul>
<p><small><a href="https://gist.github.com/shichao-an/a90609694cb97c765ca2">apue_fread.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">size_t</span> <span class="nf">fread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nobj</span><span class="p">,</span>
             <span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="nf">fwrite</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nobj</span><span class="p">,</span>
              <span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">);</span>

<span class="cm">/* Both return: number of objects read or written */</span>
</pre></div>


<p>These functions have two common uses:</p>
<p>Read or write a binary array (e.g write elements 2 through 5 of a floating-point array):</p>
<div class="codehilite"><pre><span class="kt">float</span>   <span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

<span class="k">if</span> <span class="p">(</span><span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="mi">4</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;fwrite error&quot;</span><span class="p">);</span>
</pre></div>


<p>Read or write a structure:</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="p">{</span>
    <span class="kt">short</span>  <span class="n">count</span><span class="p">;</span>
    <span class="kt">long</span>   <span class="n">total</span><span class="p">;</span>
    <span class="kt">char</span>   <span class="n">name</span><span class="p">[</span><span class="n">NAMESIZE</span><span class="p">];</span>
<span class="p">}</span> <span class="n">item</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">item</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;fwrite error&quot;</span><span class="p">);</span>
</pre></div>


<ul>
<li><code>fread</code>: return value can be less than <em>nobj</em> if an error occurs or if the end of file is encountered</li>
<li><code>fwrite</code>: if the return value is less than the requested <code>nobj</code>, an error has occurred</li>
</ul>
<p>These two functions won't work on different systems (sometimes even on the same system):</p>
<ol>
<li>The offset of a member within a structure can differ between compilers and systems because of different <a href="http://en.wikipedia.org/wiki/Data_structure_alignment#Typical_alignment_of_C_structs_on_x86">alignment requirements</a>. Even on a single system, the binary layout of a structure can differ, depending on compiler options. [p157]</li>
<li>The binary formats used to store multibyte integers and floating-point values differ among machine architectures</li>
</ol>
<h3 id="positioning-a-stream">Positioning a Stream</h3>
<p><small><a href="https://gist.github.com/shichao-an/18d258b1815658a84cf7">apue_ftell.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">long</span> <span class="nf">ftell</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>

<span class="cm">/* Returns: current file position indicator if OK, −1L on error */</span>

<span class="kt">int</span> <span class="nf">fseek</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whence</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, −1 on error */</span>

<span class="kt">void</span> <span class="nf">rewind</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</pre></div>


<ul>
<li><code>ftell</code>: return file's position indicator (bytes from the beginning of the file)</li>
<li><code>fseek</code>:<ul>
<li>Binary file: <em>whence</em> can be <code>SEEK_SET</code>, <code>SEEK_CUR</code>, and <code>SEEK_END</code></li>
<li>Text file: <em>whence</em> has to be <code>SEEK_SET</code>; <em>offset</em> can only be 0 (rewind the file to its beginning) or a value that was returned by <code>ftell</code> for that file.</li>
</ul>
</li>
<li><code>rewind</code>: set the stream to the beginning of the file</li>
</ul>
<p><small><a href="https://gist.github.com/shichao-an/530b106fa164cb197077">apue_ftello.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">off_t</span> <span class="nf">ftello</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>

<span class="cm">/* Returns: current file position indicator if OK, (off_t)−1 on error */</span>

<span class="kt">int</span> <span class="nf">fseeko</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whence</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, −1 on error */</span>
</pre></div>


<p><small><a href="https://gist.github.com/shichao-an/e37050a7db81810e78cc">apue_fgetpos.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">fgetpos</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">,</span> <span class="kt">fpos_t</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">pos</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">fsetpos</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">fpos_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>

<span class="cm">/* Both return: 0 if OK, nonzero on error */</span>
</pre></div>


<h3 id="formatted-io">Formatted I/O</h3>
<h4 id="formatted-output">Formatted Output</h4>
<p><small><a href="https://gist.github.com/shichao-an/558af328d4915c8d77b8">apue_printf.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">int</span> <span class="nf">fprintf</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">int</span> <span class="nf">dprintf</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span>

<span class="cm">/* All three return: number of characters output if OK, negative value if output error */</span>

<span class="kt">int</span> <span class="nf">sprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="cm">/* Returns: number of characters stored in array if OK, negative value if encoding error */</span>

<span class="kt">int</span> <span class="nf">snprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="cm">/* Returns: number of characters that would have been stored in array if buffer was</span>
<span class="cm">   large enough, negative value if encoding error */</span>
</pre></div>


<ul>
<li><code>sprintf</code>: automatically appends a null byte at the end of the array, but this null byte is not included in the return value. <code>sprintf</code> is possible to overflow the buffer.</li>
<li><code>snprintf</code>: returns the number of characters that would have been written to the buffer had it been big enough. If <code>snprintf</code> returns a positive value less than the buffer size n, then the output was not truncated.</li>
</ul>
<h5 id="conversion-specification"><strong>Conversion specification</strong></h5>
<div class="codehilite"><pre><span class="c">%[flags][fldwidth][precision][lenmodifier]convtype</span>
</pre></div>


<ul>
<li>
<p>Flag</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>’</code></td>
<td>(apostrophe) format integer with thousands grouping characters</td>
</tr>
<tr>
<td><code>-</code></td>
<td>left-justify the output in the field</td>
</tr>
<tr>
<td><code>+</code></td>
<td>always display sign of a signed conversion</td>
</tr>
<tr>
<td>(space)</td>
<td>prefix by a space if no sign is generated</td>
</tr>
<tr>
<td><code>#</code></td>
<td>convert using alternative form (include 0x prefix for hexadecimal format, for example)</td>
</tr>
<tr>
<td><code>0</code></td>
<td>prefix with leading zeros instead of padding with spaces</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><code>fldwidth</code> specifies a minimum field width for the conversion</p>
</li>
<li><code>precision</code> specifies the minimum number of digits to appear for integer conversions, the minimum number of digits to appear to the right of the decimal point for floating-point conversions, or the maximum number of bytes for string conversions</li>
<li>
<p><code>lenmodifier</code> pecifies the size of the argument</p>
<table>
<thead>
<tr>
<th>Length modifier</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>hh</code></td>
<td>signed or unsigned <code>char</code></td>
</tr>
<tr>
<td><code>h</code></td>
<td>signed or unsigned <code>short</code></td>
</tr>
<tr>
<td><code>l</code></td>
<td>signed or unsigned <code>long</code> or wide character</td>
</tr>
<tr>
<td><code>ll</code></td>
<td>signed or unsigned <code>long</code> <code>long</code></td>
</tr>
<tr>
<td><code>j</code></td>
<td><code>intmax_t</code> or <code>uintmax_t</code></td>
</tr>
<tr>
<td><code>z</code></td>
<td><code>size_t</code></td>
</tr>
<tr>
<td><code>t</code></td>
<td><code>ptrdiff_t</code></td>
</tr>
<tr>
<td><code>L</code></td>
<td><code>long double</code></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><code>convtype</code> is required.</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Conversion type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>d</code>,<code>i</code></td>
<td>signed decimal</td>
</tr>
<tr>
<td><code>o</code></td>
<td>unsigned octal</td>
</tr>
<tr>
<td><code>u</code></td>
<td>unsigned decimal</td>
</tr>
<tr>
<td><code>x</code>,<code>X</code></td>
<td>unsigned hexadecimal</td>
</tr>
<tr>
<td><code>f</code>,<code>F</code></td>
<td>double floating-point number</td>
</tr>
<tr>
<td><code>e</code>,<code>E</code></td>
<td>double floating-point number in exponential format</td>
</tr>
<tr>
<td><code>g</code>,<code>G</code></td>
<td>interpreted as <code>f</code>, <code>F</code>, <code>e</code>, or <code>E</code>, depending on value converted</td>
</tr>
<tr>
<td><code>a</code>,<code>A</code></td>
<td>double floating-point number in hexadecimal exponential format</td>
</tr>
<tr>
<td><code>c</code></td>
<td>character (with <code>l</code> length modifier, wide character)</td>
</tr>
<tr>
<td><code>s</code></td>
<td>string (with <code>l</code> length modifier, wide character string)</td>
</tr>
<tr>
<td><code>p</code></td>
<td>pointer to a void</td>
</tr>
<tr>
<td><code>n</code></td>
<td>pointer to a signed integer into which is written the number of characters written so far</td>
</tr>
<tr>
<td><code>%</code></td>
<td>a <code>%</code> character</td>
</tr>
<tr>
<td><code>C</code></td>
<td>wide character (XSI option, equivalent to <code>lc</code>)</td>
</tr>
<tr>
<td><code>S</code></td>
<td>wide character string (XSI option, equivalent to <code>ls</code>)</td>
</tr>
</tbody>
</table>
<p>With the normal conversion specification, conversions are applied to the arguments in the order they appear after the format argument. An alternative conversion specification syntax allows the arguments to be named explicitly with the sequence <code>%n$</code> representing the <em>n</em>th argument.</p>
<p>The following five variants of the printf family are similar to the previous five, but the variable argument list (<code>...</code>) is replaced with <code>arg</code>.</p>
<p><small><a href="https://gist.github.com/shichao-an/dbc3fe7bcb50f823951b">apue_vprintf.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdarg.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">vprintf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">arg</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">vfprintf</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span>
             <span class="kt">va_list</span> <span class="n">arg</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">vdprintf</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">arg</span><span class="p">);</span>

<span class="cm">/* All three return: number of characters output if OK, negative value if output error */</span>

<span class="kt">int</span> <span class="nf">vsprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">arg</span><span class="p">);</span>

<span class="cm">/* Returns: number of characters stored in array if OK, negative value if encoding error */</span>

<span class="kt">int</span> <span class="nf">vsnprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span>
              <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">arg</span><span class="p">);</span>

<span class="cm">/* Returns: number of characters that would have been stored in array if buffer was</span>
<span class="cm">   large enough, negative value if encoding error */</span>
</pre></div>


<h4 id="formatted-output_1">Formatted Output</h4>
<p><small><a href="https://gist.github.com/shichao-an/ee777644c2ea82bf38c0">apue_scanf.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">scanf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">int</span> <span class="nf">fscanf</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">int</span> <span class="nf">sscanf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span>

<span class="cm">/* All three return: number of input items assigned, EOF if input error</span>
<span class="cm">   or end of file before any conversion */</span>
</pre></div>


<p>Except for the conversion specifications and white space, other characters in the format have to match the input. If a character doesn’t match, processing stops, leaving the remainder of the input unread.</p>
<h5 id="conversion-specification_1"><strong>Conversion specification</strong></h5>
<div class="codehilite"><pre><span class="c">%[*][fldwidth][m][lenmodifier]convtype</span>
</pre></div>


<ul>
<li><code>*</code> (leading asterisk) causes the result not stored in an argument</li>
<li>
<p><code>m</code>: <strong>assignment-allocation character</strong>, used with the <code>%c</code>, <code>%s</code>, and <code>%[</code> to force a memory  buffer to be allocated to hold the converted string. The caller is responsible for freeing the buffer.</p>
</li>
<li>
<p><code>convtype</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Conversion type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>d</code></td>
<td>signed decimal, base 10</td>
</tr>
<tr>
<td><code>i</code></td>
<td>signed decimal, base determined by format of input</td>
</tr>
<tr>
<td><code>o</code></td>
<td>unsigned octal (input optionally signed)</td>
</tr>
<tr>
<td><code>u</code></td>
<td>unsigned decimal, base 10 (input optionally signed)</td>
</tr>
<tr>
<td><code>x</code>,<code>X</code></td>
<td>unsigned hexadecimal (input optionally signed)</td>
</tr>
<tr>
<td><code>a</code>,<code>A</code>,<code>e</code>,<code>E</code>,<code>f</code>,<code>F</code>,<code>g</code>,<code>G</code></td>
<td>floating-point number</td>
</tr>
<tr>
<td><code>c</code></td>
<td>character (with <code>l</code> length modifier, wide character)</td>
</tr>
<tr>
<td><code>s</code></td>
<td>string (with <code>l</code> length modifier, wide character string)</td>
</tr>
<tr>
<td><code>[</code></td>
<td>matches a sequence of listed characters, ending with <code>]</code></td>
</tr>
<tr>
<td><code>[ˆ</code></td>
<td>matches all characters except the ones listed, ending with <code>]</code></td>
</tr>
<tr>
<td><code>p</code></td>
<td>pointer to a void</td>
</tr>
<tr>
<td><code>n</code></td>
<td>pointer to a signed integer into which is written the number of characters read so far</td>
</tr>
<tr>
<td><code>%</code></td>
<td>a <code>%</code> character</td>
</tr>
<tr>
<td><code>C</code></td>
<td>wide character (XSI option, equivalent to <code>lc</code>)</td>
</tr>
<tr>
<td><code>S</code></td>
<td>wide character string (XSI option, equivalent to <code>ls</code>)</td>
</tr>
</tbody>
</table>
<h3 id="implementation-details">Implementation Details</h3>
<p><small><a href="https://gist.github.com/shichao-an/938ed0cb122d71d66cfc">apue_fileno.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">fileno</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>

<span class="cm">/* Returns: the file descriptor associated with the stream */</span>
</pre></div>


<p>Each standard I/O stream has an associated file descriptor, and we can obtain the descriptor for a stream by calling <code>fileno</code>.</p>
<ul>
<li><a href="https://github.com/shichao-an/glibc-2.21/blob/master/libio/libio.h#L245"><code>FILE</code></a> implementaion in GNU C.</li>
<li><a href="https://github.com/shichao-an/apue.3e/blob/master/stdio/buf.c"><code>buf.c</code></a> (Figure 5.11): print buffering for various standard I/O streams</li>
</ul>
<p>Result on OS X 10.10:</p>
<div class="codehilite"><pre>$ ./buf
enter any character

one line to standard error
stream = stdin, line buffered, buffer size = 4096
stream = stdout, line buffered, buffer size = 4096
stream = stderr, unbuffered, buffer size = 1
stream = /etc/passwd, fully buffered, buffer size = 4096

$ ./buf &lt; /etc/group &gt; std.out 2&gt; std.err
$ cat std.out
enter any character
stream = stdin, fully buffered, buffer size = 4096
stream = stdout, fully buffered, buffer size = 4096
stream = stderr, unbuffered, buffer size = 1
stream = /etc/passwd, fully buffered, buffer size = 4096
$ cat std.err
one line to standard error
</pre></div>


<h3 id="temporary-files">Temporary Files</h3>
<p><small><a href="https://gist.github.com/shichao-an/5679ebc6a3221a63c196">apue_tmpnam.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">tmpnam</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
<span class="kt">FILE</span> <span class="o">*</span><span class="nf">tmpfile</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Returns: pointer to unique pathname Returns: file pointer if OK, NULL on error */</span>
</pre></div>


<ul>
<li><code>tmpnam</code>: generates a string that is a valid pathname that does not match any existing file. This function generates a different pathname each time it is called, up to <code>TMP_MAX</code> times.<ul>
<li>When <em>ptr</em> is <code>NULL</code>: pathname is stored in a static area</li>
<li>When <em>ptr</em> is not <code>NULL</code>: it is assumed that it points to an array of at least <code>L_tmpnam</code> characters. The generated pathname is stored in this array, and <em>ptr</em> is returned as the value of the function.</li>
</ul>
</li>
<li><code>tmpfile</code>: creates a temporary binary file (type <code>wb+</code>) that is automatically removed when it is closed or on program termination.</li>
</ul>
<p><small><a href="https://gist.github.com/shichao-an/f2065b6923b100974256">apue_mkdtemp.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">mkdtemp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">template</span><span class="p">);</span>

<span class="cm">/* Returns: pointer to directory name if OK, NULL on error */</span>

<span class="kt">int</span> <span class="nf">mkstemp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">template</span><span class="p">);</span>

<span class="cm">/* Returns: file descriptor if OK, −1 on error */</span>
</pre></div>


<ul>
<li><code>mkdtemp</code>: creates a uniquely named directory</li>
<li><code>mkstemp</code>: creates a uniquely named regular file</li>
<li><em>template</em>: a pathname whose last six characters are set to <code>XXXXXX</code> (<code>/tmp/dirXXXXXX</code>)</li>
</ul>
<p>Unlike <code>tmpfile</code>, the temporary file created by <code>mkstemp</code> is not removed automatically for us.</p>
<p>The <code>tmpfile</code> and <code>mkstemp</code> functions should be used instead of <code>tmpnam</code>. [p169]</p>
<p>Example:</p>
<ul>
<li><a href="https://gist.github.com/shichao-an/ef04db13cfdaecb65f4b">apue_stdio_mkstemp.c</a>: the array variable is allocated on the stacl. For a pointer to a string literal, only the pointer itself resides on the stack; the (constant) string is stored in the read-only segment of the program.</li>
</ul>
<h3 id="memory-streams">Memory Streams</h3>
<p><strong>Memory streams</strong> are standard I/O streams for which there are no underlying files, although they are still accessed with <code>FILE</code> pointers. All I/O is done by transferring bytes to and from buffers in main memory.</p>
<p><small><a href="https://gist.github.com/shichao-an/1e2ecfc1323bdae6ff58">apue_fmemopen.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">FILE</span> <span class="o">*</span><span class="nf">fmemopen</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
               <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">type</span><span class="p">);</span>

<span class="cm">/* Returns: stream pointer if OK, NULL on error */</span>
</pre></div>


<ul>
<li><em>buf</em>: points to the beginning of the user-allocated buffer and the size argument specifies the size of the buffer in bytes. If the buf argument is null, then the fmemopen function allocates a buffer of <em>size</em> bytes.</li>
<li><em>type</em>: controls how the stream can be used [p171]</li>
</ul>
<p>Note:</p>
<ul>
<li>Under append mode, the current file position is set to the first null byte in the buffer. If the buffer contains no null bytes, then the current position is set to one byte past the end of the buffer. Under non-append mode, the current position is set to the beginning of the buffer. Thus, memory streams aren’t well suited for storing binary data (which might contain null bytes before the end of the data).</li>
<li>If the <em>buf</em> argument is a null pointer, it makes no sense to open the stream for only reading or only writing. Because the buffer is allocated by <code>fmemopen</code> in this case, there is no way to find the buffer's address</li>
<li>A null byte is written at the current position in the stream whenever we increase the amount of data in the stream’s buffer and call <code>fclose</code>, <code>fflush</code>, <code>fseek</code>, <code>fseeko</code>, or <code>fsetpos</code>.</li>
</ul>
<h3 id="alternatives-to-standard-io">Alternatives to Standard I/O</h3>
<p>When we use the line-at-a-time functions, <code>fgets</code> and <code>fputs</code>, the data is usually copied twice: once between the kernel and the standard I/O buffer (when the corresponding read or write is issued) and again between the standard I/O buffer and our line buffer.</p>
<h3 id="doubts-and-solutions">Doubts and Solutions</h3>
<h4 id="verbatim">Verbatim</h4>
<p>Section 5.4 on line buffering [p145]</p>
<blockquote>
<p>Second, whenever input is requested through the standard I/O library from either (a) an unbuffered stream or (b) a line-buffered stream (that requires data to be requested from the kernel), all line-buffered output streams are flushed. The reason for the qualifier on (b) is that the requested data may already be in the buffer, which doesn’t require data to be read from the kernel. Obviously, any input from an unbuffered stream, item (a), requires data to be obtained from the kernel.</p>
</blockquote>
<p>Section 5.8 Standard I/O Efficiency [p155]</p>
<blockquote>
<p>The version using line-at-a-time I/O is almost twice as fast as the version using character-at-a-time I/O. If the fgets and fputs functions are implemented using getc and putc, then we would expect the timing to be similar to the getc version. Actually, we might expect the line-at-a-time version to take longer, since we would be adding the overhead of 200 million extra function calls to the existing 6 million ones.</p>
</blockquote>
<p>Section 5.14 on Memory Stream [p172]</p>
<blockquote>
<p>Third, a null byte is written at the current position in the stream whenever we increase the amount of data in the stream’s buffer and call fclose, fflush, fseek, fseeko, or fsetpos.</p>
</blockquote>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>