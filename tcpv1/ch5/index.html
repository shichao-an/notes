<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/tcpv1/ch5/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 5. The Internet Protocol (IP) - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../github.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
            
                <li >
                    <a href="../..">Home</a>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch5/">Chapter 5. System Calls</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch7/">Chapter 7. Interrupts and Interrupt Handlers</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch8/">Chapter 8. Bottom Halves and Deferring Work</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch9/">Chapter 9. An Introduction to Kernel Synchronization</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch10/">Chapter 10. Kernel Synchronization Methods</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch11/">Chapter 11. Timers and Time Management</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch12/">Chapter 12. Memory Management</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch13/">Chapter 13. The Virtual Filesystem</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch14/">Chapter 14. The Block I/O Layer</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch15/">Chapter 15. The Process Address Space</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                    
                        <li >
                            <a href="../ch3/">Chapter 3. Link Layer</a>
                        </li>
                    
                        <li >
                            <a href="../ch4/">Chapter 4. ARP: Address Resolution Protocol </a>
                        </li>
                    
                        <li class="active">
                            <a href="./">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                    
                        <li >
                            <a href="../ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                    
                        <li >
                            <a href="../ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                    
                        <li >
                            <a href="../ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                    
                        <li >
                            <a href="../ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                    
                        <li >
                            <a href="../ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                    
                        <li >
                            <a href="../ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                    
                        <li >
                            <a href="../ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                    
                        <li >
                            <a href="../ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                    
                        <li >
                            <a href="../ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                    
                        <li >
                            <a href="../ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                    
                        <li >
                            <a href="../ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                    
                        <li >
                            <a href="../headers/">Headers</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UTLK <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../utlk/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../utlk/ch2/">Chapter 2. Memory Addressing</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LSP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../lsp/ch9/">Chapter 9. Memory Management</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TLPI <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../tlpi/ch6/">Chapter 6. Processes</a>
                        </li>
                    
                        <li >
                            <a href="../../tlpi/ch7/">Chapter 7. Memory Allocation</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Others <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../clrs/">CLRS</a>
                        </li>
                    
                        <li >
                            <a href="../../htae/">HTAE</a>
                        </li>
                    
                        <li >
                            <a href="../../golang/">Go</a>
                        </li>
                    
                        <li >
                            <a href="../../bash/">Bash</a>
                        </li>
                    
                        <li >
                            <a href="../../c/">C</a>
                        </li>
                    
                        <li >
                            <a href="../../asm/">x86 assembly</a>
                        </li>
                    
                        <li >
                            <a href="../../iptables/">iptables</a>
                        </li>
                    
                        <li >
                            <a href="../../nginx/">Nginx</a>
                        </li>
                    
                        <li >
                            <a href="../../vim/">Vim</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/tcpv1/ch5.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-5-the-internet-protocol-ip">Chapter 5. The Internet Protocol (IP)</a></li>
        
    
        <li class="main "><a href="#introduction">Introduction</a></li>
        
    
        <li class="main "><a href="#ipv4-and-ipv6-headers">IPv4 and IPv6 Headers</a></li>
        
            <li><a href="#ipv4-header">IPv4 Header *</a></li>
        
            <li><a href="#ipv6-header">IPv6 Header *</a></li>
        
            <li><a href="#size-and-network-byte-order">Size and network byte order *</a></li>
        
            <li><a href="#ip-header-fields">IP Header Fields</a></li>
        
            <li><a href="#the-internet-checksum">The Internet Checksum</a></li>
        
            <li><a href="#ds-field-and-ecn">DS Field and ECN</a></li>
        
            <li><a href="#ip-options">IP Options</a></li>
        
    
        <li class="main "><a href="#ipv6-extension-headers">IPv6 Extension Headers</a></li>
        
            <li><a href="#ipv6-options">IPv6 Options</a></li>
        
            <li><a href="#routing-header">Routing Header</a></li>
        
            <li><a href="#fragment-header">Fragment Header</a></li>
        
    
        <li class="main "><a href="#ip-forwarding">IP Forwarding</a></li>
        
            <li><a href="#forwarding-table">Forwarding Table</a></li>
        
            <li><a href="#ip-forwarding-actions">IP Forwarding Actions</a></li>
        
            <li><a href="#examples-of-ip-forwarding">Examples of IP Forwarding</a></li>
        
            <li><a href="#discussion-ip-forwarding">Discussion (IP Forwarding)</a></li>
        
    
        <li class="main "><a href="#mobile-ip">Mobile IP</a></li>
        
    
        <li class="main "><a href="#host-processing-of-ip-datagrams">Host Processing of IP Datagrams</a></li>
        
            <li><a href="#host-models">Host Models</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-5-the-internet-protocol-ip"><strong>Chapter 5. The Internet Protocol (IP)</strong></h3>
<blockquote>
<p>IP is the workhorse protocol of the TCP/IP protocol suite.
<small><em>TCPv1</em></small></p>
</blockquote>
<h3 id="introduction">Introduction</h3>
<p>IP provides a best-effort, connectionless datagram delivery service. When something goes wrong, such as a router temporarily running out of buffers, IP simly throws away some data. Any required reliability must be provided by the upper layers (e.g. TCP). IPv4 and IPv6 both use this basic best-effort delivery model.</p>
<p>The term <em>connectionless</em> means that IP does not maintain any connection state information about related datagrams within the network elements (within the routers):</p>
<ul>
<li>Each IP datagram is handled independently from all other others.</li>
<li>Datagrams can be delivered out of order.</li>
</ul>
<p>This chapter is on IPv4 and IPv6 header fields, and describes how IP forwarding works.</p>
<h3 id="ipv4-and-ipv6-headers">IPv4 and IPv6 Headers</h3>
<h5 id="ipv4-header"><strong>IPv4 Header</strong> *</h5>
<p><a href="../figure_5-1.png" title="The IPv4 datagram. The header is of variable size, limited to fifteen 32-bit words (60 bytes) by the 4-bit IHL field. A typical IPv4 header contains 20 bytes (no options). The source and destination addresses are 32 bits long. Most of the second 32-bit word is used for the IPv4 fragmentation function. A header checksum helps ensure that the fields in the header are delivered correctly to the proper destination but does not protect the data."><img alt="The IPv4 datagram. The header is of variable size, limited to fifteen 32-bit words (60 bytes) by the 4-bit IHL field. A typical IPv4 header contains 20 bytes (no options). The source and destination addresses are 32 bits long. Most of the second 32-bit word is used for the IPv4 fragmentation function. A header checksum helps ensure that the fields in the header are delivered correctly to the proper destination but does not protect the data." src="../figure_5-1_600.png" /></a></p>
<h5 id="ipv6-header"><strong>IPv6 Header</strong> *</h5>
<p><a href="../figure_5-2.png" title="The IPv6 header is of fixed size (40 bytes) and contains 128-bit source and destination addresses. The Next Header field is used to indicate the presence and types of additional extension headers that follow the IPv6 header, forming a daisy chain of headers that may include special extensions or processing directives. Application data follows the header chain, usually immediately following a transport-layer header."><img alt="The IPv6 header is of fixed size (40 bytes) and contains 128-bit source and destination addresses. The Next Header field is used to indicate the presence and types of additional extension headers that follow the IPv6 header, forming a daisy chain of headers that may include special extensions or processing directives. Application data follows the header chain, usually immediately following a transport-layer header." src="../figure_5-2_600.png" /></a></p>
<h5 id="size-and-network-byte-order"><strong>Size and network byte order</strong> *</h5>
<ul>
<li>The normal size of the IPv4 header is 20 bytes, unless options are present (which is rare).</li>
<li><u>The IPv6 header is twice as large as the IPv4 Header but never has any options.</u> It may have <em>extension headers</em>.</li>
</ul>
<p>In our pictures of headers and datagrams, for a 32-bit value, <u>the most significant bit is numbered 0 at the left, and the least significant bit of a 32-bit value is numbered 31 on the right.</u> The 4 bytes in a 32-bit value are transmitted in the following order: bits 0–7 first, then bits 8–15, then 16–23, and bits 24–31 last. This is called <strong>big endian</strong> byte ordering, which is the byte ordering required for all binary integers in the TCP/IP headers as they traverse a network. It is also called <strong>network byte order</strong>. Computer CPUs that store binary integers in little endian format must convert the header values into network byte order for transmission and back again for reception.</p>
<h4 id="ip-header-fields">IP Header Fields</h4>
<ul>
<li>The <strong>Version</strong> field is the first field (only 4 bits or one nibble wide). It contains the version number of the IP datagram: 4 for IPv4 and 6 for IPv6.<ul>
<li>This is the only field that IPv4 and IPv6 of which share the location. The two protocols are not directly interoperable, which means a host or router must handle either IPv4 or IPv6 (or both, called <strong>dual stack</strong>) separately.</li>
</ul>
</li>
<li>The <strong>Internet Header Length (IHL)</strong> field is the number of 32-bit words in the IPv4 header, including any options.<ul>
<li>Because this is also a 4-bit field, the IPv4 header is limited to a maximum of fifteen 32-bit words or 60 bytes.</li>
<li>The normal value of this field (when no options are present) is 5. There is no such field in IPv6 because the header length is fixed at 40 bytes.</li>
</ul>
</li>
<li>The 8 bits following the header length (IPv4) are two fields used for special processing of the datagram when it is forwarded, in both IPv4 and IPv6:<ul>
<li>The first 6 bits are the <strong>Differentiated Services (DS)</strong> field.</li>
<li>The last 2 bits are the <strong>Explicit Congestion Notification (ECN)</strong> field or indicator bits.</li>
</ul>
</li>
<li>
<p>The <strong>Total Length</strong> field is the total length of the IPv4 datagram in bytes.</p>
<ul>
<li>Using this field and the IHL field can indicate where the data portion of the datagram starts, and its length.</li>
<li>Because this is a 16-bit field, the maximum size of an IPv4 datagram (including header) is 65,535 bytes.</li>
<li>This field is required in the header because some lower-layer protocols that carry IPv4 datagrams do not (accurately) convey the size of encapsulated datagrams on their own. For example, Ethernet pads small frames to be a minimum length (64 bytes) and an IPv4 datagram (minimum 20 bytes) can be smaller than the minimum Ethernet payload size (46 bytes). Without the Total Length field, the IPv4 implementation would not know how much of a 46-byte Ethernet frame was really an IP datagram, as opposed to padding.</li>
<li>
<p>Although it is possible to send a 65,535-byte IP datagram, most link layers (such as Ethernet) are not able to carry one this large without fragmenting it into smaller pieces.</p>
<ul>
<li><u>In IPv4, a host is not required to be able to receive an IPv4 datagram larger than 576 bytes.</u></li>
<li><u>In IPv6 a host must be able to process a datagram at least as large as the MTU of the link to which it is attached, and the minimum link MTU is 1280 bytes.</u></li>
</ul>
<p>Many applications that use the UDP protocol (<a href="../ch10/">Chapter 10</a>) for data transport (e.g., DNS, DHCP, etc.) use a limited data size of 512 bytes to avoid the 576-byte IPv4 limit. TCP chooses its own datagram size based on additional information (<a href="../ch15/">Chapter 15</a>).</p>
</li>
<li>
<p>When an IPv4 datagram is fragmented into multiple smaller fragments, each of which itself is an independent IP datagram, the Total Length field reflects the length of the particular fragment.</p>
</li>
</ul>
</li>
<li>
<p>The <strong>Payload Length</strong> field is the length of the IPv6 datagram not including the length of the header; extension headers, however, are included in the Payload Length field. In IPv6, fragmentation is not supported by the header.</p>
<ul>
<li>The 16-bit size of this field limits its maximum value to 65,535 (64KB), which applies to the payload length, not the entire datagram.</li>
<li>In addition, IPv6 supports a <strong>jumbogram</strong> option that provides for the possibility (at least theoretically) of single packets with payloads as large as 4GB (4,294,967,295 bytes).</li>
</ul>
</li>
<li>The <strong>Identification</strong> field (IPv4) indentifies each datagram sent by an IPv4 host. To prevent confusion among fragments of a datagrams, the sending host normally increments an internal counter by 1 each time a datagram is sent (from one of its IP addresses) and copies the value of the counter into the IPv4 Identification field.<ul>
<li>This field is most important for implementing fragmentation, along with the Flags and Fragment Offset fields.</li>
<li>In IPv6, this field shows up in the Fragmentation extension header,</li>
</ul>
</li>
<li>The <strong>Time-to-Live</strong> field, or <strong>TTL</strong>, sets an upper limit on the number of routers through which a datagram can pass.<ul>
<li>This field initialized by the sender to some value (64 is recommended, although 128 or 255 is not uncommon) and decremented by 1 by every router that forwards the datagram. <u>When this field reaches 0, the datagram is thrown away, and the sender is notified with an ICMP message</u> (<a href="ch8.md">Chapter 8</a>). This prevents packets from getting caught in the network forever should an unwanted routing loop occur.</li>
<li>In IPv6, the field has been renamed to its de facto use: <strong>Hop Limit</strong>.</li>
</ul>
</li>
<li>The <strong>Protocol</strong> field in the IPv4 header contains a number indicating the type of data found in the payload portion of the datagram. The most common values are 17 (for UDP) and 6 (for TCP).<ul>
<li>This field provides a demultiplexing feature so that the IP protocol can be used to carry payloads of more than one protocol type. Although this field originally specified the transport-layer protocol the datagram is encapsulating, it now can identify the encapsulated protocol, which may or not be a transport protocol. Other encapsulations are possible, such as IPv4-in-IPv4 (value 4). The official list of the possible values of the Protocol field
is given in the <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">assigned numbers page</a>.</li>
</ul>
</li>
<li>The <strong>Next Header</strong> field in the IPv6 header generalizes the Protocol field from IPv4. It is used to indicate the type of header following the IPv6 header. This field may contain any values defined for the IPv4 Protocol field, or any of the values associated with the IPv6 extension headers.</li>
<li>The <strong>Header Checksum</strong> field is calculated <em>over the IPv4 header only</em>, which means that <u>the payload of the IPv4 datagram (e.g., TCP or UDP data) is not checked for correctness by the IP protocol.</u> To ensure the payload has been correctly delivered, other protocols must cover any important data that follows the header with their own data-integrity-checking mechanisms.<ul>
<li>Almost all protocols encapsulated in IP (ICMP, IGMP, UDP, and TCP) have a checksum in their own headers to cover their header and data and also to cover certain parts of the IP header they deem important (a form of "layering violation").</li>
<li>The IPv6 header does not have any checksum field.</li>
<li>The algorithm used in computing a checksum (also used by most of the other Internet-related protocols) is sometimes known as the <strong>Internet checksum</strong>.</li>
<li>When an IPv4 datagram passes through a router, its header checksum must change as a result of decrementing the TTL field.</li>
</ul>
</li>
<li>The <strong>Source IP Address</strong> is the IP address of the datagram's sender and the <strong>Destination IP Address</strong> of where the datagram is destined. These are 32-bit values for IPv4 and 128-bit values for IPv6, and they usually identify a single interface on a computer, although multicast and broadcast addresses (<a href="../ch2/">Chapter 2</a>) violate this rule.</li>
</ul>
<h4 id="the-internet-checksum">The Internet Checksum</h4>
<p>The <strong>Internet checksum</strong> is a 16-bit mathematical sum used to determine, with reasonably high probability, whether a received message or portion of a message matches the one sent. the Internet checksum algorithm is not the same as the common <strong>cyclic redundancy check</strong> (CRC), which offers stronger protection.</p>
<p>To compute the IPv4 header checksum for an outgoing datagram, the value of the datagram’s Checksum field is first set to 0. Then, the 16-bit one’s complement sum of the header is calculated (the entire header is considered a sequence of 16-bit words). The 16-bit one’s complement of this sum is then stored in the Checksum field to make the datagram ready for transmission.</p>
<p>When an IPv4 datagram is received, a checksum is computed across the whole header, including the value of the Checksum field itself. Assuming there are no errors, the computed checksum value is always 0 (a one’s complement of the value FFFF). <u>The value of the Checksum field in the packet can never be FFFF.</u> If it were, the sum (prior to the final one’s complement operation at the sender) would have to have been 0. No sum can ever be 0 using one’s complement addition unless all the bytes are 0. (<a href="https://en.wikipedia.org/wiki/Signed_number_representations#Ones.27_complement">end-round carry</a>)</p>
<p>When the header is found to be bad (the computed checksum is nonzero), the IPv4 implementation discards the received datagram. No error message is generated. It is up to the higher layers to somehow detect the missing datagram and retransmit if necessary.</p>
<h5 id="mathematics-of-the-internet-checksum"><strong>Mathematics of the Internet Checksum</strong></h5>
<p>For the mathematically inclined, the set of 16-bit hexadecimal values V = {0001, . . . , FFFF} and the one’s complement sum operation + together form an <a href="https://en.wikipedia.org/wiki/Abelian_group">Abelian group</a>. The following properties are obeyed:</p>
<ul>
<li>For any X,Y in V, (X + Y) is in V [closure]</li>
<li>For any X,Y,Z in V, X + (Y + Z) = (X + Y) + Z [associativity]</li>
<li>For any X in V, e + X = X + e = X where e = FFFF [identity]</li>
<li>For any X in V, there is an X′ in V such that X + X′ = e [inverse]</li>
<li>For any X,Y in V, (X + Y) = (Y + X) [commutativity]</li>
</ul>
<p>Note that in the set V and the group &lt;V,+&gt;, number 0000 deleted the from consideration. If we put the number 0000 in the set V, then &lt;V,+&gt; is not a group any longer. [p187-188]</p>
<h4 id="ds-field-and-ecn">DS Field and ECN</h4>
<p>The third and fourth fields of the IPv4 header (second and third fields of the IPv6 header) are the <strong>Differentiated Services</strong> (called DS Field) and <strong>ECN</strong> fields, formerly called the <strong>ToS Byte</strong> or IPv6 <strong>Traffic Class</strong>.</p>
<p>Differentiated Services (called <em>DiffServ</em>) is a framework and set of standards aimed at supporting differentiated classes of service (beyond just best-effort) on the Internet. IP datagrams that are marked in certain ways may be forwarded differently (e.g., with higher priority) and can lead to increased or decreased queuing delay in the network and other special effects (possibly with associated special fees imposed by an ISP). [p188]</p>
<p>The Differentiated Services Code Point (DSCP) is a number (in the DS Field) that refers to a particular predefined arrangement of bits with agreed-upon meaning. Datagrams have a DSCP assigned to them when they are given to the network infrastructure that remains unmodified during delivery ,but policies (such as how many high-priority packets are allowed to be sent in a period of time) may cause a change in DSCP during delivery. [p188]</p>
<p>The pair of ECN bits marks a datagram with a <em>congestion indicator</em> when passing through a router that has a significant amount of internally queued traffic. Both bits are set by persistently congested ECN-aware routers when forwarding packets. When a marked packet is received at the destination, some protocol (such as TCP) will notice that the packet is marked and indicate this fact back to the sender, which would then slow down, thereby easing congestion before a router is forced to drop traffic because of overload. This mechanism is one of several aimed at avoiding or dealing with network congestion.</p>
<p>(Original uses for the ToS and Traffic Class skipped) [p188-189]</p>
<p>The 6-bit DS Field holds the DSCP, providing support for 64 distinct code points. The particular value of the DSCP, expressed as <strong>per-hop behavior</strong> (PHB), tells a router the forwarding treatment or special handling the datagram should receive. The default value for the DSCP is generally 0, which corresponds to routine, best-effort Internet traffic.</p>
<p><a href="../figure_5-5.png" title="The DS Field contains the DSCP in 6 bits (5 bits are currently standardized to indicate the forwarding treatment the datagram should receive when forwarded by a compliant router). The following 2 bits are used for ECN and may be turned on in the datagram when it passes through a persistently congested router. When such datagrams arrive at their destinations, the congestion indication is sent back to the source in a later datagram to inform the source that its datagrams are passing through one or more congested routers."><img alt="The DS Field contains the DSCP in 6 bits (5 bits are currently standardized to indicate the forwarding treatment the datagram should receive when forwarded by a compliant router). The following 2 bits are used for ECN and may be turned on in the datagram when it passes through a persistently congested router. When such datagrams arrive at their destinations, the congestion indication is sent back to the source in a later datagram to inform the source that its datagrams are passing through one or more congested routers." src="../figure_5-5.png" /></a></p>
<p>As indicated in the table below, the DSCP values are divided into three pools: standardized, experimental/local use (EXP/LU), and experimental/local use.</p>
<table>
<thead>
<tr>
<th>Pool</th>
<th>Code Point Prefix</th>
<th>Policy</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>xxxxx0</td>
<td>Standards</td>
</tr>
<tr>
<td>2</td>
<td>xxxx11</td>
<td>EXP/LU</td>
</tr>
<tr>
<td>3</td>
<td>xxxx01</td>
<td>EXP/LU(*)</td>
</tr>
</tbody>
</table>
<p>A router is to first segregate traffic into different classes. Traffic within a common class may have different drop probabilities, allowing the router to decide what traffic to drop first if it is forced to discard traffic.</p>
<ul>
<li>The 3-bit class selector provides for eight defined code points (called the <strong>class selector code points</strong>) that correspond to PHBs with a specified minimum set of features providing similar functionality to the earlier IP precedence capability. These are called <strong>class selector compliant PHBs</strong>. Code points of the form xxx000 always map to such PHBs.</li>
<li>The <strong>Assured Forwarding</strong> (AF) group provides forwarding of IP packets in a fixed number of independent AF classes. Traffic from one class is forwarded separately from other classes. Within a traffic class, a datagram is assigned a <strong>drop precedence</strong>. Datagrams of higher drop precedence in a class areare discarded with higher priority over those with lower drop precedence in the same class. Combining the traffic class and drop precedence, the name <em>AFij</em> corresponds to assured forwarding class <em>i</em> with drop precedence <em>j</em>.</li>
<li>The <strong>Expedited Forwarding</strong> (EF) service provides the appearance of an uncongested network (EF traffic should receive relatively low delay, jitter, and loss). This requires the rate of EF traffic going out of a router to be at least as large as the rate coming in. Consequently, EF traffic will only ever have to wait in a router queue behind other EF traffic.</li>
</ul>
<p>The following table indicates the class selector DSCP values:</p>
<p><small></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
<th>Reference</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CS0</td>
<td>000000</td>
<td>[RFC2474]</td>
<td>Class selector (best-effort/routine)</td>
</tr>
<tr>
<td>CS1</td>
<td>001000</td>
<td>[RFC2474]</td>
<td>Class selector (priority)</td>
</tr>
<tr>
<td>CS2</td>
<td>010000</td>
<td>[RFC2474]</td>
<td>Class selector (immediate)</td>
</tr>
<tr>
<td>CS3</td>
<td>011000</td>
<td>[RFC2474]</td>
<td>Class selector (flash)</td>
</tr>
<tr>
<td>CS4</td>
<td>100000</td>
<td>[RFC2474]</td>
<td>Class selector (flash override)</td>
</tr>
<tr>
<td>CS5</td>
<td>101000</td>
<td>[RFC2474]</td>
<td>Class selector (CRITIC/ECP)</td>
</tr>
<tr>
<td>CS6</td>
<td>110000</td>
<td>[RFC2474]</td>
<td>Class selector (internetwork control)</td>
</tr>
<tr>
<td>CS7</td>
<td>111000</td>
<td>[RFC2474]</td>
<td>Class selector (control)</td>
</tr>
<tr>
<td>AF11</td>
<td>001010</td>
<td>[RFC2597]</td>
<td>Assured Forwarding (class 1,dp 1)</td>
</tr>
<tr>
<td>AF12</td>
<td>001100</td>
<td>[RFC2597]</td>
<td>Assured Forwarding (1,2)</td>
</tr>
<tr>
<td>AF13</td>
<td>001110</td>
<td>[RFC2597]</td>
<td>Assured Forwarding (1,3)</td>
</tr>
<tr>
<td>AF21</td>
<td>010010</td>
<td>[RFC2597]</td>
<td>Assured Forwarding (2,1)</td>
</tr>
<tr>
<td>AF22</td>
<td>010100</td>
<td>[RFC2597]</td>
<td>Assured Forwarding (2,2)</td>
</tr>
<tr>
<td>AF23</td>
<td>010110</td>
<td>[RFC2597]</td>
<td>Assured Forwarding (2,3)</td>
</tr>
<tr>
<td>AF31</td>
<td>011010</td>
<td>[RFC2597]</td>
<td>Assured Forwarding (3,1)</td>
</tr>
<tr>
<td>AF32</td>
<td>011100</td>
<td>[RFC2597]</td>
<td>Assured Forwarding (3,2)</td>
</tr>
<tr>
<td>AF33</td>
<td>011110</td>
<td>[RFC2597]</td>
<td>Assured Forwarding (3,3)</td>
</tr>
<tr>
<td>AF41</td>
<td>100010</td>
<td>[RFC2597]</td>
<td>Assured Forwarding (4,1)</td>
</tr>
<tr>
<td>AF42</td>
<td>100100</td>
<td>[RFC2597]</td>
<td>Assured Forwarding (4,2)</td>
</tr>
<tr>
<td>AF43</td>
<td>100110</td>
<td>[RFC2597]</td>
<td>Assured Forwarding (4,3)</td>
</tr>
<tr>
<td>EF PHB</td>
<td>101110</td>
<td>[RFC3246]</td>
<td>Expedited Forwarding</td>
</tr>
<tr>
<td>VOICE-ADMIT</td>
<td>101100</td>
<td>[RFC5865]</td>
<td>Capacity-Admitted Traffic</td>
</tr>
</tbody>
</table>
<p></small></p>
<h4 id="ip-options">IP Options</h4>
<p>IP options may be selected on a per-datagram basis. Many of the options are no longer practical or desirable because of the limited size of the IPv4 header or concerns regarding security. With IPv6, most of the options have been removed or altered and are in the basic IPv6 header but are placed after the IPv6 header in one or more extension headers.</p>
<p>An IP router that receives a datagram containing options should perform special processing. In some cases IPv6 routers process extension headers, but many headers are designed to be processed only by end hosts. In some routers, datagrams with options or extensions are not forwarded as fast as ordinary datagrams.</p>
<p>The table shows most of the IPv4 options that have been standardized over the years.</p>
<p><a href="../table_5-4.png" title="Options, if present, are carried in IPv4 packets immediately after the basic IPv4 header. Options are identified by an 8-bit option Type field. This field is subdivided into three subfields: Copy (1 bit), Class (2 bits), and Number (5 bits). Options 0 and 1 are a single byte long, and most others are variable in length. Variable options consist of 1 byte of type identifier, 1 byte of length, and the option itself."><img alt="Options, if present, are carried in IPv4 packets immediately after the basic IPv4 header. Options are identified by an 8-bit option Type field. This field is subdivided into three subfields: Copy (1 bit), Class (2 bits), and Number (5 bits). Options 0 and 1 are a single byte long, and most others are variable in length. Variable options consist of 1 byte of type identifier, 1 byte of length, and the option itself." src="../table_5-4.png" /></a></p>
<p>The options area always ends on a 32-bit boundary. Pad bytes with a value of 0 are added if necessary. This ensures that the IPv4 header is always a multiple of 32 bits (as required by the IHL field). [p192]</p>
<p>Options are identified by an 8-bit option <em>Type</em> field. This field is subdivided into three subfields: <em>Copy</em> (1 bit), <em>Class</em> (2 bits), and <em>Number</em> (5 bits). Options 0 and 1 are a single byte long, and most others are variable in length. Variable options consist of 1 byte of type identifier, 1 byte of length, and the option itself.</p>
<p>Most of the standardized options are rarely or never used in the Internet today. In addition, the options are primarily for diagnostic purposes and make the construction of firewalls more cumbersome and risky. Thus, IPv4 options are typically disallowed or stripped at the perimeter of enterprise networks by firewalls. (<a href="../ch7.m">Chapter 7</a>)</p>
<p>Within enterprise networks, where the average path length is smaller and protection from malicious users may be less of a concern, options can still be useful. In addition, since the <strong>Router Alert</strong> option is designed primarily as a performance optimization and does not change fundamental router behavior, it is permitted more often than the other options. Some router implementations have a highly optimized internal pathway for forwarding IP traffic containing no options. The Router Alert option informs routers that a packet requires processing beyond the conventional forwarding algorithms. The experimental <strong>Quick-Start</strong> option at the end of the table is applicable to both IPv4 and IPv6.</p>
<h3 id="ipv6-extension-headers">IPv6 Extension Headers</h3>
<p>In IPv6, special functions such as those provided by options in IPv4 can be enabled by adding extension headers that follow the IPv6 header. IPv6 header is fixed at 40 bytes, and extension headers are added only when needed. [p194]</p>
<p>In choosing the IPv6 header to be of a fixed size, and requiring that extension headers be processed only by end hosts (with one exception), design and construction of high-performance routers are easier because the demands on packet processing at routers can be simpler than with IPv4.</p>
<p>Extension headers, along with headers of higher-layer protocols such as TCP or UDP, are chained together with the IPv6 header to form a cascade of headers (see the figure below). The <strong>Next Header</strong> field in each header indicates the type of the subsequent header, which could be an IPv6 extension header or some other type.  The value of 59 indicates the end of the header chain. The most possible values for the Next Header field are provided in the following table.</p>
<p><a href="../figure_5-6.png" title="IPv6 headers form a chain using the Next Header field. Headers in the chain may be IPv6 extension headers or transport headers. The IPv6 header appears at the beginning of the datagram and is always 40 bytes long."><img alt="IPv6 headers form a chain using the Next Header field. Headers in the chain may be IPv6 extension headers or transport headers. The IPv6 header appears at the beginning of the datagram and is always 40 bytes long." src="../figure_5-6.png" /></a></p>
<p>This figure shows IPv6 headers form a chain using the Next Header field. Headers in the chain may be IPv6 extension headers or transport headers. The IPv6 header appears at the beginning of the datagram and is always 40 bytes long.</p>
<p><a href="../table_5-5.png" title="The values for the IPv6 Next Header field may indicate extensions or headers for other protocols. The same values are used with the IPv4 Protocol field, where appropriate."><img alt="The values for the IPv6 Next Header field may indicate extensions or headers for other protocols. The same values are used with the IPv4 Protocol field, where appropriate." src="../table_5-5.png" /></a></p>
<p>This table show values for the IPv6 Next Header field may indicate extensions or headers for other protocols. The same values are used with the IPv4 Protocol field, where appropriate. The IPv6 extension header mechanism distinguishes some functions (e.g., routing and fragmentation) from options.</p>
<ul>
<li>The order of the extension headers is given as a recommendation, except for the location of the <strong>Hop-by-Hop Options</strong> (HOPOPT)), which is mandatory, so an IPv6 implementation must be prepared to process extension headers in the order in which they are received.</li>
<li>Only the <strong>Destination Options</strong> header can be used twice: the first time for options pertaining to the destination IPv6 address contained in the IPv6 header and the second time (position 8) for options pertaining to the final destination of the datagram.</li>
<li>In some cases (e.g., when the <a href="#routing-header">Routing header</a> is used), the <strong>Destination IP Address</strong> field in the IPv6 header changes as the datagram is forwarded to its ultimate destination.</li>
</ul>
<h4 id="ipv6-options">IPv6 Options</h4>
<p>IPv6 options, if present, are grouped into either of the following:</p>
<ul>
<li><strong>Hop-by-Hop Options</strong>: relevant to every router along a datagram’s path</li>
<li><strong>Destination Options</strong>: relevant only to the recipient</li>
</ul>
<p>Hopby-Hop Options (called HOPOPTs) are the only ones that need to be processed by every router a packet encounters.  The format for encoding options within the Hop-by-Hop and Destination Options extension headers is common.</p>
<p>The Hop-by-Hop and Destination Options headers are capable of holding more than one option. Each of these options is encoded as <strong>type-length-value</strong> (TLV) sets, as shown below:</p>
<p><a href="../figure_5-7.png" title="Hop-by-hop and Destination Options are encoded as TLV sets. The first byte gives the option type, including subfields indicating how an IPv6 node should behave if the option is not recognized, and whether the option data might change as the datagram is forwarded. The Opt Data Len field gives the size of the option data in bytes."><img alt="Hop-by-hop and Destination Options are encoded as TLV sets. The first byte gives the option type, including subfields indicating how an IPv6 node should behave if the option is not recognized, and whether the option data might change as the datagram is forwarded. The Opt Data Len field gives the size of the option data in bytes." src="../figure_5-7.png" /></a></p>
<p>In the TLV sets, the first byte gives the option type, including subfields indicating how an IPv6 node should behave if the option is not recognized, and whether the option data might change as the datagram is forwarded. The <strong>Opt Data Len</strong> field gives the size of the option data in bytes.</p>
<p>The 2 high-order bits in an IPv6 TLV option type indicate whether an IPv6 node should forward or drop the datagram if the option is not recognized, and whether a message indicating the datagram’s fate should be sent back to the sender, as shown in the table below:</p>
<p><a href="../table_5-6.png" title="The 2 high-order bits in an IPv6 TLV option type indicate whether an IPv6 node should forward or drop the datagram if the option is not recognized, and whether a message indicating the datagram’s fate should be sent back to the sender."><img alt="The 2 high-order bits in an IPv6 TLV option type indicate whether an IPv6 node should forward or drop the datagram if the option is not recognized, and whether a message indicating the datagram’s fate should be sent back to the sender." src="../table_5-6.png" /></a></p>
<p>Options in IPv6 are carried in either Hop-by-Hop (H) or Destination (D) Options extension headers. The option Type field contains the value from the "Type" column with the Action and Change subfields denoted in binary. The "Length" column contains the value of the Opt Data Len byte. See the table below:</p>
<p><a href="../table_5-7.png" title="Options in IPv6 are carried in either Hop-by-Hop (H) or Destination (D) Options extension headers. The option Type field contains the value from the “Type” column with the Action and Change subfields denoted in binary. The “Length” column contains the value of the Opt Data Len byte from Figure 5-7. The Pad1 option is the only one lacking this byte."><img alt="Options in IPv6 are carried in either Hop-by-Hop (H) or Destination (D) Options extension headers. The option Type field contains the value from the “Type” column with the Action and Change subfields denoted in binary. The “Length” column contains the value of the Opt Data Len byte from Figure 5-7. The Pad1 option is the only one lacking this byte." src="../table_5-7.png" /></a></p>
<p>[p196-197]</p>
<h5 id="pad1-and-padn"><strong>Pad1 and PadN</strong></h5>
<p>IPv6 options are aligned to 8-byte offsets, so options that are naturally smaller are padded with 0 bytes to round out their lengths to the nearest 8 bytes. [p197]</p>
<h5 id="ipv6-jumbo-payload"><strong>IPv6 Jumbo Payload</strong></h5>
<p>In some TCP/IP networks, such as those used to interconnect supercomputers, the normal 64KB limit on the IP datagram size can lead to unwanted overhead when moving large amounts of data. The IPv6 <strong>Jumbo Payload</strong> option specifies an IPv6 datagram with payload size larger than 65,535 bytes, called a <strong>jumbogram</strong>. This option need not be implemented by nodes attached to links with MTU sizes below 64KB. The Jumbo Payload option provides a 32-bit field for holding the payload size for datagrams with payloads of sizes between 65,535 and 4,294,967,295 bytes (4 GB).</p>
<p>When a jumbogram is formed for transmission, its normal Payload Length field is set to 0. The TCP protocol makes use of the Payload Length field in order to compute its checksum using the Internet checksum algorithm described previously. When the Jumbo Payload option is used, TCP must be careful to use the length value from the option instead of the regular Length field in the base header. [p198]</p>
<h5 id="tunnel-encapsulation-limit"><strong>Tunnel Encapsulation Limit</strong></h5>
<p><a href="https://en.wikipedia.org/wiki/Tunneling_protocol"><strong>Tunneling</strong></a> refers to the encapsulation of one protocol in another that does not conform to traditional layering. For example, IP datagrams may be encapsulated inside the payload portion of another IP datagram.</p>
<ul>
<li>Tunneling can be used to form virtual <a href="https://en.wikipedia.org/wiki/Overlay_network">overlay networks</a>, in which one network (e.g., the Internet) acts as a well-connected link layer for another layer of IP.</li>
<li>Tunnels can be nested in the sense that datagrams that are in a tunnel may themselves be placed in a tunnel, in a recursive fashion.</li>
</ul>
<p>Using Tunnel Encapsulation Limit option, a sender can specify a limit to have control over how many tunnel levels are ultimately used for encapsulation. Using this option.</p>
<h5 id="router-alert"><strong>Router Alert</strong></h5>
<p>The Router Alert option indicates that the datagram contains information that needs to be processed by a router. It is used for the same purpose as the IPv4 Router Alert option.</p>
<h5 id="quick-start"><strong>Quick-Start</strong></h5>
<p>The Quick-Start (QS) option is used in conjunction with the experimental QuickStart procedure for TCP/IP specified in [RFC4782]. It is applicable to both IPv4 and IPv6 but at present is suggested only for private networks and not the global Internet. [p199]</p>
<h5 id="calipso"><strong>CALIPSO</strong></h5>
<p>This option is used for supporting the <strong>Common Architecture Label IPv6 Security Option</strong> (CALIPSO) [RFC5570] in certain private networks.</p>
<h5 id="home-address"><strong>Home Address</strong></h5>
<p>This option holds the "home" address of the IPv6 node sending the datagram when IPv6 mobility options are in use. Mobile IP (<a href="#mobile-ip">Section 5.5</a>) specifies a set of procedures for handling IP nodes that may change their point of network attachment without losing their higher-layer network connections. [p199]</p>
<h4 id="routing-header">Routing Header</h4>
<p>The IPv6 Routing header provides a mechanism for the sender of an IPv6 datagram to control the path the datagram takes through the network. Two different versions of the routing extension header have been specified: type 0 (RH0) and type 2 (RH2):</p>
<ul>
<li>RH0 has been deprecated because of security concerns [RFC5095]</li>
<li>RH2 is defined in conjunction with Mobile IP.</li>
</ul>
<p>To best understand the Routing header, we begin by discussing RH0 and then investigate why it has been deprecated and how it differs from RH2. RH0 specifies one or more IPv6 nodes to be "visited" as the datagram is forwarded.</p>
<p><a href="../figure_5-8.png" title="The now-deprecated Routing header type 0 (RH0) generalizes the IPv4 loose and strict Source Route and Record Route options. It is constructed by the sender to include IPv6 node addresses that act as waypoints when the datagram is forwarded. Each address can be specified as a loose or strict address. A strict address must be reached by a single IPv6 hop, whereas a loose address may contain one or more other hops in between. The IPv6 Destination IP Address field in the base header is modified to contain the next waypoint address as the datagram is forwarded."><img alt="The now-deprecated Routing header type 0 (RH0) generalizes the IPv4 loose and strict Source Route and Record Route options. It is constructed by the sender to include IPv6 node addresses that act as waypoints when the datagram is forwarded. Each address can be specified as a loose or strict address. A strict address must be reached by a single IPv6 hop, whereas a loose address may contain one or more other hops in between. The IPv6 Destination IP Address field in the base header is modified to contain the next waypoint address as the datagram is forwarded." src="../figure_5-8_600.png" /></a></p>
<p>The IPv6 Routing header shown below generalizes the loose Source and Record Route options from IPv4. RH0 allows the sender to specify a vector of IPv6 addresses for nodes to be visited. [p200-201]</p>
<ul>
<li>The header contains an 8-bit <strong>Routing Type</strong> identifier and an 8-bit <strong>Segments Left</strong> field.<ul>
<li>The Routing Type identifier for IPv6 addresses is 0 for RH0 and 2 for RH2.</li>
<li>The Segments Left field indicates how many route segments remain to be processed. (The number of explicitly listed intermediate nodes still to be visited before reaching the final destination.) [p201]</li>
</ul>
</li>
</ul>
<p>A Routing header is not processed until it reaches the node whose address is contained in the <strong>Destination IP Address</strong> field of the IPv6 header. At this time, the Segments Left field is used to determine the next hop address from the address vector, and this address is swapped with the Destination IP Address field in the IPv6 header. Thus, as the datagram is forwarded, the Segments Left field grows smaller, and the list of addresses in the header reflects the node addresses that forwarded the datagram.</p>
<p>The forwarding procedure is shown in the below figure:</p>
<p><a href="../figure_5-9.png" title="Using an IPv6 Routing header (RH0), the sender (S) is able to direct the datagram through the intermediate nodes R2 and R3 . The other nodes traversed are determined by the normal IPv6 routing. Note that the destination address in the IPv6 header is updated at each hop specified in the Routing header."><img alt="Using an IPv6 Routing header (RH0), the sender (S) is able to direct the datagram through the intermediate nodes R2 and R3 . The other nodes traversed are determined by the normal IPv6 routing. Note that the destination address in the IPv6 header is updated at each hop specified in the Routing header." src="../figure_5-9_600.png" /></a></p>
<ol>
<li>The sender (S) constructs the datagram with destination address R1 and a Routing header (type 0) containing the addresses R2, R3, and D. The final destination of the datagram is the last address in the list (D). The Segments Left field (labeled "Left") starts at 3.</li>
<li>The datagram is forwarded toward R1 automatically by S and R0 . Because R0's address is not present in the datagram, no modifications of the Routing header or addresses are performed by R0 .</li>
<li>Upon reaching R1, the destination address from the base header is swapped with the first address listed in the Routing header and the Segments Left field is decremented.</li>
<li>As the datagram is forwarded, the process of swapping the destination address with the next address from the address list in the Routing header repeats until the last destination listed in the Routing header is reached.</li>
</ol>
<p>RH0 has been deprecated by [RFC5095] because of a security concern that allows RH0 to be used to increase the effectiveness of DoS attacks. <u>The problem is that RH0 allows the same address to be specified in multiple locations within the Routing header. This can lead to traffic being forwarded many times between two or more hosts or routers along a particular path.</u> The potentially high traffic loads that can be created along particular paths in the network can cause disruption to other traffic flows competing for bandwidth across the same path. Consequently, RH0 has been deprecated and only RH2 remains as the sole Routing header supported by IPv6. RH2 is equivalent to RH0 except it has room for only a single address and uses a different value in the <strong>Routing Type</strong> field.</p>
<h4 id="fragment-header">Fragment Header</h4>
<p>The Fragment header is used by an IPv6 source when sending a datagram larger than the path MTU of the datagram’s intended destination. (Path MTU and how it is determined are detailed in <a href="../ch13/">Chapter 13</a>). 1280 bytes is a network-wide link-layer minimum MTU for IPv6 [RFC2460].</p>
<ul>
<li>In IPv4, any host or router can fragment a datagram if it is too large for the MTU on the next hop, and fields within the second 32-bit word of the IPv4 header indicate the fragmentation information.</li>
<li>In IPv6, only the sender of the datagram is permitted to perform fragmentation, and in such cases a Fragment header is added.</li>
</ul>
<p>The Fragment header includes the same information as is found in the IPv4 header, but the Identification field is 32 bits instead of the 16 that are used for IPv4. The larger field provides the ability for more fragmented packets to be outstanding in the network simultaneously. The Fragment header uses the format shown in the figure below:</p>
<p><a href="../figure_5-11.png" title="The IPv6 Fragment header contains a 32-bit Identification field (twice as large as the Identification field in IPv4). The M bit field indicates whether the fragment is the last of an original datagram. As with IPv4, the Fragment Offset field gives the offset of the payload into the original datagram in 8-byte units."><img alt="The IPv6 Fragment header contains a 32-bit Identification field (twice as large as the Identification field in IPv4). The M bit field indicates whether the fragment is the last of an original datagram. As with IPv4, the Fragment Offset field gives the offset of the payload into the original datagram in 8-byte units." src="../figure_5-11_600.png" /></a></p>
<ul>
<li>The <strong>Reserved</strong> field and 2-bit Res field are both zero and ignored by receivers.</li>
<li>The <strong>Fragment Offset</strong> field indicates where the data that follows the Fragment header is located, as a positive offset in 8-byte units, relative to the "fragmentable part" of the original IPv6 datagram.</li>
</ul>
<p>The datagram serving as input to the fragmentation process is called the "original packet" and consists of two parts: the "unfragmentable part" and the "fragmentable part":</p>
<ul>
<li>The <strong>unfragmentable part</strong> includes the IPv6 header and any included extension headers required to be processed by intermediate nodes to the destination, which includes:<ul>
<li>All headers up to and including the Routing header, or,</li>
<li>the Hop-by-Hop Options extension header if only it is present.</li>
</ul>
</li>
<li>The <strong>fragmentable part</strong> constitutes the remainder of the datagram, which includes:<ul>
<li>Destination Options header</li>
<li>Upper-layer headers</li>
<li>Payload data)</li>
</ul>
</li>
</ul>
<p>When the original packet is fragmented, multiple fragment packets are produced, each of which contains a copy of the unfragmentable part of the original packet followed by the Fragment header. In each fragmented IPv6 packet:</p>
<ul>
<li>The IPv6 header has the <strong>Payload Length</strong> field altered to reflect the size of the fragment packet it describes.</li>
<li>Following the unfragmentable part, each new fragment packet contains a Fragment header with the following fields:<ul>
<li>An appropriately assigned <strong>Fragment Offset</strong> field (the first fragment contains offset 0)</li>
<li>A copy of the original packet’s <strong>Identification</strong> field.</li>
<li>The last fragment has its <strong>M</strong> (<em>More Fragments</em>) bit field set to 0.</li>
</ul>
</li>
</ul>
<p>The following example illustrates the way an IPv6 source might fragment a datagram:</p>
<p><a href="../figure_5-12.png" title=" An example of IPv6 fragmentation where a 3960-byte payload is split into three fragment packets of size 1448 bytes or less. Each fragment contains a Fragment header with the identical Identification field. All but the last fragment have the More Fragments field (M) set to 1. The offset is given in 8-byte units—the last fragment, for example, contains data beginning at offset (362 * 8) = 2896 bytes from the beginning of the original packet’s data. The scheme is similar to fragmentation in IPv4."><img alt=" An example of IPv6 fragmentation where a 3960-byte payload is split into three fragment packets of size 1448 bytes or less. Each fragment contains a Fragment header with the identical Identification field. All but the last fragment have the More Fragments field (M) set to 1. The offset is given in 8-byte units—the last fragment, for example, contains data beginning at offset (362 * 8) = 2896 bytes from the beginning of the original packet’s data. The scheme is similar to fragmentation in IPv4." src="../figure_5-12_600.png" /></a></p>
<p>In the figure above, a payload of 3960 bytes is fragmented such that no fragment’s total packet size exceeds 1500 bytes (a typical MTU for Ethernet), yet the <u>fragment data sizes still are arranged to be multiples of 8 bytes.</u> [p204-205]</p>
<ul>
<li>A 3960-byte payload is split into three fragment packets of size 1448 bytes or less.</li>
<li>The Fragment header in each fragment contains a common Identification field</li>
<li>All but the last fragment have the More Fragments field (M) set to 1. The offset is given in 8-byte units—the last fragment, for example, contains data beginning at offset (362 * 8) = 2896 bytes from the beginning of the original packet’s data. The scheme is similar to fragmentation in IPv4.</li>
<li>The IPv6 header’s Payload Length field is modified to reflect the size of the data and newly formed Fragment header.</li>
</ul>
<p>The receiver must ensure that all fragments of an original datagram have been received before performing reassembly. As with fragmentation in IPv4 (<a href="../ch10/">Chapter 10</a>), fragments may arrive out of order at the receiver but are reassembled in order to form a datagram that is given to other protocols for processing.</p>
<p>[p205-208]</p>
<p>(Wireshark example skipped)</p>
<h3 id="ip-forwarding">IP Forwarding</h3>
<p>IP forwarding is simple, especially for a host:</p>
<ul>
<li>If the destination is directly connected to the host (e.g., a point-to-point link) or on a shared network (e.g., Ethernet), the IP datagram is sent directly to the destination; a router is not required or used.</li>
<li>Otherwise, the host sends the datagram to a single router (called the <em>default</em> router) and lets the router deliver the datagram to its destination.</li>
</ul>
<p>A host differs from a router in how IP datagrams are handled: a host never forwards datagrams it does not originate, whereas routers do.</p>
<p>The IP protocol can receive a datagram from either of the following:</p>
<ul>
<li>Another protocol on the same machine (TCP, UDP, etc.),</li>
<li>A network interface.</li>
</ul>
<p>The IP layer has some information in memory, called a <strong>routing table</strong> or <strong>forwarding table</strong>, which it searches each time it receives a datagram to send.</p>
<p>When a datagram is received from a network interface, IP first checks if the destination IP address is one of its own IP addresses (one of the IP addresses associated with one of its network interfaces) or some other address for which it should receive traffic such as an IP broadcast or multicast address:</p>
<ul>
<li>If so, the datagram is delivered to the protocol module specified by the <strong>Protocol</strong> field in the IPv4 header or <strong>Next Header</strong> field in the IPv6 header.</li>
<li>If the datagram is not destined for one of the IP addresses being used locally by the IP module, then:<ul>
<li>If the IP layer was configured to act as a router, the datagram is forwarded (that is, handled as an outgoing datagram as described in <a href="#ip-forwarding-actions">Section 5.4.2</a>); or,</li>
<li>The datagram is silently discarded. Under some circumstances (e.g., no route is known in case 1), an ICMP message may be sent back to the source indicating an error condition.</li>
</ul>
</li>
</ul>
<h4 id="forwarding-table">Forwarding Table</h4>
<p>The data in a forwarding table is up to the implementation, though several key pieces of information are generally required to implement the forwarding table for IP. Each entry in the routing or forwarding table contains (at least conceptually) the following information fields:</p>
<ul>
<li><strong>Destination</strong>: This contains a 32-bit field (or 128-bit field for IPv6) used for matching the result of a masking operation. The destination can be:<ul>
<li>Zero, for a "default route" covering all destinations, or,</li>
<li>Full length of an IP address, for a "host route" that describes only a single destination.</li>
</ul>
</li>
<li><strong>Mask</strong>: This contains a 32-bit field (or 128-bit field for IPv6) applied as a bitwise AND mask to the destination IP address of a datagram being looked up in the forwarding table. The masked result is compared with the set of destinations in the forwarding table entries.</li>
<li><strong>Next-hop</strong>: This contains the 32-bit IPv4 address or 128-bit IPv6 address of the next IP entity (router or host) to which the datagram should be sent. The next-hop entity is typically on a network shared with the system performing the forwarding lookup, meaning the two share the same network prefix.</li>
<li><strong>Interface</strong>: This contains an identifier used by the IP layer to reference the network interface that should be used to send the datagram to its next hop. For example, it could refer to a host’s 802.11 wireless interface, a wired Ethernet interface, or a PPP interface associated with a serial port. If the forwarding system is also the sender of the IP datagram, this field is used in selecting which source IP address to use on the outgoing datagram (see <a href="../the-source-address-selection-algorithm">Section 5.6.2.1</a>).</li>
</ul>
<p>IP forwarding is performed on a <em>hop-by-hop</em> basis. The routers and hosts do not contain the complete forwarding path to any destination, except those destinations that are directly connected to the host or router. IP forwarding provides the IP address of only the next-hop entity to which the datagram is sent. The following assumption are made:</p>
<ul>
<li>The next hop is really "closer" to the destination than the forwarding system is, and that the next-hop router is directly connected to (shares a common network prefix with) the forwarding system.</li>
<li>No "loops" are constructed between the next hops so that a datagram does not circulate around the network until its TTL or hop limit expires.</li>
</ul>
<p>The job of ensuring correctness of the routing table is given to one or more routing protocols. Many different routing protocols are available to do this job, including <a href="https://en.wikipedia.org/wiki/Routing_Information_Protocol">RIP</a>, <a href="https://en.wikipedia.org/wiki/Open_Shortest_Path_First">OSPF</a>, <a href="https://en.wikipedia.org/wiki/Border_Gateway_Protocol">BGP</a>, and <a href="https://en.wikipedia.org/wiki/IS-IS">IS-IS</a>.</p>
<h4 id="ip-forwarding-actions">IP Forwarding Actions</h4>
<p>When the IP layer in a host or router needs to send an IP datagram to a next-hop router or host, it first examines the destination IP address (<em>D</em>) in the datagram  Using the value <em>D</em>, the following <strong>longest prefix match</strong> algorithm is executed on the forwarding table:</p>
<ol>
<li>
<p>Search the table for all entries (masking and comparing) for which the following property holds:</p>
<p>(<em>D</em> &amp; <em>m</em><sub>j</sub>) = <em>d</em><sub>j</sub></p>
<p>Where:</p>
<ul>
<li><em>m</em><sub>j</sub> is the value of the mask field associated with the forwarding entry <em>e</em><sub>j</sub> having index j</li>
<li><em>d</em><sub>j</sub> is the value of the destination field associated with <em>e</em><sub>j</sub>.</li>
</ul>
<p>This means that the destination IP address <em>D</em> is bitwise ANDed with the mask in each forwarding table entry (<em>m</em><sub>j</sub>), and the result is compared against the destination in the same forwarding table entry (<em>d</em><sub>j</sub>). If the property holds, the entry (<em>e</em><sub>j</sub> here) is a "match" for the destination IP address. When a match happens, the algorithm notes the entry index (<em>j</em> here) and how many bits in the mask <em>m</em><sub>j</sub> were 1. The more bits are 1, the "better" the match.</p>
</li>
<li>
<p>The best matching entry <em>e</em><sub>k</sub> (the one with the largest number of 1 bits in its mask <em>m</em><sub>j</sub>) is selected, and its next-hop field <em>nm</em><sub>k</sub> is used as the next-hop IP address in forwarding the datagram.</p>
</li>
</ol>
<p>If no matches in the forwarding table are found, the datagram is undeliverable:</p>
<ul>
<li>If on a host (the undeliverable datagram was generated locally), a "host unreachable" error is normally returned to the application that generated the datagram.</li>
<li>If on a router, an ICMP message is normally sent back to the host that sent the datagram.</li>
</ul>
<p>In some circumstances, more than one entry may match an equal number of 1 bits: for example, when more than one default route is available (e.g., when attached to more than one ISP, called <a href="https://en.wikipedia.org/wiki/Multihoming">multihoming</a>). A common behavior is for the system to simply choose the first match. More sophisticated systems may attempt to load-balance or split traffic across the multiple routes. Studies suggest that multihoming can be beneficial not only for large enterprises, but also for residential users. [p210]</p>
<h4 id="examples-of-ip-forwarding">Examples of IP Forwarding</h4>
<p>There are two cases of IP forwarding:</p>
<ul>
<li><strong>Direct delivery</strong>: all systems are using the same network prefix.</li>
<li><strong>Indirect delivery</strong> (<a href="../figure_5-16.png">Figure 5-16</a>).</li>
</ul>
<h5 id="direct-delivery"><strong>Direct Delivery</strong></h5>
<p>Host S (with IPv4 address S and MAC address <u>S</u>) has an IP datagram to send to Host D (IPv4 address D, MAC address <u>D</u>). Both hosts are on the same Ethernet (<a href="../front_cover.jpg">front cover</a>) and are interconnected using a switch. [p210]</p>
<p>The top part of the following figure shows the delivery of the datagram and the forwarding table on S to contain the information as shown in the following table:</p>
<p><a href="../figure_5-16.png" title="Direct delivery does not require the presence of a router—IP datagrams are encapsulated in a link-layer frame that directly identifies the source and destination. Indirect delivery involves a router—data is forwarded to the router using the router’s link-layer address as the destination link-layer address. The router’s IP address does not appear in the IP datagram (unless the router itself is the source or destination, or when source routing is used)."><img alt="Direct delivery does not require the presence of a router—IP datagrams are encapsulated in a link-layer frame that directly identifies the source and destination. Indirect delivery involves a router—data is forwarded to the router using the router’s link-layer address as the destination link-layer address. The router’s IP address does not appear in the IP datagram (unless the router itself is the source or destination, or when source routing is used)." src="../figure_5-16_600.png" /></a></p>
<table>
<thead>
<tr>
<th>Destination</th>
<th>Mask</th>
<th>Gateway (Next Hop)</th>
<th>Interface</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.0.0.0</td>
<td>0.0.0.0</td>
<td>10.0.0.1</td>
<td>10.0.0.100</td>
</tr>
<tr>
<td>10.0.0.0</td>
<td>255.255.255.128</td>
<td>10.0.0.100</td>
<td>10.0.0.100</td>
</tr>
</tbody>
</table>
<p><small>
The (unicast) IPv4 forwarding table at host S contains only two entries. Host S is configured with IPv4 address and subnet mask 10.0.0.100/25. Datagrams destined for addresses in the range 10.0.0.1 through 10.0.0.126 use the second forwarding table entry and are sent using direct delivery. All other datagrams use the first entry and are given to router R with IPv4 address 10.0.0.1.
</small></p>
<p>Direct delivery does not require the presence of a router: IP datagrams are encapsulated in a link-layer frame that directly identifies the source and destination. In the above forwarding table, the destination IPv4 address D (10.0.0.9) matches both the first and second forwarding table entries. Because it matches the second entry better (25 bits instead of none), the "gateway" or next-hop address is 10.0.0.100, the address S. Thus, <u>the gateway portion of the entry contains the address of the sending host’s own network interface (no router is referenced), indicating that direct delivery is to be used to send the datagram.</u></p>
<p>The datagram is encapsulated in a lower-layer frame destined for the target host D. If the lower-layer address of the target host is unknown, the ARP protocol (for IPv4; <a href="../ch4/">Chapter 4</a>) or Neighbor Solicitation (for IPv6; <a href="ch8.md">Chapter 8</a>) operation may be invoked at this point to determine the correct lower-layer address, <u>D</u>. Once known, the destination address in the datagram is D’s IPv4 address (10.0.0.9), and <u>D</u> is placed in the <strong>Destination IP Address</strong> field in the lower-layer header. The switch delivers the frame to D based solely on the link-layer address <u>D</u>; it pays no attention to the IP addresses.</p>
<h5 id="indirect-delivery"><strong>Indirect Delivery</strong></h5>
<p>Host S has an IP datagram to send to the Host D (<code>ftp.uu.net</code>), whose IPv4 address is 192.48.96.9. The bottom part of the <a href="../figure_5-16.png">Figure 5-16</a> shows the conceptual path of the datagram through four routers. Host S searches its forwarding table but does not find a matching prefix on the local network. It uses its default route entry (which matches every destination, but with no 1 bits at all).</p>
<p>The IP addresses correspond to the source and destination hosts, but the lower-layer addresses do not. The lower-layer addresses determine which machines receive the frame containing the datagram on a per-hop basis.</p>
<p>In this example:</p>
<ul>
<li>The lower-layer address needs the Ethernet address of the next-hop router R1’s a-side interface (the lower-layer address corresponding to IPv4 address 10.0.0.1). This is accomplished by ARP (or a Neighbor Solicitation request for IPv6) on the network interconnecting S and R1.</li>
<li>Once R1 responds with its a-side lower-layer address, S sends the datagram to R1. Delivery from S to R1 takes place based on processing only the lower-layer headers (the lower-layer destination address).</li>
<li>Upon receipt of the datagram, R1 checks its forwarding table.</li>
</ul>
<p>The following table is the forwarding table of R1:</p>
<table>
<thead>
<tr>
<th>Destination</th>
<th>Mask</th>
<th>Gateway (Next Hop)</th>
<th>Interface</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.0.0.0</td>
<td>0.0.0.0</td>
<td>70.231.159.254</td>
<td>70.231.132.85</td>
<td>NAT</td>
</tr>
<tr>
<td>10.0.0.0</td>
<td>255.255.255.128</td>
<td>10.0.0.100</td>
<td>10.0.0.1</td>
<td>NAT</td>
</tr>
</tbody>
</table>
<p><small>
The forwarding table at R1 indicates that address translation should be performed for traffic. The router has a private address on one side (10.0.0.1) and a public address on the other (70.231.132.85). Address translation is used to make datagrams originating on the 10.0.0.0/25 network appear to the Internet as though they had been sent from 70.231.132.85.
</small></p>
<ul>
<li>When R1 receives the datagram, it realizes that the datagram’s destination IP address is not one of its own, so it forwards the datagram. Its forwarding table is searched and the default entry is used. The default entry in this case has a next hop within the ISP servicing the network, 70.231.159.254 (this is R2’s a-side interface).</li>
<li>Because this router is in the global Internet and the source address of Host S is the private address 10.0.0.100, R1 performs <a href="https://en.wikipedia.org/wiki/Network_address_translation">Network Address Translation</a> (NAT) on the datagram to make it routable on the Internet. The NAT operation results in the datagram having the new source address 70.231.132.85, which corresponds to R1’s b-side interface.</li>
<li>When router R2 (inside the ISP) receives the datagram, it goes through the same steps that the local router R1 did (except for the NAT operation). If the datagram is not destined for one of its own IP addresses, the datagram is forwarded.</li>
</ul>
<p>IPv6 uses a slightly different mechanism (Neighbor Solicitation messages) from IPv4 (which uses ARP) to ascertain the lower-layer address of its next hop (<a href="ch8.md">Chapter 8</a>). In addition, IPv6 has both link-local addresses and global addresses (<a href="../ch2/">Chapter 2</a>). While global addresses behave like regular IP addresses, link-local addresses can be used only on the same link. In addition, because all the link-local addresses share the same IPv6 prefix (fe80::/10), a multihomed host may require user to determine which interface to use when sending a datagram destined for a link-local destination.</p>
<p>[p213-214]</p>
<p>To see the path taken to an IP destination, we can use the <a href="https://en.wikipedia.org/wiki/Traceroute"><code>traceroute</code></a> program:</p>
<div class="codehilite"><pre>Linux% traceroute -n ftp.uu.net
traceroute to ftp.uu.net (192.48.96.9), 30 hops max, 38 byte packets
 1 70.231.159.254 9.285 ms 8.404 ms 8.887 ms
 2 206.171.134.131 8.412 ms 8.764 ms 8.661 ms
 3 216.102.176.226 8.502 ms 8.995 ms 8.644 ms
 4 151.164.190.185 8.705 ms 8.673 ms 9.014 ms
 5 151.164.92.181 9.149 ms 9.057 ms 9.537 ms
 6 151.164.240.134 9.680 ms 10.389 ms 11.003 ms
 7 151.164.41.10 11.605 ms 37.699 ms 11.374 ms
 8 12.122.79.97 13.449 ms 12.804 ms 13.126 ms
 9 12.122.85.134 15.114 ms 15.020 ms 13.654 ms
 MPLS Label=32307 CoS=5 TTL=1 S=0
10 12.123.12.18 16.011 ms 13.555 ms 13.167 ms
11 192.205.33.198 15.594 ms 15.497 ms 16.093 ms
12 152.63.57.102 15.103 ms 14.769 ms 15.128 ms
13 152.63.34.133 77.501 ms 77.593 ms 76.974 ms
14 152.63.38.1 77.906 ms 78.101 ms 78.398 ms
15 207.18.173.162 81.146 ms 81.281 ms 80.918 ms
16 198.5.240.36 77.988 ms 78.007 ms 77.947 ms
17 198.5.241.101 81.912 ms 82.231 ms 83.115 ms
</pre></div>


<p>This program lists each of the IP hops traversed while sending a series of datagrams to the destination <code>ftp.uu.net</code> (192.48.96.9). The <code>traceroute</code> program uses a combination of UDP datagrams (with increasing TTL over time) and ICMP messages (used to detect each hop when the UDP datagrams expire) to accomplish its task. Three UDP packets are sent at each TTL value, providing three roundtrip-time measurements to each hop. The following line indicates that <a href="https://en.wikipedia.org/wiki/Multiprotocol_Label_Switching">Multiprotocol Label Switching</a> (MPLS) [RFC3031] is being used.</p>
<div class="codehilite"><pre>MPLS Label=32307 CoS=5 TTL=1 S=0
</pre></div>


<p>MPLS is a form of link-layer network capable of carrying multiple network-layer protocols. Many network operators use it for traffic engineering purposes (controlling where network traffic flows through their networks). [p215]</p>
<h4 id="discussion-ip-forwarding">Discussion (IP Forwarding)</h4>
<p>Key points regarding the operation of IP unicast forwarding:</p>
<ol>
<li>Most of the hosts and routers in this example used a default route consisting of a single forwarding table entry of this form: mask 0, destination 0, next hop &lt;some IP address&gt;. Indeed, most hosts and most routers at the edge of the Internet can use a default route for everything other than destinations on local networks because there is only one interface available that provides connectivity to the rest of the Internet.</li>
<li>The source and destination IP addresses in the datagram never change once in the regular Internet. This is always the case unless either source routing is used, or when other functions (such as NAT, as in the example) are encountered along the data path. Forwarding decisions at the IP layer are based on the destination address.</li>
<li>A different lower-layer header is used on each link that uses addressing, and the lower-layer destination address (if present) always contains the lower-layer address of the next hop. Therefore, lower-layer headers routinely change as the datagram is moved along each hop toward its destination.  In our example, both Ethernet LANs encapsulated a link-layer header containing the next hop’s Ethernet address, but the DSL link did not. Lower-layer addresses are normally obtained using ARP (see Chap</li>
</ol>
<h3 id="mobile-ip">Mobile IP</h3>
<p>(skipped)</p>
<p>[p215-220]</p>
<h3 id="host-processing-of-ip-datagrams">Host Processing of IP Datagrams</h3>
<h4 id="host-models">Host Models</h4>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>