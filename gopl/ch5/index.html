<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/gopl/ch5/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 5. Functions - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../lkd/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch5/">Chapter 5. System Calls</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch7/">Chapter 7. Interrupts and Interrupt Handlers</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch8/">Chapter 8. Bottom Halves and Deferring Work</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch9/">Chapter 9. An Introduction to Kernel Synchronization</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch10/">Chapter 10. Kernel Synchronization Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch11/">Chapter 11. Timers and Time Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch12/">Chapter 12. Memory Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch13/">Chapter 13. The Virtual Filesystem</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch14/">Chapter 14. The Block I/O Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch15/">Chapter 15. The Process Address Space</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch16/">Chapter 16. The Page Cache and Page Writeback</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li class="active">
                            <a href="./">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/gopl/ch5.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-5-functions">Chapter 5. Functions</a></li>
        
    
        <li class="main "><a href="#function-declarations">Function Declarations</a></li>
        
    
        <li class="main "><a href="#recursion">Recursion</a></li>
        
            <li><a href="#variable-size-stacks-in-go">Variable-size stacks in Go *</a></li>
        
    
        <li class="main "><a href="#multiple-return-values">Multiple Return Values</a></li>
        
            <li><a href="#bare-return">Bare return *</a></li>
        
    
        <li class="main "><a href="#errors">Errors</a></li>
        
            <li><a href="#why-go-uses-control-flow-mechanisms-for-error-handling">Why Go uses control-flow mechanisms for error handling *</a></li>
        
            <li><a href="#error-handling-strategies">Error-Handling Strategies</a></li>
        
            <li><a href="#end-of-file-eof">End of File (EOF)</a></li>
        
    
        <li class="main "><a href="#function-values">Function Values</a></li>
        
    
        <li class="main "><a href="#anonymous-functions">Anonymous Functions</a></li>
        
            <li><a href="#caveat-capturing-iteration-variables">Caveat: Capturing Iteration Variables</a></li>
        
    
        <li class="main "><a href="#variadic-functions">Variadic Functions</a></li>
        
    
        <li class="main "><a href="#deferred-function-calls">Deferred Function Calls</a></li>
        
            <li><a href="#on-entry-and-on-exit-actions">On-entry and on-exit actions *</a></li>
        
            <li><a href="#accessing-result-variables">Accessing result variables *</a></li>
        
            <li><a href="#caveats-of-deferred-functions">Caveats of deferred functions *</a></li>
        
    
        <li class="main "><a href="#panic">Panic</a></li>
        
            <li><a href="#panic-vs-error-values">Panic vs. error values *</a></li>
        
            <li><a href="#panic-and-deferred-functions">Panic and deferred functions *</a></li>
        
    
        <li class="main "><a href="#recover">Recover</a></li>
        
    
        <li class="main "><a href="#doubts-and-solution">Doubts and Solution</a></li>
        
            <li><a href="#verbatim">Verbatim</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-5-functions"><strong>Chapter 5. Functions</strong></h3>
<p>Functions are a critical part of any programming language. [p119]</p>
<h3 id="function-declarations">Function Declarations</h3>
<p>A function declaration has a name, a list of parameters, an optional list of results, and a body:</p>
<pre>
func <i>name</i>(<i>parameter-list</i>) (<i>result-list</i>) {
    <i>body</i>
}
</pre>

<ul>
<li>The parameter list specifies the names and types of the function's <a href="https://en.wikipedia.org/wiki/Parameter_(computer_programming)"><em>parameters</em></a>, which are local variables whose values (<em>arguments</em>) are supplied by the caller.</li>
<li>The result list specifies the types of the values that the function returns.<ul>
<li><u>If the function returns one unnamed result or no results, parentheses are optional and usually omitted.</u></li>
<li>Leaving off the result list entirely declares a function that does not return any value.</li>
</ul>
</li>
</ul>
<p>For example, in the <code>hypot</code> function below:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">hypot</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nx">x</span><span class="o">*</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="o">*</span><span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">hypot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">// &quot;5&quot;</span>
</pre></div>


<ul>
<li><code>x</code> and <code>y</code> are parameters in the declaration.</li>
<li><code>3</code> and <code>4</code> are arguments of the call.</li>
<li>The function returns a <code>float64</code> value.</li>
</ul>
<p>Results may be named, in which case each name declares a local variable initialized to the zero value for its type.</p>
<p>A function that has a result list must end with a <code>return</code> statement unless execution clearly cannot reach the end of the function, the possible cases being:</p>
<ul>
<li>The function ends with a call to <a href="https://golang.org/pkg/builtin/#panic"><code>panic</code></a></li>
<li>Infinite <code>for</code> loop with no <code>break</code></li>
</ul>
<p>A sequence of parameters or results of the same type can be factored so that the type itself is written only once. These two declarations are equivalent:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">f</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">string</span><span class="p">)</span>                <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">f</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</pre></div>


<p>Below are four ways to declare a function with two parameters and one result, all of type <code>int</code>.  The blank identifier can be used to emphasize that a parameter is unused.</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>   <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">sub</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">z</span> <span class="kt">int</span><span class="p">)</span>   <span class="p">{</span> <span class="nx">z</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">-</span> <span class="nx">y</span><span class="p">;</span> <span class="k">return</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">first</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">zero</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>      <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">add</span><span class="p">)</span>   <span class="c1">// &quot;func(int, int) int&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">sub</span><span class="p">)</span>   <span class="c1">// &quot;func(int, int) int&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">first</span><span class="p">)</span> <span class="c1">// &quot;func(int, int) int&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">zero</span><span class="p">)</span>  <span class="c1">// &quot;func(int, int) int&quot;</span>
</pre></div>


<p>The type of a function is sometimes called its <a href="https://en.wikipedia.org/wiki/Type_signature"><em>signature</em></a>. Two functions have the same type or signature if they have the same sequence of parameter types and the same sequence of result types. The following don't affect the type:</p>
<ul>
<li>The names of parameters and results</li>
<li>Whether or not they were declared using the factored form</li>
</ul>
<p>Every function call must provide an argument for each parameter, in the order in which the parameters were declared.</p>
<p>Go does not have the concept of the following:</p>
<ul>
<li>Default parameter values</li>
<li>Any way to specify arguments by name</li>
</ul>
<p>The names of parameters and results don't matter to the caller except as documentation.</p>
<p>Parameters are local variables within the body of the function, with their initial values set to the arguments supplied by the caller. Function parameters and named results are variables in the same lexical block as the functions' outermost local variables.</p>
<p>Arguments are passed <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value"><em>by value</em></a>: the function receives a copy of each argument; modifications to the copy do not affect the caller. However, if the argument contains some kind of reference, like a pointer, slice, map, function, or channel, then the caller may be affected by any modifications the function makes to variables <em>indirectly</em> referred to by the argument.</p>
<p>You may occasionally encounter a function declaration without a body, indicating that the function is implemented in a language other than Go. Such a declaration defines the function signature.</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">math</span>

<span class="kd">func</span> <span class="nx">Sin</span><span class="p">(</span><span class="nx">x</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="c1">// implemented in assembly language</span>
</pre></div>


<h3 id="recursion">Recursion</h3>
<p>Functions may be recursive, which means they may call themselves, either directly or indirectly.</p>
<p>The example program below uses a non-standard package, <a href="https://godoc.org/golang.org/x/net/html"><code>golang.org/x/net/html</code></a>, which provides an HTML parser. The <code>golang.org/x/...</code> repositories hold packages designed and maintained by the Go team for applications such as networking, internationalized text processing, mobile platforms, image manipulation, cryptography, and developer tools. These packages are not in the standard library because they're still under development or rarely needed by the majority of Go programmers.</p>
<p>The parts of the <code>golang.org/x/net/html</code> API are shown below.</p>
<ul>
<li>The function <a href="https://godoc.org/golang.org/x/net/html#Parse"><code>html.Parse</code></a> reads a sequence of bytes, parses them, and returns the root of the HTML document tree, which is an <a href="https://godoc.org/golang.org/x/net/html#Node"><code>html.Node</code></a>.</li>
<li>HTML has several kinds of nodes. We are concerned only with <em>element</em> nodes of the form <code>&lt;name key='value'&gt;</code>.</li>
</ul>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">html</span>

<span class="kd">type</span> <span class="nx">Node</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Type</span> <span class="nx">NodeType</span>
    <span class="nx">Data</span> <span class="kt">string</span>
    <span class="nx">Attr</span> <span class="p">[]</span><span class="nx">Attribute</span>
    <span class="nx">FirstChild</span><span class="p">,</span> <span class="nx">NextSibling</span> <span class="o">*</span><span class="nx">Node</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">NodeType</span> <span class="kt">int32</span>

<span class="kd">const</span> <span class="p">(</span>
    <span class="nx">ErrorNode</span> <span class="nx">NodeType</span> <span class="p">=</span> <span class="kc">iota</span>
    <span class="nx">TextNode</span>
    <span class="nx">DocumentNode</span>
    <span class="nx">ElementNode</span>
    <span class="nx">CommentNode</span>
    <span class="nx">DoctypeNode</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Attribute</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Key</span><span class="p">,</span> <span class="nx">Val</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Parse</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</pre></div>


<p>The <code>main</code> function parses the standard input as HTML, extracts the links using a recursive <code>visit</code> function, and prints each discovered link:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch5/findlinks1/main.go">gopl.io/ch5/findlinks1/main.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// Findlinks1 prints the links in an HTML document read from standard input.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;os&quot;</span>
    <span class="s">&quot;golang.org/x/net/html&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;findlinks1: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">visit</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The <code>visit</code> function traverses an HTML node tree, extracts the link from the <code>href</code> attribute of each <em>anchor</em> element <code>&lt;a href='...'&gt;</code>, appends the links to a slice of strings, and returns the resulting slice:</p>
<div class="codehilite"><pre><span class="c1">// visit appends to links each link found in n and returns the result.</span>
<span class="kd">func</span> <span class="nx">visit</span><span class="p">(</span><span class="nx">links</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="s">&quot;a&quot;</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Key</span> <span class="o">==</span> <span class="s">&quot;href&quot;</span> <span class="p">{</span>
                <span class="nx">links</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">links</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
        <span class="nx">links</span> <span class="p">=</span> <span class="nx">visit</span><span class="p">(</span><span class="nx">links</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">links</span>
<span class="p">}</span>
</pre></div>


<p>[p123]</p>
<p>The next program uses recursion over the HTML node tree to print the structure of the tree in outline. As it encounters each element, it pushes the element's tag onto a stack, then prints the stack.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch5/outline/main.go">gopl.io/ch5/outline/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;outline: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">outline</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">doc</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">outline</span><span class="p">(</span><span class="nx">stack</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
        <span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span> <span class="c1">// push tag</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
        <span class="nx">outline</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Note that <code>outline</code> "pushes" an element on stack, but there is no corresponding pop. <u>When <code>outline</code> calls itself recursively, the callee receives a copy of stack.</u> Although the callee may append elements to this slice, modifying its underlying array and perhaps even allocating a new array, it doesn't modify the initial elements that are visible to the caller, so when the function returns, the caller's stack is as it was before the call.</p>
<p>The following is the outline of <code>https://golang.org</code>:</p>
<div class="codehilite"><pre>$ go build gopl.io/ch5/outline
$ ./fetch https://golang.org | ./outline
[html]
[html head]
[html head meta]
[html head title]
[html head link]
[html body]
[html body div]
[html body div]
[html body div div]
[html body div div form]
[html body div div form div]
[html body div div form div a]
...
</pre></div>


<h4 id="variable-size-stacks-in-go">Variable-size stacks in Go *</h4>
<p>Many programming language implementations use a fixed-size function call stack; sizes from 64KB to 2MB are typical. Fixed-size stacks impose a limit on the depth of recursion, so one must be careful to avoid a <a href="https://en.wikipedia.org/wiki/Stack_overflow">stack overflow</a> when traversing large data structures recursively; fixed-size stacks may even pose a security risk.</p>
<p>In contrast, <u>typical Go implementations use variable-size stacks that start small and grow as needed up to a limit on the order of a gigabyte, which lets us use recursion safely and without worrying about overflow.</u></p>
<h3 id="multiple-return-values">Multiple Return Values</h3>
<p>A function can return more than one result. Many examples of functions from standard packages return two values, the desired computational result and an error value or boolean that indicates whether the computation worked.</p>
<p>The program below is a variation of <code>findlinks</code> that makes the HTTP request itself. Because the HTTP and parsing operations can fail, <code>findLinks</code> declares two results: the list of discovered links and an error. The HTML parser can usually recover from bad input and construct a document containing error nodes, so <code>Parse</code> rarely fails; when it does, itâ€™s typically due to underlying I/O errors.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch5/findlinks2/main.go">gopl.io/ch5/findlinks2/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">url</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
        <span class="nx">links</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;findlinks2: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">links</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// findLinks performs an HTTP GET request for url, parses the</span>
<span class="c1">// response as HTML, and extracts and returns the links.</span>
<span class="kd">func</span> <span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">!=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="p">{</span>
        <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;getting %s: %s&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Status</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
    <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;parsing %s as HTML: %v&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">visit</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">doc</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>


<p>There are four return statements in <code>findLinks</code>, each of which returns a pair of values. The first three returns cause the function to pass the underlying errors from the <code>http</code> and <code>html</code> packages on to the caller.</p>
<ul>
<li>In the first case, the error is returned unchanged.</li>
<li>In the second and third, it is augmented with additional context information by <code>fmt.Errorf</code> (<a href="../ch7/#the-error-interface">Section 7.8</a>).</li>
<li>If <code>findLinks</code> is successful, the final return statement returns the slice of links, with no error.</li>
</ul>
<p>We must ensure that <code>resp.Body</code> is closed so that network resources are properly released even in case of error. <u>Go's garbage collector recycles unused memory, but you cannot assume it will release unused operating system resources like open files and network connections.</u> They should be closed explicitly.</p>
<p>The result of calling a multi-valued function is a tuple of values. The caller of such a function must explicitly assign the values to variables if any of them are to be used:</p>
<div class="codehilite"><pre><span class="nx">links</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
</pre></div>


<p>To ignore one of the values, assign it to the blank identifier:</p>
<div class="codehilite"><pre><span class="nx">links</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="c1">// errors ignored</span>
</pre></div>


<p>The result of a multi-valued call may itself be returned from a (multi-valued) calling function. For example, the following function behaves like <code>findLinks</code> but logs its argument:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">findLinksLog</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;findLinks %s&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p><u>A multi-valued call may appear as the sole argument when calling a function of multiple parameters.</u> Although rarely used in production code, this feature is sometimes convenient during debugging since it prints all the results of a call using a single statement. The two print statements below have the same effect.</p>
<div class="codehilite"><pre><span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span><span class="p">))</span>

<span class="nx">links</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
<span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">links</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</pre></div>


<p>Well-chosen names can document the significance of a function's results. Names are particularly valuable when a function returns multiple results of the same type. For example:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">Size</span><span class="p">(</span><span class="nx">rect</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Rectangle</span><span class="p">)</span> <span class="p">(</span><span class="nx">width</span><span class="p">,</span> <span class="nx">height</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="nx">Split</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">dir</span><span class="p">,</span> <span class="nx">file</span> <span class="kt">string</span><span class="p">)</span>
<span class="kd">func</span> <span class="nx">HourMinSec</span><span class="p">(</span><span class="nx">t</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">hour</span><span class="p">,</span> <span class="nx">minute</span><span class="p">,</span> <span class="nx">second</span> <span class="kt">int</span><span class="p">)</span>
</pre></div>


<p>However, it's not always necessary to name multiple results solely for documentation. For instance, <u>convention dictates that a final <code>bool</code> result indicates success;</u> an <a href="https://golang.org/pkg/builtin/#error"><code>error</code></a> result often needs no explanation.</p>
<h4 id="bare-return">Bare return *</h4>
<p>In a function with named results, the operands of a return statement may be omitted. This is called a <em>bare return</em>.</p>
<div class="codehilite"><pre><span class="c1">// CountWordsAndImages does an HTTP GET request for the HTML</span>
<span class="c1">// document url and returns the number of words and images in it.</span>
<span class="kd">func</span> <span class="nx">CountWordsAndImages</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">words</span><span class="p">,</span> <span class="nx">images</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
<span class="p">}</span>
    <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
    <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;parsing HTML: %s&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">words</span><span class="p">,</span> <span class="nx">images</span> <span class="p">=</span> <span class="nx">countWordsAndImages</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">countWordsAndImages</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">(</span><span class="nx">words</span><span class="p">,</span> <span class="nx">images</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</pre></div>


<p>A bare return is a shorthand way to return each of the named result variables in order: in the function above, each return statement is equivalent to.</p>
<div class="codehilite"><pre><span class="k">return</span> <span class="nx">words</span><span class="p">,</span> <span class="nx">images</span><span class="p">,</span> <span class="nx">err</span>
</pre></div>


<p>In such functions with many return statements and several results, bare returns can reduce code duplication, but they rarely make code easier to understand. For instance, it's not obvious that the two early returns are equivalent to return <code>0, 0, err</code> (because the result variables words and images are initialized to their zero values) and that the final return is equivalent to return <code>words, images, nil</code>. For this reason, bare returns should be sparingly used.</p>
<h3 id="errors">Errors</h3>
<p>Some functions always succeed. For example, <code>strings.Contains</code> and <code>strconv.FormatBool</code> have well-defined results for all possible argument values and cannot fail, except catastrophic and unpredictable scenarios like running out of memory. [p127]</p>
<p>Other functions always succeed so long as their preconditions are met. For example, the <a href="https://golang.org/pkg/time/#Date"><code>time.Date</code></a> function always constructs a <code>time.Time</code> from its components (year, month, etc.), unless the last argument (the time zone) is <code>nil</code>, in which case it panics. This panic is a sure sign of a bug in the calling code and should never happen in a well-written program.</p>
<p><u>For many other functions, even in a well-written program, success is not assured because it depends on factors beyond the programmers' control.</u> Any function that does I/O, for example, must confront the possibility of error, and only a naive programmer believes a simple read or write cannot fail. We most need to know why when the most reliable operations fail unexpectedly</p>
<p>Errors are thus an important part of a package's API or an applications' user interface, and failure is just one of several expected behaviors. This is the approach Go takes to <a href="http://blog.golang.org/error-handling-and-go">error handling</a>.</p>
<p>A function for which failure is an expected behavior returns an additional result, conventionally the last one. <u>If the failure has only one possible cause, the result is a boolean, usually called <code>ok</code></u>, as in the following example of a cache lookup that always succeeds unless there was no entry for that key:</p>
<div class="codehilite"><pre><span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">Lookup</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="c1">// ...cache[key] does not exist...</span>
<span class="p">}</span>
</pre></div>


<p>More often, and especially for I/O, the failure may have a variety of causes for which the caller will need an explanation. In such cases, the type of the additional result is <code>error</code>.</p>
<p>The built-in type <a href="https://golang.org/pkg/builtin/#error"><code>error</code></a> is an interface type (detailed in <a href="../ch7/">Chapter 7</a>. An error may be <code>nil</code> or non-<code>nil</code>; <code>nil</code> implies success and non-<code>nil</code> implies failure, and non-<code>nil</code> error has an error message string which can be obtained by calling its <code>Error</code> method or print by calling <code>fmt.Println(err)</code> or <code>fmt.Printf("%v", err)</code>.</p>
<p>Usually when a function returns a non-nil error, its other results are undefined and should be ignored. However, a few functions may return partial results in error cases. For example, if an error occurs while reading from a file, a call to <code>Read</code> returns the number of bytes it was able to read and an <code>error</code> value describing the problem. For correct behavior, some callers may need to process the incomplete data before handling the error, so it is important that such functions clearly document their results.</p>
<h4 id="why-go-uses-control-flow-mechanisms-for-error-handling">Why Go uses control-flow mechanisms for error handling *</h4>
<p>Go's approach differs from many other languages in which failures are reported using <em>exceptions</em>, not ordinary values. Although Go does have an exception mechanism of sorts, which is discussed in <a href="#panic">Section 5.9</a>, it is used only for reporting truly unexpected errors that indicate a bug, not the routine errors that a robust program should be built to expect.</p>
<p>The problem is that exceptions tend to entangle the description of an error with the control flow required to handle it, often leading to an undesirable outcome: routine errors are reported to the end user in the form of an incomprehensible stack trace, full of information about the structure of the program but lacking intelligible context about what went wrong.</p>
<p>By contrast, Go programs use ordinary control-flow mechanisms like <code>if</code> and <code>return</code> to respond to errors. This style undeniably demands that more attention be paid to error-handling logic, but that is precisely the point.</p>
<h4 id="error-handling-strategies">Error-Handling Strategies</h4>
<p>When a function call returns an error, it's the caller's responsibility to check it and take appropriate action. Depending on the situation, there may be a number of possibilities. This section discusses five of them.</p>
<h5 id="propagating-the-error"><strong>Propagating the error</strong> *</h5>
<p>The first and most common strategy is to propagate the error, so that a failure in a subroutine becomes a failure of the calling routine. In the <code>findLinks</code> function of <a href="#multiple-return-values">Section 5.3</a>, if the call to <code>http.Get</code> fails, <code>findLinks</code> returns the HTTP error to the caller immediately:</p>
<div class="codehilite"><pre><span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
</pre></div>


<p>In contrast, if the call to <code>html.Parse</code> fails, <code>findLinks</code> does not return the HTML parser's error directly because it lacks two crucial pieces of information:</p>
<ol>
<li>The error occurred in the parser</li>
<li>The URL of the document that was being parsed.</li>
</ol>
<p>In this case, <code>findLinks</code> constructs a new error message that includes both pieces of information as well as the underlying parse error:</p>
<div class="codehilite"><pre><span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
<span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;parsing %s as HTML: %v&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>The <code>fmt.Errorf</code> function formats an error message using <code>fmt.Sprintf</code> and returns a new <code>error</code> value. It is used to build descriptive errors by successively prefixing additional context information to the original error message. When the error is ultimately handled by the program's main function, it should provide a clear causal chain from the root problem to the overall failure, reminiscent of a NASA accident investigation:</p>
<div class="codehilite"><pre><span class="nx">genesis</span><span class="p">:</span> <span class="nx">crashed</span><span class="p">:</span> <span class="nx">no</span> <span class="nx">parachute</span><span class="p">:</span> <span class="nx">G</span><span class="o">-</span><span class="k">switch</span> <span class="nx">failed</span><span class="p">:</span> <span class="nx">bad</span> <span class="nx">relay</span> <span class="nx">orientation</span>
</pre></div>


<p><u>Because error messages are frequently chained together, message strings should not be capitalized and newlines should be avoided.</u> The resulting errors may be long, but they will be self-contained when found by tools like <code>grep</code>.</p>
<p>When designing error messages, remember the following:</p>
<ul>
<li>Be deliberate, so that each one is a meaningful description of the problem with sufficient and relevant detail.</li>
<li>Be consistent, so that errors returned by the same function or by a group of functions in the same package are similar in form and can be dealt with in the same way.</li>
</ul>
<p>For example, the <a href="https://golang.org/pkg/os/"><code>os</code></a> package guarantees that every error returned by a file operation, such as <code>os.Open</code> or the <code>Read</code>, <code>Write</code>, or <code>Close</code> methods of an open file, describes not just the nature of the failure (permission denied, no such directory, and so on) but also the name of the file, so the caller needn't include this information in the error message it constructs.</p>
<p>In general, the call <code>f(x)</code> is responsible for reporting the attempted operation <code>f</code> and the argument value <code>x</code> as they relate to the context of the error. The caller is responsible for adding further information that it has but the call <code>f(x)</code> does not, such as the URL in the call to <code>html.Parse</code> above.</p>
<h5 id="retrying-the-failed-operation"><strong>Retrying the failed operation</strong> *</h5>
<p>The second strategy is for errors that represent transient or unpredictable problems; in such cases, it may make sense to retry the failed operation, possibly with a delay between tries and with a limit on the number of attempts or the time spent trying before giving up entirely.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch5/wait/wait.go">gopl.io/ch5/wait/wait.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// WaitForServer attempts to contact the server of a URL.</span>
<span class="c1">// It tries for one minute using exponential back-off.</span>
<span class="c1">// It reports an error if all attempts fail.</span>
<span class="kd">func</span> <span class="nx">WaitForServer</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">timeout</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span>
    <span class="nx">deadline</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">Add</span><span class="p">(</span><span class="nx">timeout</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">tries</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">Before</span><span class="p">(</span><span class="nx">deadline</span><span class="p">);</span> <span class="nx">tries</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Head</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span> <span class="c1">// success</span>
        <span class="p">}</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;server not responding (%s); retrying...&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">&lt;&lt;</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">tries</span><span class="p">))</span> <span class="c1">// exponential back-off</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;server %s failed to respond after %s&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">timeout</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h5 id="printing-the-error-and-stopping-the-program"><strong>Printing the error and stopping the program</strong> *</h5>
<p>Third, if progress is impossible, the caller can print the error and stop the program gracefully,
but <u>this action should generally be reserved for the main package of a program.</u></p>
<p>Library functions should usually propagate errors to the caller, unless the error is a sign of an internal inconsistency, that is, a bug.</p>
<div class="codehilite"><pre><span class="c1">// (In function main.)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">WaitForServer</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;Site is down: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>A more convenient, equivalent way is to call <a href="https://golang.org/pkg/log/#Fatalf"><code>log.Fatalf</code></a>. As with all the <a href="https://golang.org/pkg/log/"><code>log</code></a> functions, by default it prefixes the time and date to the error message.</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">WaitForServer</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;Site is down: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>The default format is helpful in a long-running server, but not useful for an interactive tool:</p>
<div class="codehilite"><pre>2006/01/02 15:04:05 Site is down: no such domain: bad.gopl.io
</pre></div>


<p>We can set the prefix used by the <code>log</code> package to the name of the command, and suppress the display of the date and time:</p>
<div class="codehilite"><pre><span class="nx">log</span><span class="p">.</span><span class="nx">SetPrefix</span><span class="p">(</span><span class="s">&quot;wait: &quot;</span><span class="p">)</span>
<span class="nx">log</span><span class="p">.</span><span class="nx">SetFlags</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>


<h5 id="logging-the-error-and-continuing"><strong>Logging the error and continuing</strong> *</h5>
<p>Fourth, in some cases, it's sufficient just to log the error and then continue, perhaps with
reduced functionality. Using the <code>log</code> package adds the usual prefix:</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">Ping</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;ping failed: %v; networking disabled&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>To print directly to the standard error stream:</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">Ping</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;ping failed: %v; networking disabled\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>Note that all <code>log</code> functions append a newline if one is not already present.</p>
<h5 id="ignoring-the-error"><strong>Ignoring the error</strong> *</h5>
<p>Fifth and finally, in rare cases we can safely ignore an error entirely:</p>
<div class="codehilite"><pre><span class="nx">dir</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nx">TempDir</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;scratch&quot;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;failed to create temp dir: %v&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ...use temp dir...</span>
<span class="nx">os</span><span class="p">.</span><span class="nx">RemoveAll</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span> <span class="c1">// ignore errors; $TMPDIR is cleaned periodically</span>
</pre></div>


<p>The call to <code>os.RemoveAll</code> may fail, but the program ignores it because the operating system periodically cleans out the temporary directory. In this case, discarding the error was intentional, but the program logic would be the same had we forgotten to deal with it. When you deliberately ignore one, document your intention clearly.</p>
<h5 id="summary-of-error-handling"><strong>Summary of error handling</strong> *</h5>
<p>Error handling in Go has a particular rhythm.</p>
<ol>
<li>After checking an error, failure is usually dealt with before success.</li>
<li>If failure causes the function to return, the logic for success is not indented within an else block but follows at the outer level.</li>
<li>Functions tend to exhibit a common structure, with a series of initial checks to reject errors, followed by the substance of the function at the end, minimally indented.</li>
</ol>
<h4 id="end-of-file-eof">End of File (EOF)</h4>
<p>Occasionally, program must take different
actions depending on the kind of error that has occurred. Consider an attempt to read <em>n</em> bytes
of data from a file:</p>
<ul>
<li>If <em>n</em> is chosen to be the length of the file, any error represents a failure.</li>
<li>If the caller repeatedly tries to read fixed-size chunks until the file is exhausted, the caller must respond differently to an <a href="https://en.wikipedia.org/wiki/End-of-file">end-of-file</a> condition than it does to all other errors.</li>
</ul>
<p>For this reason, the <a href="https://golang.org/pkg/io/"><code>io</code></a> package guarantees that any read failure caused by an end-of-file condition is always reported by a distinguished error, <a href="https://golang.org/pkg/io/#EOF"><code>io.EOF</code></a>, which is defined as follows:</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">io</span>

<span class="kn">import</span> <span class="s">&quot;errors&quot;</span>

<span class="c1">// EOF is the error returned by Read when no more input is available.</span>
<span class="kd">var</span> <span class="nx">EOF</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;EOF&quot;</span><span class="p">)</span>
</pre></div>


<p>The caller can detect this condition using a simple comparison, as in the loop below, which reads runes from the standard input. (The <a href="https://github.com/shichao-an/gopl.io/blob/master/ch4/charcount/main.go"><code>charcount</code></a> program in Section 4.3 provides a more complete example.)</p>
<div class="codehilite"><pre><span class="nx">in</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewReader</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
<span class="k">for</span> <span class="p">{</span>
    <span class="nx">r</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">in</span><span class="p">.</span><span class="nx">ReadRune</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
        <span class="k">break</span> <span class="c1">// finished reading</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;read failed: %v&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// ...use r...</span>
<span class="p">}</span>
</pre></div>


<p>Since in an end-of-file condition there is no information to report besides the fact of it, <code>io.EOF</code> has a fixed error message, <code>"EOF"</code>. For other errors, we may need to report both the quality and quantity of the error, so a fixed error value will not do. <a href="../ch7/#discriminating-errors-with-type-assertions">Section 7.11</a> will present a more systematic way to distinguish certain error values from others.</p>
<h3 id="function-values">Function Values</h3>
<p>Functions are <a href="https://en.wikipedia.org/wiki/First-class_citizen"><em>first-class values</em></a> in Go: like other values, function values have types, and they may be assigned to variables or passed to or returned from functions. A function value may be called like any other function. For example:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">square</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">n</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">negative</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="nx">n</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">product</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">m</span> <span class="o">*</span> <span class="nx">n</span> <span class="p">}</span>

<span class="nx">f</span> <span class="o">:=</span> <span class="nx">square</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="c1">// &quot;9&quot;</span>

<span class="nx">f</span> <span class="p">=</span> <span class="nx">negative</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>     <span class="c1">// &quot;-3&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="c1">// &quot;func(int) int&quot;</span>

<span class="nx">f</span> <span class="p">=</span> <span class="nx">product</span> <span class="c1">// compile error: can&#39;t assign f(int, int) int to f(int) int</span>
</pre></div>


<p>The zero value of a function type is <code>nil</code>. Calling a <code>nil</code> function value causes a panic:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
<span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// panic: call of nil function</span>
</pre></div>


<p>Function values may be compared with <code>nil</code>:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
    <span class="k">if</span> <span class="nx">f</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>But they are not comparable, so they may not be compared against each other or used as keys in a map.</p>
<p>With function values, we can parameterize our functions over not only data, but also behavior. The standard libraries contain many examples. For instance, <code>strings.Map</code> applies a function to each character of a string, joining the results to make another string.</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">add1</span><span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">)</span> <span class="kt">rune</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Map</span><span class="p">(</span><span class="nx">add1</span><span class="p">,</span> <span class="s">&quot;HAL-9000&quot;</span><span class="p">))</span> <span class="c1">// &quot;IBM.:111&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Map</span><span class="p">(</span><span class="nx">add1</span><span class="p">,</span> <span class="s">&quot;VMS&quot;</span><span class="p">))</span> <span class="c1">// &quot;WNT&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Map</span><span class="p">(</span><span class="nx">add1</span><span class="p">,</span> <span class="s">&quot;Admix&quot;</span><span class="p">))</span> <span class="c1">// &quot;Benjy&quot;</span>
</pre></div>


<p>The <code>findLinks</code> function from <a href="#recursion">Section 5.2</a> uses a helper function, <code>visit</code>, to visit all the nodes in an HTML document and apply an action to each one. Using a function value, we can separate the logic for tree traversal from the logic for the action to be applied to each node, so that we can reuse the traversal with different actions.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch5/outline2/outline.go">gopl.io/ch5/outline2/outline.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// forEachNode calls the functions pre(x) and post(x) for each node</span>
<span class="c1">// x in the tree rooted at n. Both functions are optional.</span>
<span class="c1">// pre is called before the children are visited (preorder) and</span>
<span class="c1">// post is called after (postorder).</span>
<span class="kd">func</span> <span class="nx">forEachNode</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">pre</span><span class="p">,</span> <span class="nx">post</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">pre</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">pre</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
        <span class="nx">forEachNode</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">pre</span><span class="p">,</span> <span class="nx">post</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">post</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">post</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The <code>forEachNode</code> function accepts two function arguments, one to call before a node's children are visited and one to call after. This arrangement gives the caller a great deal of flexibility. For example, the functions <code>startElement</code> and <code>endElement</code> print the start and end tags of an HTML element like <code>&lt;b&gt;...&lt;/b&gt;</code>:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">depth</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nx">startElement</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%*s&lt;%s&gt;\n&quot;</span><span class="p">,</span> <span class="nx">depth</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
        <span class="nx">depth</span><span class="o">++</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">endElement</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
        <span class="nx">depth</span><span class="o">--</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%*s&lt;/%s&gt;\n&quot;</span><span class="p">,</span> <span class="nx">depth</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The functions also indent the output using another <code>fmt.Printf</code> trick. The <code>*</code> adverb in <code>%*s</code> prints a string padded with a variable number of spaces. The width and the string are provided by the arguments <code>depth*2</code> and <code>""</code>.</p>
<p>If we call <code>forEachNode</code> on an HTML document, like this:</p>
<div class="codehilite"><pre><span class="nx">forEachNode</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="nx">startElement</span><span class="p">,</span> <span class="nx">endElement</span><span class="p">)</span>
</pre></div>


<p>This will output:</p>
<div class="codehilite"><pre>$ go build gopl.io/ch5/outline2
$ ./outline2 http://gopl.io
&lt;html&gt;
  &lt;head&gt;
    &lt;meta&gt;
    &lt;/meta&gt;
    &lt;title&gt;
    &lt;/title&gt;
    &lt;style&gt;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;
            &lt;a&gt;
              &lt;img&gt;
              &lt;/img&gt;
...
</pre></div>


<h3 id="anonymous-functions">Anonymous Functions</h3>
<p>Named functions can be declared only at the package level, but we can use a <em>function literal</em> to denote a function value within any expression. A function literal is written like a function declaration, but without a name following the <code>func</code> keyword. It is an expression, and its value is called an <a href="https://en.wikipedia.org/wiki/Anonymous_function"><em>anonymous function</em></a>.</p>
<p>Function literals let us define a function at its point of use. As an example, the earlier call to <code>strings.Map</code> in <a href="#function-values">Section 5.5</a> can be rewritten as:</p>
<div class="codehilite"><pre><span class="nx">strings</span><span class="p">.</span><span class="nx">Map</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">)</span> <span class="kt">rune</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">},</span> <span class="s">&quot;HAL-9000&quot;</span><span class="p">)</span>
</pre></div>


<p><u>Functions defined in this way have access to the entire lexical environment, so the inner function can refer to variables from the enclosing function.</u> For example:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch5/squares/main.go">gopl.io/ch5/squares/main.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// squares returns a function that returns</span>
<span class="c1">// the next square number each time it is called.</span>
<span class="kd">func</span> <span class="nx">squares</span><span class="p">()</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="kt">int</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
        <span class="nx">x</span><span class="o">++</span>
        <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nx">squares</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">())</span> <span class="c1">// &quot;1&quot;</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">())</span> <span class="c1">// &quot;4&quot;</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">())</span> <span class="c1">// &quot;9&quot;</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">())</span> <span class="c1">// &quot;16&quot;</span>
<span class="p">}</span>
</pre></div>


<p>The function <code>squares</code> returns another function of type <code>func() int</code>. A call to <code>squares</code> creates a local variable <code>x</code> and returns an anonymous function that, each time it is called, increments <code>x</code> and returns its square. A second call to squares would create a second variable <code>x</code> and return a new anonymous function.</p>
<p>This example demonstrates:</p>
<ul>
<li>Function values are not just code but can have state.<ul>
<li><u>The anonymous inner function can access and update the local variables of the enclosing function. These hidden variable references are why we classify functions as reference types and why function values are not comparable.</u></li>
<li>Function values like these are implemented using a technique called <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)"><em>closures</em></a>, and Go programmers often use this term for function values.</li>
</ul>
</li>
<li>The lifetime of a variable is not determined by its scope<ul>
<li>In the above example, the variable <code>x</code> exists after <code>squares</code> has returned within <code>main</code>, even though <code>x</code> is hidden inside <code>f</code>.</li>
</ul>
</li>
</ul>
<p>The following example is a problem of computing a sequence of computer science courses that satisfies the prerequisite requirements of each one. The prerequisites are given in the <code>prereqs</code> table below, which is a mapping from each course to the list of courses that must be completed before it.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch5/toposort/main.go">gopl.io/ch5/toposort/main.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// prereqs maps computer science courses to their prerequisites.</span>
<span class="kd">var</span> <span class="nx">prereqs</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">{</span>
    <span class="s">&quot;algorithms&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;data structures&quot;</span><span class="p">},</span>
    <span class="s">&quot;calculus&quot;</span><span class="p">:</span>   <span class="p">{</span><span class="s">&quot;linear algebra&quot;</span><span class="p">},</span>

    <span class="s">&quot;compilers&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&quot;data structures&quot;</span><span class="p">,</span>
        <span class="s">&quot;formal languages&quot;</span><span class="p">,</span>
        <span class="s">&quot;computer organization&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="s">&quot;data structures&quot;</span><span class="p">:</span>       <span class="p">{</span><span class="s">&quot;discrete math&quot;</span><span class="p">},</span>
    <span class="s">&quot;databases&quot;</span><span class="p">:</span>             <span class="p">{</span><span class="s">&quot;data structures&quot;</span><span class="p">},</span>
    <span class="s">&quot;discrete math&quot;</span><span class="p">:</span>         <span class="p">{</span><span class="s">&quot;intro to programming&quot;</span><span class="p">},</span>
    <span class="s">&quot;formal languages&quot;</span><span class="p">:</span>      <span class="p">{</span><span class="s">&quot;discrete math&quot;</span><span class="p">},</span>
    <span class="s">&quot;networks&quot;</span><span class="p">:</span>              <span class="p">{</span><span class="s">&quot;operating systems&quot;</span><span class="p">},</span>
    <span class="s">&quot;operating systems&quot;</span><span class="p">:</span>     <span class="p">{</span><span class="s">&quot;data structures&quot;</span><span class="p">,</span> <span class="s">&quot;computer organization&quot;</span><span class="p">},</span>
    <span class="s">&quot;programming languages&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;data structures&quot;</span><span class="p">,</span> <span class="s">&quot;computer organization&quot;</span><span class="p">},</span>
<span class="p">}</span>
</pre></div>


<p>This kind of problem is known as <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological sorting</a>. The prerequisite information forms a directed graph with a node for each course and edges from each course to the courses that it depends on. The graph is acyclic: there is no path from a course that leads back to itself. We can compute a valid sequence using depth-first search through the graph with the code below:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">course</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">topoSort</span><span class="p">(</span><span class="nx">prereqs</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d:\t%s\n&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">course</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">topoSort</span><span class="p">(</span><span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">order</span> <span class="p">[]</span><span class="kt">string</span>
    <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">visitAll</span> <span class="kd">func</span><span class="p">(</span><span class="nx">items</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>

    <span class="nx">visitAll</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">items</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span> <span class="p">{</span>
                <span class="nx">seen</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="nx">visitAll</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="nx">item</span><span class="p">])</span>
                <span class="nx">order</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">order</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">keys</span> <span class="p">[]</span><span class="kt">string</span>
    <span class="k">for</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
        <span class="nx">keys</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">sort</span><span class="p">.</span><span class="nx">Strings</span><span class="p">(</span><span class="nx">keys</span><span class="p">)</span>
    <span class="nx">visitAll</span><span class="p">(</span><span class="nx">keys</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">order</span>
<span class="p">}</span>
</pre></div>


<p><u>When an anonymous function requires recursion, we must first declare a variable, and then assign the anonymous function to that variable.</u></p>
<p>If two steps are combined in the declaration, the function literal would not be within the scope of the variable <code>visitAll</code> so it would have no way to call itself recursively:</p>
<div class="codehilite"><pre><span class="nx">visitAll</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">items</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="nx">visitAll</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="nx">item</span><span class="p">])</span> <span class="c1">// compile error: undefined: visitAll</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>


<p>The output of the <code>toposort</code> program is shown below. It is deterministic, an often-desirable property that doesn't always come for free. The values of the <code>prereqs</code> map are slices, not more maps, so their iteration order is deterministic, and we sorted the keys of <code>prereqs</code> before making the initial calls to <code>visitAll</code>.</p>
<div class="codehilite"><pre>1: intro to programming
2: discrete math
3: data structures
4: algorithms
5: linear algebra
6: calculus
7: formal languages
8: computer organization
9: compilers
10: databases
11: operating systems
12: networks
13: programming languages
</pre></div>


<p>Returning to the <code>findLinks</code> example, link-extraction function <code>links.Extract</code> is moved to its own package, since it'll be used again in <a href="ch8.md">Chapter 8</a>. We replaced the <code>visit</code> function with an anonymous function that appends to the <code>links</code> slice directly, and used <code>forEachNode</code> to handle the traversal. Since <code>Extract</code> needs only the <code>pre</code> function, it passes <code>nil</code> for the <code>post</code> argument.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch5/links/links.go">gopl.io/ch5/links/links.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// Package links provides a link-extraction function.</span>
<span class="kn">package</span> <span class="nx">links</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;net/http&quot;</span>
    <span class="s">&quot;golang.org/x/net/html&quot;</span>
<span class="p">)</span>

<span class="c1">// Extract makes an HTTP GET request to the specified URL, parses</span>
<span class="c1">// the response as HTML, and returns the links in the HTML document.</span>
<span class="kd">func</span> <span class="nx">Extract</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">!=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="p">{</span>
        <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;getting %s: %s&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Status</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
    <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;parsing %s as HTML: %v&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">links</span> <span class="p">[]</span><span class="kt">string</span>
    <span class="nx">visitNode</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="s">&quot;a&quot;</span> <span class="p">{</span>
            <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Key</span> <span class="o">!=</span> <span class="s">&quot;href&quot;</span> <span class="p">{</span>
                    <span class="k">continue</span>
                <span class="p">}</span>
                <span class="nx">link</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
                <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                    <span class="k">continue</span> <span class="c1">// ignore bad URLs</span>
                <span class="p">}</span>
                <span class="nx">links</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">links</span><span class="p">,</span> <span class="nx">link</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">forEachNode</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="nx">visitNode</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">links</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>


<p>Instead of appending the raw <code>href</code> attribute value to the <code>links</code> slice, this version parses it as a URL relative to the base URL of the document, <a href="https://golang.org/pkg/net/url/#URL.Parse"><code>resp.Request.URL</code></a>. The resulting <code>link</code> is in absolute form, suitable for use in a call to <code>http.Get</code>.</p>
<p>Crawling the web is a problem of graph traversal. The <code>topoSort</code> example showed a depth-first traversal. The following web crawler uses breadth-first traversal. In <a href="ch8.md">Chapter 8</a>, we'll explore concurrent traversal.</p>
<p>The function below encapsulates the essence of a breadth-first traversal:</p>
<ul>
<li>The caller provides an initial list <code>worklist</code> of items to visit and a function value <code>f</code> to call for each item, which is identified by a string.</li>
<li>The function <code>f</code> returns a list of new items to append to the worklist.</li>
<li>The <code>breadthFirst</code> function returns when all items have been visited. It maintains a set of strings to ensure that no item is visited twice.</li>
</ul>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch5/findlinks3/findlinks.go">gopl.io/ch5/findlinks3/findlinks.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// breadthFirst calls f for each item in the worklist.</span>
<span class="c1">// Any items returned by f are added to the worklist.</span>
<span class="c1">// f is called at most once for each item.</span>
<span class="kd">func</span> <span class="nx">breadthFirst</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">worklist</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">worklist</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">items</span> <span class="o">:=</span> <span class="nx">worklist</span>
        <span class="nx">worklist</span> <span class="p">=</span> <span class="kc">nil</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span> <span class="p">{</span>
                <span class="nx">seen</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="nx">worklist</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">worklist</span><span class="p">,</span> <span class="nx">f</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The argument "<code>f(item)...</code>" causes all the items in the list returned by <code>f</code> to be appended to the worklist.</p>
<p>In this crawler, items are URLs. The <code>crawl</code> function, which is passed to <code>breadthFirst</code>, prints the URL, extracts its links, and returns them so that they are also visited.</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="nx">list</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">Extract</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">list</span>
<span class="p">}</span>
</pre></div>


<p>To start off the crawler, we use the command-line arguments as the initial URLs.</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Crawl the web breadth-first,</span>
    <span class="c1">// starting from the command-line arguments.</span>
    <span class="nx">breadthFirst</span><span class="p">(</span><span class="nx">crawl</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="p">}</span>
</pre></div>


<p>Crawl the web starting from <code>https://golang.org</code>:</p>
<div class="codehilite"><pre>$ go build gopl.io/ch5/findlinks3
$ ./findlinks3 https://golang.org
https://golang.org/
https://golang.org/doc/
https://golang.org/pkg/
https://golang.org/project/
https://code.google.com/p/go-tour/
https://golang.org/doc/code.html
https://www.youtube.com/watch?v=XCsL89YtqCs
http://research.swtch.com/gotour
https://vimeo.com/53221560
...
</pre></div>


<p>The process ends when all reachable web pages have been crawled or the memory of the computer is exhausted.</p>
<h4 id="caveat-capturing-iteration-variables">Caveat: Capturing Iteration Variables</h4>
<p>This section discusses a pitfall of Go's lexical scope rules that can cause surprising results.</p>
<p>Consider a program that must create a set of directories and later remove them. We can use a slice of function values to hold the clean-up operations. (All error handling in this example for brevity.)</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">rmdirs</span> <span class="p">[]</span><span class="kd">func</span><span class="p">()</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">d</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tempDirs</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">dir</span> <span class="o">:=</span> <span class="nx">d</span>               <span class="c1">// NOTE: necessary!</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">MkdirAll</span><span class="p">(</span><span class="nx">dir</span><span class="p">,</span> <span class="mo">0755</span><span class="p">)</span> <span class="c1">// creates parent directories too</span>
    <span class="nx">rmdirs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">rmdirs</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">os</span><span class="p">.</span><span class="nx">RemoveAll</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// ...do some work...</span>

<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">rmdir</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">rmdirs</span> <span class="p">{</span>
    <span class="nx">rmdir</span><span class="p">()</span> <span class="c1">// clean up</span>
<span class="p">}</span>
</pre></div>


<p>You may be wondering why we assigned the loop variable <code>d</code> to a new local variable <code>dir</code> within the loop body, instead of just using the loop variable <code>dir</code> as in this subtly incorrect variant:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">rmdirs</span> <span class="p">[]</span><span class="kd">func</span><span class="p">()</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dir</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tempDirs</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">MkdirAll</span><span class="p">(</span><span class="nx">dir</span><span class="p">,</span> <span class="mo">0755</span><span class="p">)</span>
    <span class="nx">rmdirs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">rmdirs</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">os</span><span class="p">.</span><span class="nx">RemoveAll</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span> <span class="c1">// NOTE: incorrect!</span>
    <span class="p">})</span>
<span class="p">}</span>
</pre></div>


<p>The reason is a consequence of the scope rules for loop variables. In the program immediately above:</p>
<ol>
<li>The <code>for</code> loop introduces a new lexical block in which the variable <code>dir</code> is declared. All function values created by this loop "capture" and share the same variable, which is an addressable storage location, not its value at that particular moment.</li>
<li>The value of <code>dir</code> is updated in successive iterations, so by the time the cleanup functions are called, the <code>dir</code> variable has been updated several times by the now-completed <code>for</code> loop.</li>
<li>Thus <code>dir</code> holds the value from the final iteration, and consequently all calls to <code>os.RemoveAll</code> will attempt to remove the same directory.</li>
</ol>
<p>Frequently, <u>the inner variable introduced to work around this problem (<code>dir</code> in the example above) is given the exact same name as the outer variable of which it is a copy.</u> This leads to odd-looking but crucial variable declarations like this:</p>
<div class="codehilite"><pre><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dir</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tempDirs</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">dir</span> <span class="o">:=</span> <span class="nx">dir</span> <span class="c1">// declares inner dir, initialized to outer dir</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>


<p>The risk is not unique to <code>range</code>-based <code>for</code> loops. The loop in the example below suffers from the same problem due to unintended capture of the index variable <code>i</code>.</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">rmdirs</span> <span class="p">[]</span><span class="kd">func</span><span class="p">()</span>
<span class="nx">dirs</span> <span class="o">:=</span> <span class="nx">tempDirs</span><span class="p">()</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dirs</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">MkdirAll</span><span class="p">(</span><span class="nx">dirs</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="mo">0755</span><span class="p">)</span> <span class="c1">// OK</span>
    <span class="nx">rmdirs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">rmdirs</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">os</span><span class="p">.</span><span class="nx">RemoveAll</span><span class="p">(</span><span class="nx">dirs</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="c1">// NOTE: incorrect!</span>
    <span class="p">})</span>
<span class="p">}</span>
</pre></div>


<p>The problem of iteration variable capture is most often encountered when using the <code>go</code> statement (<a href="ch8.md">Chapter 8</a>) or with <code>defer</code> (to be discussed later) since both may delay the execution of a function value until after the loop has finished. But the problem is not inherent to <code>go</code> or <code>defer</code>. See also <a href="https://github.com/golang/go/wiki/CommonMistakes#using-goroutines-on-loop-iterator-variables">Common Mistakes</a>.</p>
<h3 id="variadic-functions">Variadic Functions</h3>
<p>A <a href="https://en.wikipedia.org/wiki/Variadic_function"><strong>variadic function</strong></a> can be called with varying numbers of arguments. The most familiar examples are <code>fmt.Printf</code> and its variants. <code>Printf</code> requires one fixed argument at the beginning, then accepts any number of subsequent arguments.</p>
<p>To declare a variadic function, the type of the final parameter is preceded by an ellipsis, "<code>...</code>", which indicates that the function may be called with any number of arguments of this type.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch5/sum/main.go">gopl.io/ch5/sum/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">vals</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">total</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vals</span> <span class="p">{</span>
        <span class="nx">total</span> <span class="o">+=</span> <span class="nx">val</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">total</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>The <code>sum</code> function above returns the sum of zero or more <code>int</code> arguments.</li>
<li>Within the body of the function, the type of <code>vals</code> is an <code>[]int</code> slice.</li>
<li>When <code>sum</code> is called, any number of values may be provided for its <code>vals</code> parameter.</li>
</ul>
<div class="codehilite"><pre><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">())</span>           <span class="c1">// &quot;0&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>          <span class="c1">// &quot;3&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">// &quot;10&quot;</span>
</pre></div>


<p><u>Implicitly, the caller allocates an array, copies the arguments into it, and passes a slice of the entire array to the function.</u></p>
<p>To invoke a variadic function when the arguments are already in a slice, place an ellipsis after the final argument. The call below behaves the same as the last call above.</p>
<div class="codehilite"><pre><span class="nx">values</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="nx">values</span><span class="o">...</span><span class="p">))</span> <span class="c1">// &quot;10&quot;</span>
</pre></div>


<p>Although the <code>...int</code> parameter behaves like a slice within the function body, the type of a variadic function is distinct from the type of a function with an ordinary slice parameter.</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">f</span><span class="p">(</span><span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
<span class="kd">func</span> <span class="nx">g</span><span class="p">([]</span><span class="kt">int</span><span class="p">)</span>  <span class="p">{}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="c1">// &quot;func(...int)&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">g</span><span class="p">)</span> <span class="c1">// &quot;func([]int)&quot;</span>
</pre></div>


<p>Variadic functions are often used for string formatting. The <code>errorf</code> function below constructs a formatted error message with a line number at the beginning. <u>The suffix <code>f</code> is a widely followed naming convention for variadic functions that accept a <code>Printf</code>-style format string.</u></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">errorf</span><span class="p">(</span><span class="nx">linenum</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;Line %d: &quot;</span><span class="p">,</span> <span class="nx">linenum</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">linenum</span><span class="p">,</span> <span class="nx">name</span> <span class="o">:=</span> <span class="mi">12</span><span class="p">,</span> <span class="s">&quot;count&quot;</span>
<span class="nx">errorf</span><span class="p">(</span><span class="nx">linenum</span><span class="p">,</span> <span class="s">&quot;undefined: %s&quot;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span> <span class="c1">// &quot;Line 12: undefined: count&quot;</span>
</pre></div>


<p>The <code>interface{}</code> type means that this function can accept any values for its final arguments, which is discussed in <a href="../ch7/">Chapter 7</a>.</p>
<h3 id="deferred-function-calls">Deferred Function Calls</h3>
<p>The <code>findLinks</code> examples used the output of <code>http.Get</code> as the input to <code>html.Parse</code>. However, many pages contain images, plain text, and other file formats instead of HTML. Feeding such files into an HTML parser could have undesirable effects.</p>
<p>The program below fetches an HTML document and prints its title. The <code>title</code> function inspects the <a href="https://en.wikipedia.org/wiki/Media_type"><code>Content-Type</code></a> header of the server's response and returns an error if the document is not HTML.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch5/title1/title.go">gopl.io/ch5/title1/title.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">title</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="c1">// Check Content-Type is HTML (e.g., &quot;text/html; charset=utf-8&quot;).</span>
    <span class="nx">ct</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;Content-Type&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">ct</span> <span class="o">!=</span> <span class="s">&quot;text/html&quot;</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">HasPrefix</span><span class="p">(</span><span class="nx">ct</span><span class="p">,</span> <span class="s">&quot;text/html;&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;%s has type %s, not text/html&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">ct</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
    <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;parsing %s as HTML: %v&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">visitNode</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="s">&quot;title&quot;</span> <span class="o">&amp;&amp;</span>
            <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">forEachNode</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="nx">visitNode</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>


<div class="codehilite"><pre>$ go build gopl.io/ch5/title1
$ ./title1 http://gopl.io
The Go Programming Language
$ ./title1 https://golang.org/doc/effective_go.html
Effective Go - The Go Programming Language
$ ./title1 https://golang.org/doc/gopher/frontpage.png
title: https://golang.org/doc/gopher/frontpage.png has type image/png, not text/html
</pre></div>


<p>The <code>resp.Body.Close()</code> call, which is duplicated, ensures that title closes the network connection on all execution paths, including failures. As functions grow more complex and have to handle more errors, such duplication of clean-up logic may become a maintenance problem. Go' <code>defer</code> mechanism makes things simpler.</p>
<p>Syntactically, a <code>defer</code> statement is an ordinary function or method call prefixed by the keyword <code>defer</code>.</p>
<ul>
<li>The function and argument expressions are evaluated when the statement is executed, but the actual call is <em>deferred</em> until the (caller) function that contains the <code>defer</code> statement has finished. The "finished" here means either normally or abnormally:<ul>
<li>Normally: the caller function executing a return statement or falling off the end.</li>
<li>Abnormally: the caller function panicking.</li>
</ul>
</li>
<li>Any number of calls may be deferred; <u>they are executed in the reverse of the order in which they were deferred.</u></li>
</ul>
<p>A <code>defer</code> statement is often used with paired operations to ensure that resources are released in all cases no matter how complex the control flow. Some examples for such paired operations are:</p>
<ul>
<li>Open and close</li>
<li>Connect and disconnect</li>
<li>Lock and unlock</li>
</ul>
<p>The right place for a <code>defer</code> statement that releases a resource is immediately after the resource has been successfully acquired. In the <code>title</code> function below, a single deferred call replaces both previous calls to <code>resp.Body.Close()</code>:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch5/title2/title.go">gopl.io/ch5/title2/title.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">title</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>

    <span class="nx">ct</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;Content-Type&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">ct</span> <span class="o">!=</span> <span class="s">&quot;text/html&quot;</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">HasPrefix</span><span class="p">(</span><span class="nx">ct</span><span class="p">,</span> <span class="s">&quot;text/html;&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;%s has type %s, not text/html&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">ct</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;parsing %s as HTML: %v&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// ...print doc&#39;s title element...</span>
    <span class="c1">//!-</span>
    <span class="nx">visitNode</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="s">&quot;title&quot;</span> <span class="o">&amp;&amp;</span>
            <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">forEachNode</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="nx">visitNode</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="c1">//!+</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>


<p>The same pattern can be used for other resources. For example, close an open file:</p>
<p><small><a href="https://golang.org/src/io/ioutil/ioutil.go">io/ioutil/ioutil.go</a></small></p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">ioutil</span>

<span class="kd">func</span> <span class="nx">ReadFile</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">ReadAll</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>Unlock a mutex (<a href="ch9.md#mutual-exclusion-syncmutex">Section 9.2</a>):</p>
<div class="codehilite"><pre>var mu sync.Mutex
var m = make(map[string]int)

func lookup(key string) int {
    mu.Lock()
    defer mu.Unlock()
    return m[key]
}
</pre></div>


<h4 id="on-entry-and-on-exit-actions">On-entry and on-exit actions *</h4>
<p>The <code>defer</code> statement can also be used to pair "on entry" and "on exit" actions when debugging a complex function.</p>
<p>The <code>bigSlowOperation</code> function below does two things:</p>
<ol>
<li>It calls trace immediately, which does the "on entry" action.</li>
<li>Then, it returns a function value that, when called, does the corresponding "on exit" action.</li>
</ol>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch5/trace/main.go">gopl.io/ch5/trace/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">bigSlowOperation</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">trace</span><span class="p">(</span><span class="s">&quot;bigSlowOperation&quot;</span><span class="p">)()</span> <span class="c1">// don&#39;t forget the extra parentheses</span>
    <span class="c1">// ...lots of work...</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span> <span class="c1">// simulate slow operation by sleeping</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">trace</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;enter %s&quot;</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;exit %s (%s)&quot;</span><span class="p">,</span> <span class="nx">msg</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Since</span><span class="p">(</span><span class="nx">start</span><span class="p">))</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p><u>By deferring a call to the returned function in this way, we can instrument the entry point and all exit points of a function in a single statement and even pass values,</u> like the start time, between the two actions. Do not forget the final parentheses in the defer statement, or the "on entry" action will happen on exit and the on-exit action won't happen at all.</p>
<p>Each time <code>bigSlowOperation</code> is called, it logs its entry and exit and the elapsed time between them.</p>
<div class="codehilite"><pre>$ go build gopl.io/ch5/trace
$ ./trace
2015/11/18 09:53:26 enter bigSlowOperation
2015/11/18 09:53:36 <span class="nb">exit</span> bigSlowOperation <span class="o">(</span>10.000589217s<span class="o">)</span>
</pre></div>


<h4 id="accessing-result-variables">Accessing result variables *</h4>
<p>Deferred functions run after return statements have updated the function's result variables.  Because an anonymous function can access its enclosing function's variables, including named results, a deferred anonymous function can observe the function's results.</p>
<p>For the following function:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">double</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">x</span>
<span class="p">}</span>
</pre></div>


<p>By naming its result variable and adding a <code>defer</code> statement, we can make the function print its arguments and results each time it is called.</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">double</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;double(%d) = %d\n&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">}()</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">x</span>
<span class="p">}</span>

<span class="nx">_</span><span class="p">=</span><span class="nx">double</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="c1">// Output:</span>
<span class="c1">// &quot;double(4) = 8&quot;</span>
</pre></div>


<p>This is useful in functions with many return statements.</p>
<p>A deferred anonymous function can even change the values that the enclosing function returns to its caller:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">triple</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">result</span> <span class="o">+=</span> <span class="nx">x</span> <span class="p">}()</span>
    <span class="k">return</span> <span class="nx">double</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">triple</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="c1">// &quot;12&quot;</span>
</pre></div>


<h4 id="caveats-of-deferred-functions">Caveats of deferred functions *</h4>
<p>Because deferred functions aren't executed until the end of a function's execution, a <code>defer</code> statement in a loop deserves extra scrutiny. The code below could run out of file descriptors since no file will be closed until all files have been processed:</p>
<div class="codehilite"><pre><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">filename</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span> <span class="c1">// NOTE: risky; could run out of file descriptors</span>
    <span class="c1">// ...process f...</span>
<span class="p">}</span>
</pre></div>


<p>One solution is to move the loop body, including the <code>defer</code> statement, into another function that is called on each iteration:</p>
<div class="codehilite"><pre><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">filename</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">doFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">doFile</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="c1">// ...process f...</span>
<span class="p">}</span>
</pre></div>


<p>The example below is an improved <code>fetch</code> program (<a href="../ch1/#fetching-a-url">Section 1.5</a>) that writes the HTTP response to a local file instead of to the standard output. It derives the file name from the last component of the URL path, which it obtains using the <code>path.Base</code> function.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch5/fetch/main.go">gopl.io/ch5/fetch/main.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// Fetch downloads the URL and returns the</span>
<span class="c1">// name and length of the local file.</span>
<span class="kd">func</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>

    <span class="nx">local</span> <span class="o">:=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">Base</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">local</span> <span class="o">==</span> <span class="s">&quot;/&quot;</span> <span class="p">{</span>
        <span class="nx">local</span> <span class="p">=</span> <span class="s">&quot;index.html&quot;</span>
    <span class="p">}</span>
    <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="nx">local</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
    <span class="c1">// Close file, but prefer error from Copy, if any.</span>
    <span class="k">if</span> <span class="nx">closeErr</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">();</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">closeErr</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">local</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
</pre></div>


<ol>
<li>The call to <code>resp.Body.Close</code> is deferred.</li>
<li>It's tempting to use a second deferred call, to <code>f.Close</code>, to close the local file, but this would be subtly wrong because <code>os.Create</code> opens a file for writing, creating it as needed. On many file systems, notably NFS, write errors are not reported immediately but may be postponed until the file is closed. Failure to check the result of the close operation could cause serious data loss to go unnoticed.</li>
<li>If both <code>io.Copy</code> and <code>f.Close</code> fail, we should prefer to report the error from <code>io.Copy</code> since it occurred first and is more likely to tell us the root cause.</li>
</ol>
<h3 id="panic">Panic</h3>
<p>Go's type system catches many mistakes at compile time; other mistakes, such as an out-of-bounds array access or nil pointer dereference, require checks at run time. When the Go runtime detects these mistakes, it <em>panics</em>.</p>
<p>During a typical panic, normal execution stops, all deferred function calls in that goroutine are executed, and the program crashes with a log message:</p>
<ol>
<li>This log message includes the panic value, which is usually an error message and a <a href="https://en.wikipedia.org/wiki/Stack_trace">stack trace</a> (for each goroutine) showing the stack of function calls that were active at the time of the panic.</li>
<li>This log message often has enough information to diagnose the root cause of the problem without running the program again, so it should always be included in a bug report about a panicking program.</li>
</ol>
<p>Besides the panics that come from the runtime, the built-in <code>panic</code> function may be called directly. It accepts any value as an argument. A panic is often the best thing to do when some "impossible" situation happens, for instance, execution reaches a case that logically can't happen:</p>
<div class="codehilite"><pre><span class="k">switch</span> <span class="nx">s</span> <span class="o">:=</span> <span class="nx">suit</span><span class="p">(</span><span class="nx">drawCard</span><span class="p">());</span> <span class="nx">s</span> <span class="p">{</span>
<span class="k">case</span> <span class="s">&quot;Spades&quot;</span><span class="p">:</span> <span class="c1">// ...</span>
<span class="k">case</span> <span class="s">&quot;Hearts&quot;</span><span class="p">:</span> <span class="c1">// ...</span>
<span class="k">case</span> <span class="s">&quot;Diamonds&quot;</span><span class="p">:</span> <span class="c1">// ...</span>
<span class="k">case</span> <span class="s">&quot;Clubs&quot;</span><span class="p">:</span> <span class="c1">// ...</span>
<span class="k">default</span><span class="p">:</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;invalid suit %q&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">))</span> <span class="c1">// Joker?</span>
<span class="p">}</span>
</pre></div>


<p>It's good practice to assert that the preconditions of a function hold only if you can provide a more informative error message or detect an error sooner. Otherwise, there is no point asserting a condition that the runtime will check for you.</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">Reset</span><span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="s">&quot;x is nil&quot;</span><span class="p">)</span> <span class="c1">// unnecessary!</span>
    <span class="p">}</span>
    <span class="nx">x</span><span class="p">.</span><span class="nx">elements</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>


<h4 id="panic-vs-error-values">Panic vs. <code>error</code> values *</h4>
<p>Although Go's panic mechanism resembles exceptions in other languages, its usages are quite different. Since a panic causes the program to crash, it is generally used for grave errors, such as a logical inconsistency in the program; diligent programmers consider any crash to be proof of a bug in their code.</p>
<p>In a robust program, "expected" errors that arise from incorrect input, misconfiguration, or failing I/O, should be handled gracefully; they are best dealt with using error values.</p>
<p>Consider the function <a href="https://golang.org/pkg/regexp/#Compile"><code>regexp.Compile</code></a>, which compiles a regular expression into an efficient form for matching. It returns an error if called with an ill-formed pattern, but checking this error is unnecessary and burdensome if the caller knows that a particular call cannot fail. In such cases, it's reasonable for the caller to handle an error by panicking, since it is believed to be impossible.</p>
<p>Since most regular expressions are literals in the program source code, the <a href="https://golang.org/pkg/regexp/"><code>regexp</code></a> package provides a wrapper function <a href="https://golang.org/pkg/regexp/#MustCompile"><code>regexp.MustCompile</code></a> that does this check:</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">regexp</span>

<span class="kd">func</span> <span class="nx">Compile</span><span class="p">(</span><span class="nx">expr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Regexp</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">MustCompile</span><span class="p">(</span><span class="nx">expr</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Regexp</span> <span class="p">{</span>
    <span class="nx">re</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">Compile</span><span class="p">(</span><span class="nx">expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">re</span>
<span class="p">}</span>
</pre></div>


<p>This wrapper function makes it convenient for clients to initialize a package-level variable with a compiled regular expression, like this:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">httpSchemeRE</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="s">`^https?:`</span><span class="p">)</span> <span class="c1">// &quot;http:&quot; or &quot;https:&quot;</span>
</pre></div>


<p><code>MustCompile</code> should not be called with untrusted input values. <u>The <code>Must</code> prefix is a common naming convention for functions of this kind,</u> like <code>template.Must</code> in <a href="#text-and-html-templates">Section 4.6</a>.</p>
<h4 id="panic-and-deferred-functions">Panic and deferred functions *</h4>
<p>When a panic occurs, all deferred functions are run in reverse order, starting with those of the topmost function on the stack and proceeding up to <code>main</code>. For example:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch5/defer1/defer.go">gopl.io/ch5/defer1/defer.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;f(%d)\n&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="o">+</span><span class="mi">0</span><span class="o">/</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// panics if x == 0</span>
    <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;defer %d\n&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
    <span class="nx">f</span><span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>When the program is run, it prints the following to the standard output:</p>
<div class="codehilite"><pre>f(3)
f(2)
f(1)
defer 1
defer 2
defer 3
</pre></div>


<p>And the following to the standard error (simplified for clarity):</p>
<div class="codehilite"><pre>panic: runtime error: integer divide by zero
main.f(0)
        src/gopl.io/ch5/defer1/defer.go:14
main.f(1)
        src/gopl.io/ch5/defer1/defer.go:16
main.f(2)
        src/gopl.io/ch5/defer1/defer.go:16
main.f(3)
        src/gopl.io/ch5/defer1/defer.go:16
main.main()
        src/gopl.io/ch5/defer1/defer.go:10
</pre></div>


<ol>
<li>A panic occurs during the call to <code>f(0)</code>, causing the three deferred calls to <code>fmt.Printf</code> to run.</li>
<li>Then the runtime terminates the program, printing the panic message and a stack dump to the standard error stream.</li>
</ol>
<p>For diagnostic purposes, the <a href="https://golang.org/pkg/runtime/"><code>runtime</code></a> package lets the programmer dump the stack.</p>
<p>For example, the program below defers a call to <code>printStack</code> in <code>main</code>:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch5/defer2/defer.go">gopl.io/ch5/defer2/defer.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">printStack</span><span class="p">()</span>
    <span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">printStack</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">buf</span> <span class="p">[</span><span class="mi">4096</span><span class="p">]</span><span class="kt">byte</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">Stack</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:],</span> <span class="kc">false</span><span class="p">)</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">.</span><span class="nx">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">])</span>
<span class="p">}</span>
</pre></div>


<p>The following additional text (simplified for clarity) is printed to the standard output:</p>
<div class="codehilite"><pre>goroutine 1 [running]:
main.printStack()
    src/gopl.io/ch5/defer2/defer.go:20
main.f(0)
    src/gopl.io/ch5/defer2/defer.go:27
main.f(1)
    src/gopl.io/ch5/defer2/defer.go:29
main.f(2)
    src/gopl.io/ch5/defer2/defer.go:29
main.f(3)
    src/gopl.io/ch5/defer2/defer.go:29
main.main()
    src/gopl.io/ch5/defer2/defer.go:15
</pre></div>


<p>Those familiar with exceptions in other languages may found that <code>runtime.Stack</code> can print information about functions that seem to have already been "<a href="https://en.wikipedia.org/wiki/Call_stack#Unwinding">unwound</a>". Go's panic mechanism runs the deferred functions <em>before</em> it unwinds the stack.</p>
<h3 id="recover">Recover</h3>
<p>Giving up is not always the right response to a panic. It might be possible to recover in some way, or at least do the clean-up before quitting. For example, a web server that encounters an unexpected problem could close the connection rather than leave the client hanging.</p>
<p>If the built-in <code>recover</code> function is called within a deferred function and the function containing the <code>defer</code> statement is panicking, <code>recover</code> ends the current state of panic and returns the panic value. The function that was panicking does not continue where it left off but returns normally. If <code>recover</code> is called at any other time, it has no effect and returns <code>nil</code>.</p>
<p>In the following parser example, instead of crashing, it turns these panics into ordinary parse errors.</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">Parse</span><span class="p">(</span><span class="nx">input</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Syntax</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;internal error: %v&quot;</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="c1">// ...parser...</span>
<span class="p">}</span>
</pre></div>


<p>The deferred function in <code>Parse</code> recovers from a panic, using the panic value to construct an error message; a fancier version might include the entire call stack using <code>runtime.Stack</code>. <u>The deferred function then assigns to the <code>err</code> result, which is returned to the caller.</u></p>
<p>Recovering indiscriminately from panics is a dubious practice because:</p>
<ul>
<li>The state of a package's variables after a panic is rarely well defined or documented. For example:<ul>
<li>A critical update to a data structure was incomplete.</li>
<li>A file or network connection was opened but not closed.</li>
<li>A lock was acquired but not released.</li>
</ul>
</li>
<li>Indiscriminate recovery may cause bugs to go unnoticed. For example, a crash is replaced with a line in a log file.</li>
</ul>
<p>Recovering from a panic within the same package simplifies the handling of complex or unexpected errors. However, there is a general rule of exceptions:</p>
<ol>
<li>You should not attempt to recover from another package's panic. Public APIs should report failures as errors.</li>
<li>You should not recover from a panic that may pass through a function you do not maintain, such as a caller-provided callback, since you cannot reason about its safety.</li>
</ol>
<p>For example, the <code>net/http</code> package provides a web server that dispatches incoming requests to user-provided handler functions. Rather than allowing a panic in one of these handlers kill the process, the server calls <code>recover</code>, prints a stack trace, and continues serving. This is convenient in practice, but it does risk leaking resources or leaving the failed handler in an unspecified state that could lead to other problems.</p>
<p>For all the above reasons, it's safest to recover only from panics that were intended to be recovered from, which should be rare. This can be achieved by using a distinct, unexported type for the panic value and testing whether the value returned by recover has that type. If so, we report the panic as an ordinary error; if not, we call panic with the same value to resume the state of panic.</p>
<div class="codehilite"><pre><span class="c1">// soleTitle returns the text of the first non-empty title element</span>
<span class="c1">// in doc, and an error if there was not exactly one.</span>
<span class="kd">func</span> <span class="nx">soleTitle</span><span class="p">(</span><span class="nx">doc</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">(</span><span class="nx">title</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">type</span> <span class="nx">bailout</span> <span class="kd">struct</span><span class="p">{}</span>

    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">p</span> <span class="p">{</span>
        <span class="k">case</span> <span class="kc">nil</span><span class="p">:</span>
            <span class="c1">// no panic</span>
        <span class="k">case</span> <span class="nx">bailout</span><span class="p">{}:</span>
            <span class="c1">// &quot;expected&quot; panic</span>
            <span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;multiple title elements&quot;</span><span class="p">)</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="nb">panic</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// unexpected panic; carry on panicking</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="c1">// Bail out of recursion if we find more than one non-empty title.</span>
    <span class="nx">forEachNode</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="s">&quot;title&quot;</span> <span class="o">&amp;&amp;</span>
            <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">title</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
                <span class="nb">panic</span><span class="p">(</span><span class="nx">bailout</span><span class="p">{})</span> <span class="c1">// multiple title elements</span>
            <span class="p">}</span>
            <span class="nx">title</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">.</span><span class="nx">Data</span>
        <span class="p">}</span>
    <span class="p">},</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">title</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;no title element&quot;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">title</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>


<p>The deferred handler function calls <code>recover</code>, checks the panic value, and reports an ordinary error if the value was <code>bailout{}</code>. All other non-nil values indicate an unexpected panic, in which case the handler calls panic with that value, undoing the effect of recover and resuming the original state of panic. [p153]</p>
<p>From some conditions there is no recovery. For example, running out of memory causes the Go runtime to terminate the program with a fatal error.</p>
<h3 id="doubts-and-solution">Doubts and Solution</h3>
<h4 id="verbatim">Verbatim</h4>
<h5 id="p131-on-error-handling"><strong>p131 on error handling</strong></h5>
<blockquote>
<p>After checking an error, failure is usually dealt with before success.</p>
</blockquote>
<p><span class="text-danger">Question</span>: What does it mean exactly?</p>
<h5 id="p148-on-panic"><strong>p148 on panic</strong></h5>
<blockquote>
<p>During a typical panic, normal execution stops, all deferred function calls in that goroutine are executed, and the program crashes with a log message.</p>
</blockquote>
<p><span class="text-danger">Question</span>: From this text, does it mean that all functions in Go are "goroutines"?</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>