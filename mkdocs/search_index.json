{
    "docs": [
        {
            "location": "/", 
            "text": "Shichao's Notes\n\n\nThis site documents reading notes of the following books. Each chapter is organized as a single page; the included sections are noted with major concepts, along with personal doubts (with possible solutions figured out afterwards) and summary.\n\n\nReading Notes\n\n\nAdvanced Programming in the UNIX Environment, 3rd Edition\n\n\nby W. Richard Stevens and Stephen A. Rago\n\n\n\n\nUNIX System Overview\n\n\nUNIX Standardization and Implementations\n\n\nFile I/O\n\n\nFiles and Directories\n\n\nStandard I/O Library\n\n\nSystem Data Files and Information\n\n\nProcess Environment\n\n\nProcess Control\n\n\n\n\nUnderstanding the Linux Kernel, Third Edition\n\n\nby Daniel P. Bovet and Marco Cesati\n\n\n\n\nIntroduction\n\n\nMemory Addressing\n\n\n\n\nUnix Network Programming, Volume 1: The Sockets Networking API (3rd Edition)\n\n\nby W. Richard Stevens and Bill Fenner\n\n\n\n\nIntroduction\n\n\nThe Transport Layer: TCP, UDP, and SCTP\n\n\nSockets Introduction\n\n\n\n\nTCP/IP Illustrated, Volume 1: The Protocols (2nd Edition)\n\n\nby Kevin R. Fall and W. Richard Stevens\n\n\n\n\nIntroduction\n\n\nThe Internet Address Architecture\n\n\n\n\nCCENT/CCNA ICND1 640-822 Official Cert Guide, Third Edition\n\n\n\n\nNetworking Fundamentals\n\n\n\n\nCCNA ICND2 Official Exam Certification Guide, Second Edition\n\n\n\n\nLAN Switching\n\n\n\n\nHacking: The Art of Exploitation, 2nd Edition\n\n\nby Jon Erickson \n\n\n\n\nIntroduction (skipped)\n\n\nProgramming\n\n\n\n\nLearning Notes\n\n\nProgramming Languages\n\n\n\n\nGolang\n\n\nBash\n\n\nC\n\n\n\n\nSoftware and Technologies\n\n\n\n\nNginx\n\n\nIptables\n\n\nVim", 
            "title": "Home"
        }, 
        {
            "location": "/#shichaos-notes", 
            "text": "This site documents reading notes of the following books. Each chapter is organized as a single page; the included sections are noted with major concepts, along with personal doubts (with possible solutions figured out afterwards) and summary.  Reading Notes  Advanced Programming in the UNIX Environment, 3rd Edition  by W. Richard Stevens and Stephen A. Rago   UNIX System Overview  UNIX Standardization and Implementations  File I/O  Files and Directories  Standard I/O Library  System Data Files and Information  Process Environment  Process Control   Understanding the Linux Kernel, Third Edition  by Daniel P. Bovet and Marco Cesati   Introduction  Memory Addressing   Unix Network Programming, Volume 1: The Sockets Networking API (3rd Edition)  by W. Richard Stevens and Bill Fenner   Introduction  The Transport Layer: TCP, UDP, and SCTP  Sockets Introduction   TCP/IP Illustrated, Volume 1: The Protocols (2nd Edition)  by Kevin R. Fall and W. Richard Stevens   Introduction  The Internet Address Architecture   CCENT/CCNA ICND1 640-822 Official Cert Guide, Third Edition   Networking Fundamentals   CCNA ICND2 Official Exam Certification Guide, Second Edition   LAN Switching   Hacking: The Art of Exploitation, 2nd Edition  by Jon Erickson    Introduction (skipped)  Programming   Learning Notes  Programming Languages   Golang  Bash  C   Software and Technologies   Nginx  Iptables  Vim", 
            "title": "Shichao's Notes"
        }, 
        {
            "location": "/apue/ch1/", 
            "text": "Chapter 1. UNIX System Overview\n\n\nThis chapter gives basic Unix system concepts that are familiar to system administrators.\n\n\nSystem Calls and Library Functions\n\n\n\n\nLinux 3.2.0 has 380 system calls and FreeBSD 8.0 has over 450\n\n\nEach system call has a function of the same name in the standard C library\n\n\nAn application can either make a system call or call a library routine", 
            "title": "Chapter 1. UNIX System Overview"
        }, 
        {
            "location": "/apue/ch2/", 
            "text": "Chapter 2. UNIX Standardization and Implementations\n\n\nThis chapter discusses Unix standards, specifications and implementations.\n\n\nUNIX Standardization\n\n\n\n\nISO C\n\n\nIEEE POSIX\n\n\nSingle UNIX Specification (SUS): superset of the POSIX.1 standard\n\n\n\n\nLimits\n\n\n\n\nCompile-time limits\n\n\nRuntime limits", 
            "title": "Chapter 2. UNIX Standardization and Implementations"
        }, 
        {
            "location": "/apue/ch3/", 
            "text": "Chapter 3. File I/O\n\n\nThis chapter discusses unbuffered I/O, which are not part of ISO C but are part of POSIX.1 and the Single UNIX Specification.\n\n\nFile Descriptors\n\n\n\n\nAll open files are referred to by file descriptors\n\n\nNon-negative integer\n\n\nRange from 0 to \nOPEN_MAX - 1\n. With FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10, the limit is essentially infinite, bounded by the amount of memory on the system, the size of an integer, and any hard and soft limits configured by the system administrator.\n\n\n\n\nopen\n and \nopenat\n Functions\n\n\n\n\n\noflag\n argument is formed by ORing one or more of the following constants from \nfcntl.h\n [p62]:\n\n\nRequired:\n\n\n\n\nO_RDONLY\n\n\nO_WRONLY\n\n\nO_RDWR\n\n\nO_EXEC\n\n\nO_SEARCH\n: Open for search only (applies to directories).\n\n\n\n\nOptional:\n\n\n\n\nO_APPEND\n\n\nO_CLOEXEC\n: Set the \nFD_CLOEXEC\n file descriptor flag\n\n\nO_CREAT\n: Create the file if it doesn\u2019t exist\n\n\nO_DIRECTORY\n: Generate an error if \nO_CREAT\n is also specified and the file already exists. This test for whether the file already exists and the creation of the file if it doesn\u2019t exist is an atomic operation\n\n\nO_EXCL\n\n\nO_NOCTTY\n\n\nO_NOFOLLOW\n\n\nO_NONBLOCK\n\n\nO_SYNC\n: Have each \nwrite\n wait for physical I/O to complete\n\n\nO_TRUNC\n\n\nO_TTY_INIT\n\n\nO_DSYNC\n\n\nO_RSYNC\n\n\n\n\nTOCTTOU\n\n\nopenat\n, for example, provides a way to avoid \ntime-of-check-to-time-of-use\n (TOCTTOU) errors. A program is vulnerable if it makes two file-based function calls where the second call depends on the results of the first call (two calls are not atomic).\n\n\nFilename and Pathname Truncation\n\n\nMost modern file systems support a maximum of 255 characters for filenames.\n\n\ncreat\n Function\n\n\n\n\n\nThis function is equivalent to:\n\n\nopen(path, O_WRONLY | O_CREAT | O_TRUNC, mode);\n\n\n\n\nWith \ncreat\n, the file is opened only for writing. To read and write a file, use [p66]:\n\n\nopen(path, O_RDWR | O_CREAT | O_TRUNC, mode);\n\n\n\n\nclose\n Function\n\n\n\n\n\nWhen a process terminates, all of its open files are closed automatically by the kernel. Many programs take advantage of this fact and don\u2019t explicitly close open files.\n\n\nlseek\n Function\n\n\nEvery open file has a \"current file offset\", normally a non-negative integer that measures the number of bytes from the beginning of the file.\n\n\n\n\n\nThe \nwhence\n argument can be:\n\n\n\n\nSEEK_SET\n: the file\u2019s offset is set to \noffset\n bytes from the beginning of the file\n\n\nSEEK_CUR\n: the file\u2019s offset is set to its current value plus the \noffset\n. The \noffset\n can be positive or negative.\n\n\nSEEK_END\n: the file\u2019s offset is set to the size of the file plus the \noffset\n. The \noffset\n can be positive or negative.\n\n\n\n\nTo determine the current offset, \nseek zero bytes from the current position\n:\n\n\noff_t currpos;\ncurrpos = lseek(fd, 0, SEEK_CUR);\n\n\n\n\nThis technique (above code) can also be used to determine if a file is capable of seeking. If the file descriptor refers to a pipe, FIFO, or socket, \nlseek\n sets \nerrno\n to \nESPIPE\n and returns \u22121.\n\n\n\n\nNegative offsets are possible for certain devices, but for regular files, the offset must be non-negative.\n\n\nlseek\n only records the current file offset within the kernel and does not cause any I/O to take place. This offset is then used by the next read or write operation.\n\n\nHole in a file: file\u2019s offset can be greater than the file\u2019s current size, in which case the next \nwrite\n to the file will extend the file. This creates a hole in the file.\n\n\nBytes in the hole (bytes that have not been writen) are read back as 0. \n\n\nA hole in a file isn\u2019t required to have storage backing it on disk.\n\n\n\n\n\n\n\n\nread\n Function\n\n\n\n\n\n\n\nbuf\n: type \nvoid *\n is used for generic pointers.\n\n\nReturn value is required to be a signed integer (\nssize_t\n) to return a positive byte count, 0 (for end of file), or \u22121 (for an error).\n\n\n\n\nSeveral cases in which the number of bytes actually read is less than the amount requested:\n\n\n\n\nRegular file: if the end of file is reached before the requested number of bytes has been read.\n\n\nTerminal device: up to one line is read at a time\n\n\nNetwork: buffering within the network may cause less than the requested amount to be returned\n\n\nPipe or FIFO: if the pipe contains fewer bytes than requested, \nread\n will return only what is available\n\n\nRecord-oriented device\n\n\nInterrupted by a signal and a partial amount of data has already been read\n\n\n\n\nwrite\n Function\n\n\n\n\n\nThe return value is usually equal to the \nnbytes\n argument; otherwise, an error has occurred. \n\n\nCommon causes for a \nwrite\n error: \n\n\n\n\nFilling up a disk\n\n\nExceeding the file size limit for a given process\n\n\n\n\nFor a regular file, the write operation starts at the file\u2019s current offset. If the \nO_APPEND\n option was specified when the file was opened, the file\u2019s offset is set to the current end of file before each write operation. After a successful write, the file\u2019s offset is incremented by the number of bytes actually written.\n\n\nI/O Efficiency\n\n\n\n\nmycat.c\n\n\n\n\n#include \napue.h\n\n\n#define BUFFSIZE 4096\n\nint\nmain(void)\n{\n    int n;\n    char buf[BUFFSIZE];\n\n    while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) \n 0)\n    if (write(STDOUT_FILENO, buf, n) != n)\n        err_sys(\nwrite error\n);\n\n    if (n \n 0)\n        err_sys(\nread error\n);\n\n    exit(0);\n}\n\n\n\n\nCaveats of the above program:\n\n\n\n\nIt reads from standard input and writes to standard output, assuming that these have been set up by the shell before this program is executed.\n\n\nIt doesn\u2019t close the input file or output file. Instead, the program uses the feature of the \nUNIX kernel that closes all open file descriptors in a process when that process terminates.\n\n\nThis example works for both text files and binary files, since there is no difference between the two to the UNIX kernel.\n\n\n\n\nTiming results for reading with different buffer sizes (\nBUFFSIZE\n) on Linux:\n\n\n\n\nThe file was read using the program shown above, with standard output redirected to \n/dev/null\n. The file system used for this test was the Linux ext4 file system with 4,096-byte blocks (the \nst_blksize\n value is 4,096). This accounts for the minimum in the system time occurring at the few timing measurements starting around a \nBUFFSIZE\n of 4,096. Increasing the buffer size beyond this limit has little positive effect.\n\n\nMost file systems support some kind of read-ahead to improve performance. When sequential reads are detected, the system tries to read in more data than an application requests, assuming that the application will read it shortly. The effect of read-ahead can be seen in Figure 3.6, where the elapsed time for buffer sizes as small as 32 bytes is as good as the elapsed time for larger buffer sizes. [p73]\n\n\nFile Sharing\n\n\nThe UNIX System supports the sharing of open files among different processes.\n\n\n\n\nThe kernel uses three data structures to represent an open file, and the relationships among them determine the effect one process has on another with regard to file sharing.\n\n\n\n\nProcess table entry\n: every process has an entry in the process table. Each process table entry has a table of open file descriptors. Associated with each file descriptor are:\n\n\nFile descriptor flags\n (close-on-exec)\n\n\nPointer to a file table entry:\n\n\n\n\n\n\nFile table entry\n: the kernel maintains a file table for all open files. Each file table entry contains:\n\n\nFile status flags\n\n\nCurrent file offset\n\n\nPointer to the v-node table entry for the file\n\n\n\n\n\n\nv-node\n structure: contains information about the type of file and pointers to functions that operate on the file\n\n\nThis information is read from disk when the file is opened, so that all the pertinent information about the file is readily available\n\n\nv-node also contains the \ni-node\n for the file\n\n\nLinux has no v-node. Instead, a generic i-node structure is used. [p75] Instead of splitting the data structures into a v-node and an i-node, Linux uses a file system\u2013independent i-node and a file system\u2013dependent i-node. [p76]\n\n\n\n\n\n\n\n\nFigure 3.7\n shows a pictorial arrangement of these three tables for a single process that has two different files open: one file is open on standard input (file descriptor 0), and the other is open on standard output (file descriptor 1).\n\n\nIf two independent processes have the same file open, we could have the arrangement shown in Figure 3.8 (below).\n\n\n\n\nEach process that opens the file gets its own file table entry, but only a single v-node table entry is required for a given file. One reason \neach process gets its own file table entry is so that each process has its own current offset for the file.\n\n\nSpecific operations\n\n\n\n\nFile offset: After each \nwrite\n is complete, the current file offset in the file table entry is incremented by the number of bytes written. If this causes the current file offset to exceed the current file size, the current file size in the i-node table entry is set to the current file offset (the file is extended).\n\n\nO_APPEND\n: If a file is opened with the \nO_APPEND\n flag, a corresponding flag is set in the file status flags of the file table entry. Each time a \nwrite\n is performed for a file with this append flag set, the current file offset in the file table entry is first set to the current file size from the i-node table entry. Th is forces every \nwrite\n to be appended to the current end of file.\n\n\nlseek\n\n\nIf a file is positioned to its current end of file using \nlseek\n, all that happens is the current file offset in the file table entry is set to the current file size from the i-node table entry. \nThis is not the same as if the file was opened with the \nO_APPEND\n flag.\n\n\nThe \nlseek\n function modifies only the current file offset in the file table entry. No I/O takes place.\n\n\n\n\n\n\n\n\nIt is possible for more than one file descriptor entry to point to the same file table entry:\n\n\n\n\ndup\n\n\nfork\n: the parent and the child share the same file table entry for each open descriptor\n\n\n\n\nFile descriptor flags vs. the file status flags\n\n\n\n\nFile descriptor flags: apply only to a single descriptor in a single process\n\n\nFile status flags: apply to all descriptors in any process that point to the given file table entry\n\n\nfcntl\n is used to fetch and modify both of them\n\n\n\n\nAtomic Operations\n\n\nOlder versions of the UNIX System didn\u2019t support the \nO_APPEND\n option if a single process wants to append to the end of a file. The program would be:\n\n\nif (lseek(fd, 0L, 2) \n 0) /* position to EOF, 2 means SEEK_END */\n    err_sys(\nlseek error\n);\nif (write(fd, buf, 100) != 100) /* and write */\n    err_sys(\nwrite error\n);\n\n\n\n\nThis works fine for a single process, but problems arise if multiple processes (or multiple instances of the same program) use this technique to append to the same file. The problem here is that our logical operation of \"position to the end of file and write\" requires two separate function calls. The solution is to have the positioning to the current end of file and the write be an atomic operation with regard to other processes. Any operation that requires more than one function call cannot be atomic, as there is always the possibility that the kernel might temporarily suspend the process between the two function calls. The UNIX System provides an atomic way to do this operation if we set the \nO_APPEND\n flag when a file is opened. This causes the kernel to position the file to its current end of file before each \nwrite\n. We no longer have to call lseek before each \nwrite\n.\n\n\npread\n and \npwrite\n Functions\n\n\nThe Single UNIX Specification includes two functions that allow applications to seek and perform I/O atomically:\n\n\n\n\n\n\n\npread\n: equivalent to calling \nlseek\n followed by a call to \nread\n, with the following exceptions:\n\n\nThere is no way to interrupt the two operations that occur calling \npread\n.\n\n\nThe current file offset is not updated.\n\n\n\n\n\n\npwrite\n:  equivalent to calling lseek followed by a call to write, with similar exceptions to \npread\n.\n\n\n\n\nCreating a File\n\n\nAtomic operation\n\n\nWhen both of \nO_CREAT\n and \nO_EXCL\n options are specified, the \nopen\n will fail if the file already exists. The check for the existence of the file and the creation of the file was performed as an atomic operation.\n\n\nNon-atomic operation\n\n\nIf we didn\u2019t have this atomic operation, we might try:\n\n\nif ((fd = open(path, O_WRONLY)) \n 0) {\n    if (errno == ENOENT) {\n        if ((fd = creat(path, mode)) \n 0)\n            err_sys(\ncreat error\n);\n    } else {\n        err_sys(\nopen error\n);\n    }\n}\n\n\n\n\nThe problem occurs if the file is created by another process between the \nopen\n and the \ncreat\n. If the file is created by another process between these two function calls, and if that other process writes something to the file, that data is erased when this \ncreat\n is executed. Combining the test for existence and the creation into a single atomic operation avoids this problem.\n\n\nAtomic operation\n refers to an operation that might be composed of multiple steps. \nIf the operation is performed atomically, either all the steps are performed (on success) or none are performed (on failure). It must not be possible for only a subset of the steps to be performed.", 
            "title": "Chapter 3. File I/O"
        }, 
        {
            "location": "/apue/ch4/", 
            "text": "Chapter 4. Files and Directories\n\n\nThis chapter centers on I/O for regular files.\n\n\nrestrict\n keyword\n\n\nAdded in C99, \nrestrict\n keyword is used to tell the compiler which pointer references can be optimized, by indicating that the object to which the pointer refers is accessed in the function only via that pointer. [p26]\n\n\nstat\n, \nfstat\n, \nfstatat\n, and \nlstat\n Functions\n\n\n\n\n\n\n\nstat\n: returns a structure of information about the named file\n\n\nfstat\n: returns a structure of information about the given file descriptor\n\n\nlstat\n: similar to \nstat\n, returns information about the symbolic link, not the file referenced by the symbolic link\n\n\nfstatat\n:  return the file statistics for a pathname relative to an open directory represented by the fd argument; the flag argument controls whether symbolic links are followed\n\n\n\n\nThe \nbuf\n argument is a pointer to a \nstructure\n that we must supply. The functions fill in the structure.\n\n\nstruct stat {\n    mode_t    st_mode;\n    ino_t    st_ino;\n    dev_t    st_dev;\n    dev_t    st_rdev;\n    nlink_t    st_nlink;\n    uid_t    st_uid;\n    gid_t    st_gid;\n    off_t    st_size;\n    struct timespec    st_atim;\n    struct timespec    st_mtim;\n    struct timespec    st_ctim;\n    blksize_t    st_blksize;\n    blkcnt_t    st_blocks;\n};\n\n\n\n\ntimespec\n structure\n\n\nThe \ntimespec\n structure type defines time in terms of seconds and nanoseconds. It includes at least the following fields:\n\n\ntime_t tv_sec;\nlong tv_nsec;\n\n\n\n\nFile Types\n\n\n\n\nRegular file. All binary executable files conform to a format that allows the kernel to identify where to load a program\u2019s text and data.\n\n\nDirectory file. A file that contains the names of other files and pointers to information on these files. Any process that has read permission for a directory file can read the contents of the directory, but only the kernel can write directly to a directory file.\n\n\nBlock special file\n\n\nCharacter special file\n\n\nFIFO\n\n\nSocket\n\n\nSymbolic link\n\n\n\n\nThis program prints the type of file for each command-line argument.\n\n\n\n\nfiletype.c\n\n\n\n\nSet-User-ID and Set-Group-ID\n\n\nFile Access Permissions\n\n\n\n\nWhenever we want to open any type of file by name, we must have execute permission in each directory mentioned in the name, including the current directory, if it is implied. Read permission for a directory and execute permission for a directory mean different things. Read permission lets us read the directory, obtaining a list of all the filenames in the directory. Execute permission lets us pass through the directory when it is a component of a pathname that we are trying to access. [p100]\n\n\nWe cannot create a new file in a directory unless we have write permission and execute permission in the directory.\n\n\n\n\nOwnership of New Files and Directories\n\n\n\n\nThe user ID of a new file is set to the effective user ID of the process\n\n\nThe group ID of a new file can be the effective group ID of the process; or group ID of the directory in which the file is being created.\n\n\n\n\nFreeBSD 8.0 and Mac OS X 10.6.8 always copy the new file\u2019s group ID from the directory. \n\n\naccess\n and \nfaccessat\n Functions\n\n\n\n\n\nThese functions test accessibility based on the real user and group IDs.\n\n\nThe \nflag\n argument can be used to change the behavior of \nfaccessat\n. If the \nAT_EACCESS\n flag is set, the access checks are made using the effective user and group IDs.\n\n\n\n\naccess.c\n\n\n\n\numask\n Function\n\n\nThe Single UNIX Specification requires that the \numask\n command support a symbolic mode of operation. Unlike the octal format, the symbolic format specifies which permissions are to be allowed instead of which ones are to be denied.\n\n\n$ umask  # first print the current file mode creation mask\n002\n$ umask -S  # print the symbolic form\nu=rwx,g=rwx,o=rx\n$ umask 027  # print the symbolic form\n$ umask -S  # print the symbolic form\nu=rwx,g=rx,o=\n\n\n\n\nchmod\n, \nfchmod\n, and \nfchmodat\n Functions\n\n\n\n\n\nchmod\n automatically clears the following permission bits under the following conditions:\n\n\n\n\nSetting sticky bit on a regular file without superuser privileges (Solaris)\n\n\nIf the group ID of the new file does not equal either the effective group ID of the process or one of the process\u2019s supplementary group IDs and if the process does not have superuser privileges, then the set-group-ID bit is automatically turned off. On FreeBSD 8.0, Linux 3.2.0 and Mac OS X 10.6.8, if a process that does not have superuser privileges writes to a file, the set-user-ID and set-group-ID bits are automatically turned off.\n\n\n\n\nSticky Bit\n\n\nSticky Bit (\nS_ISVTX\n), or saved-text bit in the later versions of the UNIX System.\n\n\n\n\nOn file: only on a minority of systems\n\n\nOn directory: \n/tmp\n and \n/var/tmp\n\n\n\n\nchown\n, \nfchown\n, \nfchownat\n, and \nlchown\n Functions\n\n\n\n\n\n\n\nlchown\n and \nfchownat\n (with the \nAT_SYMLINK_NOFOLLOW\n flag set) change the owners of the symbolic link itself.\n\n\nfchown\n operates on a open file, it can\u2019t be used to change the ownership of a symbolic link.\n\n\n\n\nOnly the superuser can change the ownership of a file (FreeBSD 8.0, Linux 3.2.0, and Mac OS X 10.6.8)\n\n\nWhen \n_POSIX_CHOWN_RESTRICTED\n is in effect, a non-superuser can\u2019t change the user ID of your files; A nonsuperuser can change the group ID of files that he owns, but only to groups that he belongs to.\n\n\nFile Size\n\n\nThe \nst_size\n member of the stat structure contains the size of the file in bytes. This field is meaningful only for regular files, directories, and symbolic links.\n\n\nFreeBSD 8.0, Mac OS X 10.6.8, and Solaris 10 also define the file size for a pipe as the number of bytes that are available for reading from the pipe.\n\n\n\n\nFor a regular file, a file size of 0 is allowed. We\u2019ll get an end-of-file indication on the first read of the file. \n\n\nFor a directory, the file size is usually a multiple of a number, such as 16 or 512.\n\n\nFor a symbolic link, the file size is the number of bytes in the filename.\n\n\n\n\nMost contemporary UNIX systems provide two fields:\n\n\n\n\nst_blksize\n: preferred block size for I/O for the file\n\n\nst_blocks\n: actual number of 512-byte blocks that are allocated\n\n\n\n\nBe aware that different versions of the UNIX System use units other than 512-byte blocks for \nst_blocks\n. Use of this value is \nnonportable\n.\n\n\nHoles in a File\n\n\n$ ls -l core\n-rw-r--r-- 1 sar 8483248 Nov 18 12:18 core\n$ du -s core\n272 core\n\n\n\n\nFile Truncation\n\n\n\n\nThese two functions truncate an existing file to \nlength\n bytes. If the previous size of the file was greater than \nlength\n, the data beyond \nlength\n is no longer accessible. Otherwise, if the previous size was less than \nlength\n, the file size will increase and the data between the old end of file and the new end of file will read as 0 (a hole is probably created in the file).\n\n\nFile Systems\n\n\nMost UNIX file systems support \ncase-sensitive\n filenames. On Mac OS X, however, the HFS file system is \ncase-preserving\n with \ncase-insensitive\n comparisons.\n\n\n\n\n\n\nEvery i-node has a link count that contains the number of directory entries that point to it. Only when the link count (\nst_nlink\n) goes to 0 can the file be deleted.\n\n\nWith a symbolic link (file type \nS_IFLNK\n), the actual contents of the file (the data blocks) store the name of the file that the symbolic link points to.\n\n\nThe i-node contains all the information about the file: the file type, the file\u2019s access permission bits, the size of the file, pointers to the file\u2019s data blocks, and so on.\n\n\nOnly two items are stored in the directory entry: the filename and the i-node number. The data type for the i-node number is \nino_t\n.\n\n\n\n\nlink\n, \nlinkat\n, \nunlink\n, \nunlinkat\n, and \nremove\n Functions\n\n\n\n\n\nWhen a file is closed, the kernel first checks the count of the number of processes that have the file open. If this count has reached 0, the kernel then checks the link count; if it is 0, the file\u2019s contents are deleted.\n\n\nWhen the \nAT_REMOVEDIR\n flag is set, then the \nunlinkat\n function can be used to remove a directory, similar to using \nrmdir\n.\n\n\n\n\n\nrename\n and \nrenameat\n Functions\n\n\n\n\nSymbolic Links\n\n\nIt is possible to introduce loops into the file system by using symbolic links. Most functions that look up a pathname return an \nerrno\n of \nELOOP\n when this occurs.\n\n\nOn Linux, the \nftw\n and \nnftw\n functions record all directories seen and avoid processing a directory more than once, so they don\u2019t display this behavior.\n\n\n\n\nls -l\n\n\nls -F\n\n\n\n\n\n\n\nBecause the open function follows a symbolic link, we need a way to open the link itself and read the name in the link.\n\n\n\n\n\nThese functions combine the actions of \nopen\n, \nread\n, and \nclose\n.\n\n\nFile Times\n\n\n\n\n\n\n\n\nField\n\n\nDescription\n\n\nExample\n\n\nls(1) option\n\n\n\n\n\n\n\n\n\n\nst_atim\n\n\nlast-access time of file data\n\n\nread\n\n\n-u\n\n\n\n\n\n\nst_mtim\n\n\nlast-modification time of file data\n\n\nwrite\n\n\ndefault\n\n\n\n\n\n\nst_ctim\n\n\nlast-change time of i-node status\n\n\nchmod\n, \nchown\n\n\n-c\n\n\n\n\n\n\n\n\nThe system does not maintain the last-access time for an i-node. The functions \naccess\n and \nstat\n don\u2019t change any of the three times.\n\n\nfutimens\n, \nutimensat\n, and \nutimes\n Functions\n\n\n\n\n\nIn both functions, the first element of the times array argument contains the \naccess time\n, and the second element contains the \nmodification time\n.\n\n\n\n\n\nWe are unable to specify a value for the \nchanged-status time\n, \nst_ctim\n (the time the i-node was last changed), as this field is automatically updated when the \nutime\n function is called.\n\n\nmkdir\n, \nmkdirat\n, and \nrmdir\n Functions\n\n\n\n\n\nFor a directory, we normally want at least one of the execute bits enabled, to allow access to filenames within the directory.\n\n\nSolaris 10 and Linux 3.2.0 also have the new directory inherit the set-group-ID bit from the parent directory. Files created in the new directory will then inherit the group ID of that directory. With Linux, the file system implementation determines whether this behavior is supported. For example, the ext2, ext3, and ext4 file systems allow this behavior to be controlled by an option to the mount(1) command.\n\n\nReading Directories\n\n\n\n\n\nThe \ndirent\n structure defined in \n is implementation dependent, with at least the following two members:\n\n\n    ino_t  d_ino;                 /* i-node number */\n    char   d_name[];              /* null-terminated filename */\n\n\n\n\nThe \nDIR\n structure is an internal structure used by these seven functions to maintain information about the directory being read. The purpose of the DIR structure is similar to that of the \nFILE\n structure maintained by the standard I/O library,\n\n\n\n\nftw8.c\n\n\n\n\nchdir\n, \nfchdir\n, and \ngetcwd\n Functions\n\n\n\n\n\n\nDevice Special Files\n\n\n\n\nEvery file system is known by its \nmajor\n and \nminor\n device numbers, which are encoded in the primitive system data type \ndev_t\n.\n\n\nWe can usually access the major and minor device numbers through two macros defined by most implementations: \nmajor\n and \nminor\n.\n\n\n\n\nOn Linux 3.2.0, \ndev_t\n is a 64-bit integer, only 12 bits are used for the major number and 20 bits are used for the minor number. Linux defines these macros in \nsys/sysmacros.h\n, which is included by \nsys/types.h\n.\n\n\nThe \nst_dev\n value for every filename on a system is the device number of the file system containing that filename and its corresponding i-node.\n\n\nOnly character special files and block special files have an \nst_rdev\n value. This value contains the device number for the actual device.\n\n\n\n\nDoubts and Solutions\n\n\nVerbatim\n\n\nSection 4.21 on \nrmdir\n [p130]:\n\n\n\n\nIf the link count of the directory becomes 0 with this call, and if no other process has the directory open, then the space occupied by the directory is freed. If one or more processes have the directory open when the link count reaches 0, the last link is removed and the dot and dot-dot entries are removed before this function returns. Additionally, no new files can be created in the directory.\n\n\n\n\nDoes \"link count\" here mean number of entries (except dot and dot-dot)? Otherwise, this contradicts  \"any leaf directory (a directory that does not contain any other directories) always has a link count of 2\" in section 4.14 on page 115.", 
            "title": "Chapter 4. Files and Directories"
        }, 
        {
            "location": "/apue/ch5/", 
            "text": "Chapter 5. Standard I/O Library\n\n\nThe standard I/O library handles such details as buffer allocation and performing I/O in optimal-sized chunks.\n\n\nStreams and \nFILE\n Objects\n\n\nStandard I/O file streams can be used with both \nsingle-byte\n and \nmultibyte\n (\"wide\") character sets. A stream\u2019s orientation determines whether the characters that are read and written are single byte or multibyte. \n\n\n\n\nThis book deals only with \nbyte-oriented\n (single byte) streams.\n\n\nThis book refers to a pointer to a \nFILE\n object, the type \nFILE *\n, as a \nfile pointer\n.\n\n\n\n\nStandard Input, Standard Output, and Standard Error\n\n\nThree streams are predefined and automatically available to a process. They refer to file descriptors \nSTDIN_FILENO\n, \nSTDOUT_FILENO\n, and \nSTDERR_FILENO\n (defined in \nunistd.h\n) [p9]. These three standard I/O streams are referenced through the predefined file pointers \nstdin\n, \nstdout\n,and \nstderr\n(defined in \nstdio.h\n).\n\n\nBuffering\n\n\n\n\nFully buffered\n\n\nLine buffered\n\n\nUnbuffered\n\n\n\n\nMost implementations default to the following types of buffering:\n\n\n\n\nStandard error is always unbuffered.\n\n\nAll other streams are line buffered if they refer to a terminal device; otherwise, they are fully buffered.\n\n\n\n\n\n\n\n\n\nsetbuf\n: \nbuf\n must point to a buffer of length \nBUFSIZ\n, a constant defined in \nstdio.h\n\n\nsetvbuf\n: type of buffering is specified with \n_IOFBF\n, \n_IOLBF\n, \n_IONBF\n.\n\n\n\n\nThe GNU C librarys use the value from the \nst_blksize\n member of the \nstat\n structure to determine the optimal standard I/O buffer size.\n\n\nThe \nfflush\n function causes any unwritten data for the stream to be passed to the kernel. If \nfp\n is \nNULL\n, \nfflush\n causes all output streams to be flushed.\n\n\nOpening a Stream\n\n\n\n\n\n\n\nfdopen\n function is often used with descriptors returned by the functions that create pipes and network communication channels, because these special types of files cannot be opened with the \nfopen\n function.\n\n\n\n\ntype\n argument has 15 values as specifed by ISO C:\n\n\n\n\n\n\n\n\ntype\n\n\nDescription\n\n\nopen\n(2) Flags\n\n\n\n\n\n\n\n\n\n\nr\n, \nrb\n\n\nopen for reading\n\n\nO_RDONLY\n\n\n\n\n\n\nw\n, \nwb\n\n\ntruncate to 0 length or create for writing\n\n\nO_WRONLY\nO_CREAT\nO_TRUNC\n\n\n\n\n\n\na\n, \nab\n\n\nappend; open for writing at end of file, or create for writing\n\n\nO_WRONLY\nO_CREAT\nO_APPEND\n\n\n\n\n\n\nr+\n, \nr+b\n, \nrb+\n\n\nopen for reading and writing\n\n\nO_RDWR\n\n\n\n\n\n\nw+\n, \nw+b\n, \nwb+\n\n\ntruncate to 0 length or create for reading and writing\n\n\nO_RDWR\nO_CREAT\nO_TRUNC\n\n\n\n\n\n\na+\n, \na+b\n, \nab+\n\n\nopen or create for reading and writing at end of file\n\n\nO_RDWR\nO_CREAT\nO_APPEND\n\n\n\n\n\n\n\n\nCharacter \nb\n allows the standard I/O system to differentiate between a text file and a binary file. The UNIX kernel doesn\u2019t differentiate between these types of files, thus character \nb\n has no effect.\n\n\n\n\nWrite\n: The \nfdopen\n function cannot truncate any file it opens for writing\n\n\nAppend\n: each write will take place at the then current end of file. If multiple processes open the same file with the standard I/O append mode, the data from each process will be correctly written to the file\n\n\nRead and write\n (\n+\n sign in type): Output cannot be directly followed by input without an intervening \nfflush\n, \nfseek\n, \nfsetpos\n, or \nrewind\n. Input cannot be directly followed by output without an intervening \nfseek\n, \nfsetpos\n, or \nrewind\n, or an input operation that encounters an end of file.\n\n\n\n\n\n\n\nAn open stream is closed by calling \nfclose\n:\n\n\n\n\nAny buffered output data is flushed before the file is closed\n\n\nAny input data that may be buffered is discarded\n\n\n\n\nWhen a process terminates normally, either by calling the exit function directly or by returning from the main function, all standard I/O streams with unwritten buffered data are flushed and all open standard I/O streams are closed.\n\n\nReading and Writing a Stream\n\n\nUnformatted I/O:\n\n\n\n\nCharacter-at-a-time I/O\n\n\nLine-at-a-time I/O: \nfgets\n and \nfputs\n. Each line is terminated with a newline character.\n\n\nDirect I/O (binary I/O, object-at-a-time I/O, record-oriented I/O, or structure-oriented I/O): \nfread\n and \nfwrite\n. For each I/O operation, we read or write some number of objects, where each object is of a specified size\n\n\n\n\nInput Functions\n\n\n\n\n\n\n\nThe function \ngetchar\n is defined to be equivalent to \ngetc(stdin)\n. \n\n\ngetc\n can be implemented as a macro, whereas \nfgetc\n cannot be implemented as a macro.\n\n\nThese three functions return the next character as an \nunsigned char\n converted to an \nint\n. Thus, all possible character values can be returned, along with an indication that either an error occurred or the end of file has been encountered. The constant EOF in \nstdio.h\n is required to be a negative value. Its value is often \u22121.\n\n\n\n\nThese functions return the same value whether an error occurs or the end of file is reached. To distinguish between the two, we must call either \nferror\n or \nfeof\n:\n\n\n\n\n\nIn most implementations, two flags are maintained for each stream in the \nFILE\n object:\n\n\n\n\nAn error flag\n\n\nAn end-of-file flag\n\n\n\n\nBoth flags are cleared by calling \nclearerr\n.\n\n\nPushback\n\n\nAfter reading from a stream, we can push back characters by calling \nungetc\n.\n\n\n\n\n\n\n\nThe characters that are pushed back are returned by subsequent reads on the stream in reverse order of their pushing.\n\n\nThe character that is pushed back does not have to be the same character that was read.\n\n\nWhen characters are pushed back with \nungetc\n, they are not written back to the underlying file or device. Instead, they are kept incore in the standard I/O library\u2019s buffer for the stream. EOF cannot be pushed back.\n\n\nUsed for peeking characters.\n\n\n\n\nOutput Functions\n\n\n\n\n\n\n\nputchar(c)\n is equivalent to \nputc(c, stdout)\n\n\nputc\n can be implemented as a macro, whereas \nfputc\n cannot be implemented as a macro.\n\n\n\n\nLine-at-a-Time I/O\n\n\n\n\n\n\n\ngets\n function reads from standard input, whereas \nfgets\n reads from the specified stream.\n\n\nfgets\n: reads \nn - 1\n characters (including the newline) or partial line if longer than \nn - 1\n into the buffer, then the buffer is (always) null terminated.\n\n\ngets\n: should never be used. Without specifying buffer size, this may cause buffer to overflow if the line is longer than the buffer, writing over whatever happens to follow the buffer in memory. \ngets\n is marked as an obsolescent interface in SUSv4 and has been omitted from the latest version of the ISO C standard\n\n\n\n\n\n\n\n\n\nfputs\n: writes the null-terminated string to the specified stream without writing the null byte\n\n\nputs\n: writes the null-terminated string to the standard output without writing the null byte, and then writes a newline character to the standard output. \nputs\n should be avoided being used to prevent having to remember whether it appends a newline.\n\n\n\n\nStandard I/O Efficiency\n\n\n\n\n\n\n\n\nFunction\n\n\nUser CPU (seconds)\n\n\nSystem CPU (seconds)\n\n\nClock time (seconds)\n\n\nBytes of program text\n\n\n\n\n\n\n\n\n\n\nbest time from Figure 3.6\n\n\n0.05\n\n\n0.29\n\n\n3.18\n\n\n\n\n\n\n\n\nfgets\n, \nfputs\n\n\n2.27\n\n\n0.30\n\n\n3.49\n\n\n143\n\n\n\n\n\n\ngetc\n, \nputc\n\n\n8.45\n\n\n0.29\n\n\n10.33\n\n\n114\n\n\n\n\n\n\nfgetc\n, \nfputc\n\n\n8.16\n\n\n0.40\n\n\n10.18\n\n\n114\n\n\n\n\n\n\nsingle byte time from Figure 3.6\n\n\n134.61\n\n\n249.94\n\n\n394.95\n\n\n\n\n\n\n\n\n\n\n\n\nOne advantage of using the standard I/O routines is that we don\u2019t have to worry about buffering or choosing the optimal I/O size.\n\n\nUsually, \ngetc\n and \nputc\n are implemented as macros, but in the GNU C library implementation the macro simply expands to a function call.\n\n\nThe line-at-a-time functions are implemented using \nmemccpy(3)\n. Often, the memccpy function is implemented in assembly language instead of C, for efficiency.\n\n\n\n\nBinary I/O\n\n\nIf doing binary I/O, we often want to read or write an entire structure at a time. There are problems with the previous functions:\n\n\n\n\ngetc\n, \nputc\n: we have to loop through the entire structure one byte a time\n\n\nfputs\n: stops writing when it hits a null byte\n\n\nfgets\n: won't work correctly on input if any data bytes are null or newlines\n\n\n\n\n\n\n\nThese functions have two common uses:\n\n\nRead or write a binary array (e.g write elements 2 through 5 of a floating-point array):\n\n\nfloat   data[10];\n\nif (fwrite(\ndata[2], sizeof(float), 4, fp) != 4)\n    err_sys(\nfwrite error\n);\n\n\n\n\nRead or write a structure:\n\n\nstruct {\n    short  count;\n    long   total;\n    char   name[NAMESIZE];\n} item;\n\nif (fwrite(\nitem, sizeof(item), 1, fp) != 1)\n    err_sys(\nfwrite error\n);\n\n\n\n\n\n\nfread\n: return value can be less than \nnobj\n if an error occurs or if the end of file is encountered\n\n\nfwrite\n: if the return value is less than the requested \nnobj\n, an error has occurred\n\n\n\n\nThese two functions won't work on different systems (sometimes even on the same system):\n\n\n\n\nThe offset of a member within a structure can differ between compilers and systems because of different \nalignment requirements\n. Even on a single system, the binary layout of a structure can differ, depending on compiler options. [p157]\n\n\nThe binary formats used to store multibyte integers and floating-point values differ among machine architectures\n\n\n\n\nPositioning a Stream\n\n\n\n\n\n\n\nftell\n: return file's position indicator (bytes from the beginning of the file)\n\n\nfseek\n:\n\n\nBinary file: \nwhence\n can be \nSEEK_SET\n, \nSEEK_CUR\n, and \nSEEK_END\n\n\nText file: \nwhence\n has to be \nSEEK_SET\n; \noffset\n can only be 0 (rewind the file to its beginning) or a value that was returned by \nftell\n for that file.\n\n\n\n\n\n\nrewind\n: set the stream to the beginning of the file\n\n\n\n\n\n\n\n\n\n\nFormatted I/O\n\n\nFormatted Output\n\n\n\n\n\n\n\nsprintf\n: automatically appends a null byte at the end of the array, but this null byte is not included in the return value. \nsprintf\n is possible to overflow the buffer.\n\n\nsnprintf\n: returns the number of characters that would have been written to the buffer had it been big enough. If \nsnprintf\n returns a positive value less than the buffer size n, then the output was not truncated.\n\n\n\n\nConversion specification\n\n\n%[flags][fldwidth][precision][lenmodifier]convtype\n\n\n\n\n\n\n\n\nFlag\n\n\n\n\n\n\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n\u2019\n\n\n(apostrophe) format integer with thousands grouping characters\n\n\n\n\n\n\n-\n\n\nleft-justify the output in the field\n\n\n\n\n\n\n+\n\n\nalways display sign of a signed conversion\n\n\n\n\n\n\n(space)\n\n\nprefix by a space if no sign is generated\n\n\n\n\n\n\n#\n\n\nconvert using alternative form (include 0x prefix for hexadecimal format, for example)\n\n\n\n\n\n\n0\n\n\nprefix with leading zeros instead of padding with spaces\n\n\n\n\n\n\n\n\n\n\n\n\nfldwidth\n specifies a minimum field width for the conversion\n\n\n\n\nprecision\n specifies the minimum number of digits to appear for integer conversions, the minimum number of digits to appear to the right of the decimal point for floating-point conversions, or the maximum number of bytes for string conversions\n\n\n\n\nlenmodifier\n pecifies the size of the argument\n\n\n\n\n\n\n\n\nLength modifier\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nhh\n\n\nsigned or unsigned \nchar\n\n\n\n\n\n\nh\n\n\nsigned or unsigned \nshort\n\n\n\n\n\n\nl\n\n\nsigned or unsigned \nlong\n or wide character\n\n\n\n\n\n\nll\n\n\nsigned or unsigned \nlong\n \nlong\n\n\n\n\n\n\nj\n\n\nintmax_t\n or \nuintmax_t\n\n\n\n\n\n\nz\n\n\nsize_t\n\n\n\n\n\n\nt\n\n\nptrdiff_t\n\n\n\n\n\n\nL\n\n\nlong double\n\n\n\n\n\n\n\n\n\n\n\n\nconvtype\n is required.\n\n\n\n\n\n\n\n\n\n\n\n\nConversion type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nd\n,\ni\n\n\nsigned decimal\n\n\n\n\n\n\no\n\n\nunsigned octal\n\n\n\n\n\n\nu\n\n\nunsigned decimal\n\n\n\n\n\n\nx\n,\nX\n\n\nunsigned hexadecimal\n\n\n\n\n\n\nf\n,\nF\n\n\ndouble floating-point number\n\n\n\n\n\n\ne\n,\nE\n\n\ndouble floating-point number in exponential format\n\n\n\n\n\n\ng\n,\nG\n\n\ninterpreted as \nf\n, \nF\n, \ne\n, or \nE\n, depending on value converted\n\n\n\n\n\n\na\n,\nA\n\n\ndouble floating-point number in hexadecimal exponential format\n\n\n\n\n\n\nc\n\n\ncharacter (with \nl\n length modifier, wide character)\n\n\n\n\n\n\ns\n\n\nstring (with \nl\n length modifier, wide character string)\n\n\n\n\n\n\np\n\n\npointer to a void\n\n\n\n\n\n\nn\n\n\npointer to a signed integer into which is written the number of characters written so far\n\n\n\n\n\n\n%\n\n\na \n%\n character\n\n\n\n\n\n\nC\n\n\nwide character (XSI option, equivalent to \nlc\n)\n\n\n\n\n\n\nS\n\n\nwide character string (XSI option, equivalent to \nls\n)\n\n\n\n\n\n\n\n\nWith the normal conversion specification, conversions are applied to the arguments in the order they appear after the format argument. An alternative conversion specification syntax allows the arguments to be named explicitly with the sequence \n%n$\n representing the \nn\nth argument.\n\n\nThe following five variants of the printf family are similar to the previous five, but the variable argument list (\n...\n) is replaced with \narg\n.\n\n\n\n\n\nFormatted Output\n\n\n\n\n\nExcept for the conversion specifications and white space, other characters in the format have to match the input. If a character doesn\u2019t match, processing stops, leaving the remainder of the input unread.\n\n\nConversion specification\n\n\n%[*][fldwidth][m][lenmodifier]convtype\n\n\n\n\n\n\n*\n (leading asterisk) causes the result not stored in an argument\n\n\n\n\nm\n: \nassignment-allocation character\n, used with the \n%c\n, \n%s\n, and \n%[\n to force a memory  buffer to be allocated to hold the converted string. The caller is responsible for freeing the buffer.\n\n\n\n\n\n\nconvtype\n\n\n\n\n\n\n\n\n\n\n\n\nConversion type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nd\n\n\nsigned decimal, base 10\n\n\n\n\n\n\ni\n\n\nsigned decimal, base determined by format of input\n\n\n\n\n\n\no\n\n\nunsigned octal (input optionally signed)\n\n\n\n\n\n\nu\n\n\nunsigned decimal, base 10 (input optionally signed)\n\n\n\n\n\n\nx\n,\nX\n\n\nunsigned hexadecimal (input optionally signed)\n\n\n\n\n\n\na\n,\nA\n,\ne\n,\nE\n,\nf\n,\nF\n,\ng\n,\nG\n\n\nfloating-point number\n\n\n\n\n\n\nc\n\n\ncharacter (with \nl\n length modifier, wide character)\n\n\n\n\n\n\ns\n\n\nstring (with \nl\n length modifier, wide character string)\n\n\n\n\n\n\n[\n\n\nmatches a sequence of listed characters, ending with \n]\n\n\n\n\n\n\n[\u02c6\n\n\nmatches all characters except the ones listed, ending with \n]\n\n\n\n\n\n\np\n\n\npointer to a void\n\n\n\n\n\n\nn\n\n\npointer to a signed integer into which is written the number of characters read so far\n\n\n\n\n\n\n%\n\n\na \n%\n character\n\n\n\n\n\n\nC\n\n\nwide character (XSI option, equivalent to \nlc\n)\n\n\n\n\n\n\nS\n\n\nwide character string (XSI option, equivalent to \nls\n)\n\n\n\n\n\n\n\n\nImplementation Details\n\n\n\n\n\nEach standard I/O stream has an associated file descriptor, and we can obtain the descriptor for a stream by calling \nfileno\n.\n\n\n\n\nFILE\n implementaion in GNU C.\n\n\nbuf.c\n (Figure 5.11): print buffering for various standard I/O streams\n\n\n\n\nResult on OS X 10.10:\n\n\n$ ./buf\nenter any character\n\none line to standard error\nstream = stdin, line buffered, buffer size = 4096\nstream = stdout, line buffered, buffer size = 4096\nstream = stderr, unbuffered, buffer size = 1\nstream = /etc/passwd, fully buffered, buffer size = 4096\n\n$ ./buf \n /etc/group \n std.out 2\n std.err\n$ cat std.out \nenter any character\nstream = stdin, fully buffered, buffer size = 4096\nstream = stdout, fully buffered, buffer size = 4096\nstream = stderr, unbuffered, buffer size = 1\nstream = /etc/passwd, fully buffered, buffer size = 4096\n$ cat std.err \none line to standard error\n\n\n\n\nTemporary Files\n\n\n\n\n\n\n\ntmpnam\n: generates a string that is a valid pathname that does not match any existing file. This function generates a different pathname each time it is called, up to \nTMP_MAX\n times. \n\n\nWhen \nptr\n is \nNULL\n: pathname is stored in a static area\n\n\nWhen \nptr\n is not \nNULL\n: it is assumed that it points to an array of at least \nL_tmpnam\n characters. The generated pathname is stored in this array, and \nptr\n is returned as the value of the function.\n\n\n\n\n\n\ntmpfile\n: creates a temporary binary file (type \nwb+\n) that is automatically removed when it is closed or on program termination.\n\n\n\n\n\n\n\n\n\nmkdtemp\n: creates a uniquely named directory\n\n\nmkstemp\n: creates a uniquely named regular file\n\n\ntemplate\n: a pathname whose last six characters are set to \nXXXXXX\n (\n/tmp/dirXXXXXX\n)\n\n\n\n\nUnlike \ntmpfile\n, the temporary file created by \nmkstemp\n is not removed automatically for us.\n\n\nThe \ntmpfile\n and \nmkstemp\n functions should be used instead of \ntmpnam\n. [p169]\n\n\nExample:\n\n\n\n\napue_stdio_mkstemp.c\n: the array variable is allocated on the stacl. For a pointer to a string literal, only the pointer itself resides on the stack; the (constant) string is stored in the read-only segment of the program.\n\n\n\n\nMemory Streams\n\n\nMemory streams\n are standard I/O streams for which there are no underlying files, although they are still accessed with \nFILE\n pointers. All I/O is done by transferring bytes to and from buffers in main memory.\n\n\n\n\n\n\n\nbuf\n: points to the beginning of the user-allocated buffer and the size argument specifies the size of the buffer in bytes. If the buf argument is null, then the fmemopen function allocates a buffer of \nsize\n bytes.\n\n\ntype\n: controls how the stream can be used [p171]\n\n\n\n\nNote:\n\n\n\n\nUnder append mode, the current file position is set to the first null byte in the buffer. If the buffer contains no null bytes, then the current position is set to one byte past the end of the buffer. Under non-append mode, the current position is set to the beginning of the buffer. Thus, memory streams aren\u2019t well suited for storing binary data (which might contain null bytes before the end of the data).\n\n\nIf the \nbuf\n argument is a null pointer, it makes no sense to open the stream for only reading or only writing. Because the buffer is allocated by \nfmemopen\n in this case, there is no way to find the buffer's address\n\n\nA null byte is written at the current position in the stream whenever we increase the amount of data in the stream\u2019s buffer and call \nfclose\n, \nfflush\n, \nfseek\n, \nfseeko\n, or \nfsetpos\n.\n\n\n\n\nAlternatives to Standard I/O\n\n\nWhen we use the line-at-a-time functions, \nfgets\n and \nfputs\n, the data is usually copied twice: once between the kernel and the standard I/O buffer (when the corresponding read or write is issued) and again between the standard I/O buffer and our line buffer.\n\n\nDoubts and Solutions\n\n\nVerbatim\n\n\nSection 5.4 on line buffering [p145]\n\n\n\n\nSecond, whenever input is requested through the standard I/O library from either (a) an unbuffered stream or (b) a line-buffered stream (that requires data to be requested from the kernel), all line-buffered output streams are flushed. The reason for the qualifier on (b) is that the requested data may already be in the buffer, which doesn\u2019t require data to be read from the kernel. Obviously, any input from an unbuffered stream, item (a), requires data to be obtained from the kernel.\n\n\n\n\nSection 5.8 Standard I/O Efficiency [p155]\n\n\n\n\nThe version using line-at-a-time I/O is almost twice as fast as the version using character-at-a-time I/O. If the fgets and fputs functions are implemented using getc and putc, then we would expect the timing to be similar to the getc version. Actually, we might expect the line-at-a-time version to take longer, since we would be adding the overhead of 200 million extra function calls to the existing 6 million ones.\n\n\n\n\nSection 5.14 on Memory Stream [p172]\n\n\n\n\nThird, a null byte is written at the current position in the stream whenever we increase the amount of data in the stream\u2019s buffer and call fclose, fflush, fseek, fseeko, or fsetpos.", 
            "title": "Chapter 5. Standard I/O Library"
        }, 
        {
            "location": "/apue/ch6/", 
            "text": "Chapter 6. System Data Files and Information\n\n\nThis chapter covers portable interfaces to data files, system identification functions and the time and date functions.\n\n\nPassword File\n\n\nThe UNIX System's password file, called the user database by POSIX.1, contains the following fields:\n\n\n\n\nHistorically, the password file has been stored in \n/etc/passwd\n and has been an ASCII file.\n\n\n\n\nroot\n has a user ID of 0 (superuser)\n\n\nThe encrypted password field contains a single character as a placeholder (\nx\n) \n\n\nSome fields can be empty\n\n\nThe shell field contains the user's login shell. The default value for an empty shell field is usually \n/bin/sh\n. Other executable that prevents a user from loggin in to a system:\n\n\n/dev/null\n\n\n/bin/false\n: exits with an unsuccessful (nonzero) status\n\n\n/bin/true\n: exits with a successful (zero) status\n\n\nnologin\n: prints a customizable error message and exits with a nonzero exit status\n\n\n\n\n\n\nnobody\n user name can be used to allow people to log in to a system, but with a user ID (65534) and group ID (65534) that provide no privileges.\n\n\nSome systems that provide the \nfinger(1)\n command support additional information in the comment field\n\n\n\n\nSome systems provide the \nvipw\n command to allow administrators to edit the password file.\n\n\n\n\n\n\n\ngetpwuid\n: used by the \nls(1)\n program to map the numerical user ID contained in an i-node into a user's login name.\n\n\ngetpwnam\n: used by the \nlogin(1)\n program when we enter our login name\n\n\n\n\nBoth functions return a pointer to a passwd structure that the functions fill in. \nThis structure is usually a static variable within the function, so its contents are overwritten each time we call either of these functions.\n\n\n\n\n\n\n\ngetpwent\n: returns the next entry (a pointer to a structure that it has filled in, this structure is overwritten each time we call this function) in the password file.\n\n\nsetpwent\n: rewinds files\n\n\nendpwent\n: closes files\n\n\n\n\nExample:\n\n\n\n\ngetpwnam.c\n\n\n\n\nsetpwent\n at the beginning of this function is self-defense: we ensure that the files are rewound, in case the caller has already opened them by calling getpwent.\n\n\nShadow Passwords\n\n\nSystems store the encrypted password in another file, often called the \nshadow password file\n. Minimally, this file has to contain the user name and the encrypted password.\n\n\n\n\nThe shadow password file should not be readable by the world. Only a few programs need to access encrypted passwords, e.g. \nlogin(1)\n and \npasswd(1)\n, and these programs are often set-user-ID root. With shadow passwords, the regular password file, \n/etc/passwd\n, can be left readable by the world.\n\n\n\n\n\nGroup File\n\n\nThe UNIX System\u2019s group file, called the group database by POSIX.1, contains the following fields:\n\n\n\n\nThe field \ngr_mem\n is an array of pointers to the user names that belong to this group. This array is terminated by a null pointer.\n\n\n\n\n\nLike the password file functions, both of these functions normally return pointers to a static variable, which is overwritten on each call.\n\n\n\n\n\n\n\ngetgrent\n: reads the next entry from the group file, opening the file first, if it\u2019s not already open\n\n\n\n\nSupplementary Group IDs\n\n\nnewgrp(1)\n can be used to change the real group ID to the new group\u2019s ID. We could always go back to our original group (as listed in \n/etc/passwd\n) by executing \nnewgrp\n without any arguments.\n\n\nWith 4.2BSD, the concept of \nsupplementary group IDs\n was introduced. The file access permission checks were modified so that in addition to comparing the the file\u2019s group ID to the process effective group ID, it was also compared to all the supplementary group IDs.\n\n\nThe constant \nNGROUPS_MAX\n specifies the number of supplementary group IDs.\n\n\n\n\n\n\n\ngetgroups\n\n\ngidsetsize\n \n 0: the function fills in the array up to \ngidsetsize\n supplementary group IDs\n\n\ngidsetsize\n = 0: the function returns only the number of supplementary group IDs; \ngrouplist\n is not modified\n\n\n\n\n\n\nsetgroups\n: called by the superuser to set the supplementary group ID list for the calling process\n\n\ninitgroups\n: reads the entire group file with the functions \ngetgrent\n, \nsetgrent\n, and \nendgrent\n and determines the group membership for username.  It then calls setgroups to initialize the supplementary group ID list for the user. It includes \nbasegid\n in the supplementary group ID list; basegid is the group ID from the password file for username. See \nSetting the Group IDs\n\n\n\n\nImplementation Differences\n\n\n[p184-185]\n\n\nOther Data Files\n\n\nNumerous other files are used by UNIX systems in normal day-to-day operation.\n\n\nServices and networks:\n\n\n\n\n/etc/services\n\n\n/etc/protocols\n\n\n/etc/networks\n\n\n\n\nThe general principle is that every data file has at least three functions:\n\n\n\n\nget\n: reads the next record, opening the file\n\n\nset\n: opens the file, if not already open, and rewinds the file\n\n\nend\n: closes the data file\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nData file\n\n\nHeader\n\n\nStructure\n\n\nAdditional keyed lookup functions\n\n\n\n\n\n\n\n\n\n\npasswords\n\n\n/etc/passwd\n\n\npwd.h\n\n\npasswd\n\n\ngetpwnam\n, \ngetpwuid\n\n\n\n\n\n\ngroups\n\n\n/etc/group\n\n\ngrp.h\n\n\ngroup\n\n\ngetgrnam\n, \ngetgrgid\n\n\n\n\n\n\nshadow\n\n\n/etc/shadow\n\n\nshadow.h\n\n\nspwd\n\n\ngetspnam\n\n\n\n\n\n\nhosts\n\n\n/etc/hosts\n\n\nnetdb.h\n\n\nhostent\n\n\ngetnameinfo\n, \ngetaddrinfo\n\n\n\n\n\n\nnetworks\n\n\n/etc/networks\n\n\nnetdb.h\n\n\nnetent\n\n\ngetnetbyname\n, \ngetnetbyaddr\n\n\n\n\n\n\nprotocols\n\n\n/etc/protocols\n\n\nnetdb.h\n\n\nprotoent\n\n\ngetprotobyname\n, \ngetprotobynumber\n\n\n\n\n\n\nservices\n\n\n/etc/services\n\n\nnetdb.h\n\n\nservent\n\n\ngetservbyname\n, \ngetservbyport\n\n\n\n\n\n\n\n\nLogin Accounting\n\n\nTwo data files provided with most UNIX systems:\n\n\n\n\nutmp\n: keeps track of all the users currently logged in\n\n\nwtmp\n: keeps track of all logins and logouts\n\n\n\n\nstruct utmp {\n    char ut_line[8]; /* tty line: \nttyh0\n, \nttyd0\n, \nttyp0\n, ... */\n    char ut_name[8]; /* login name */\n    long ut_time; /* seconds since Epoch */\n};\n\n\n\n\nOn login, the \nlogin\n program fills one of these structures, and writes it to the \nutmp\n and \nwtmp\n file. On logout, the \ninit\n process erases this entry (fills with null bytes) in \nutmp\n file and appends a new logout entry. This logout entry in the \nwtmp\n file had the \nut_name\n field zeroed out. Special entries were appended to the \nwtmp\n file to indicate when the system was rebooted and right before and after the system\u2019s time and date was changed.\n\n\nThe \nwho(1)\n program read the \nutmp\n file and printed its contents in a readable form\n\n\nSystem Identification\n\n\n\n\n\nstruct utsname {\n    char sysname[]; /* name of the operating system */\n    char nodename[]; /* name of this node */\n    char release[]; /* current release of operating system */\n    char version[]; /* current version of this release */\n    char machine[]; /* name of hardware type */\n};\n\n\n\n\n\n\n\ngethostname\n (now defined as part of POSIX.1) specifies that the maximum host name length is \nHOST_NAME_MAX\n.\n\n\n\n\n\n\n\n\nInterface\n\n\nFreeBSD 8.0\n\n\nLinux 3.2.0\n\n\nMac OS X 10.6.8\n\n\nSolaris 10\n\n\n\n\n\n\n\n\n\n\nuname\n\n\n256\n\n\n65\n\n\n256\n\n\n257\n\n\n\n\n\n\ngethostname\n\n\n256\n\n\n64\n\n\n256\n\n\n256\n\n\n\n\n\n\n\n\nIf the host is connected to a TCP/IP network, the \nhost name is normally the fully qualified domain name of the host.\n\n\nThere is also a \nhostname(1)\n command that can fetch or set the host name. (The host name is set by the superuser using a similar function, \nsethostname\n.) The host name is normally set at bootstrap time from one of the start-up files invoked by \n/etc/rc\n or \ninit\n.\n\n\nTime and Date Routines\n\n\nCalendar times\n: number of seconds (represented in a \ntime_t\n data type) that have passed since the \nEpoch\n: 00:00:00 January 1, 1970, Coordinated Universal Time (UTC). These calendar times represent both the time and the date. The UNIX System has always differed from other operating systems in:\n\n\n\n\nkeeping time in UTC instead of the local time\n\n\nautomatically handling conversions, such as daylight saving time\n\n\nkeeping the time and date as a single quantity\n\n\n\n\nThe \ntime\n function returns the current time and date.\n\n\n\n\n\nThe time value is always returned as the value of the function. If the argument is non-null, the time value is also stored at the location pointed to by \ncalptr\n.\n\n\nThe real-time extensions to POSIX.1 added support for multiple system clocks. A clock is identified by the \nclockid_t\n type. \n\n\n\n\n\n\n\n\nIdentifier\n\n\nOption\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nCLOCK_REALTIME\n\n\n\n\nreal system time\n\n\n\n\n\n\nCLOCK_MONOTONIC\n\n\n_POSIX_MONOTONIC_CLOCK\n\n\nreal system time with no negative jumps\n\n\n\n\n\n\nCLOCK_PROCESS_CPUTIME_ID\n\n\n_POSIX_CPUTIME\n\n\nCPU time for calling process\n\n\n\n\n\n\nCLOCK_THREAD_CPUTIME_ID\n\n\n_POSIX_THREAD_CPUTIME\n\n\nCPU time for calling thread\n\n\n\n\n\n\n\n\n\n\n\n\n\nclock_gettime\n: gets the time of the specified clock. The time is returned in a \ntimespec\n structure\n\n\nclock_getres\n: determines the resolution of a given system clock. It initializes the \ntimespec\n structure pointed to by the \ntsp\n\n\nclock_settime\n: sets the time for a particular clock.\n\n\ngettimeofday\n: now obsolescent. The only legal value for \ntzp\n is \nNULL\n.\n\n\n\n\nOnce we have the integer value that counts the number of seconds since the Epoch, we normally call a function to convert it to a broken-down time structure, and then call another function to generate a human-readable time and date.\n\n\n\n\nThe two functions \nlocaltime\n and \ngmtime\n convert a calendar time into a broken-down time, a \ntm\n structure.\n\n\nstruct tm { /* a broken-down time */\n    int tm_sec; /* seconds after the minute: [0 - 60] */\n    int tm_min; /* minutes after the hour: [0 - 59] */\n    int tm_hour; /* hours after midnight: [0 - 23] */\n    int tm_mday; /* day of the month: [1 - 31] */\n    int tm_mon; /* months since January: [0 - 11] */\n    int tm_year; /* years since 1900 */\n    int tm_wday; /* days since Sunday: [0 - 6] */\n    int tm_yday; /* days since January 1: [0 - 365] */\n    int tm_isdst; /* daylight saving time flag: \n0, 0, \n0 */\n};\n\n\n\n\nThe reason that the seconds can be greater than 59 is to allow for a \nleap second\n.\n\n\n\n\n\n\n\ngmtime\n: converts the calendar time to UTC time (broken time)\n\n\nlocaltime\n: converts the calendar time to local time (broken time)\n\n\nmktime\n: takes a broken-down time, expressed as a local time, and converts it into a \ntime_t\n value\n\n\nThe \nstrftime\n and \nstrftime_l\n functions are the same, except that the \nstrftime_l\n function allows the caller to specify the locale as an argument. The strftime function uses the locale specified by the \nTZ\n environment variable\n\n\ntmptr\n argument is the time value to format, specified by a pointer to a broken-down time value. [p192]\n\n\nformat\n argument controls the formatting of the time value\n\n\n\n\n\n\n\n\nConversion specifiers for \nstrftime\n\n\n\n\n\n\n\n\nFormat\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n%a\n\n\nabbreviated weekday name\n\n\nThu\n\n\n\n\n\n\n%A\n\n\nfull weekday name\n\n\nThursday\n\n\n\n\n\n\n%b\n\n\nabbreviated month name\n\n\nJan\n\n\n\n\n\n\n%B\n\n\nfull month name\n\n\nJanuary\n\n\n\n\n\n\n%c\n\n\ndate and time\n\n\nThu Jan 19 21:24:52 2012\n\n\n\n\n\n\n%C\n\n\nyear/100: [00\u201399]\n\n\n20\n\n\n\n\n\n\n%d\n\n\nday of the month: [01\u201331]\n\n\n19\n\n\n\n\n\n\n%D\n\n\ndate [MM/DD/YY]\n\n\n01/19/12\n\n\n\n\n\n\n%e\n\n\nday of month (single digit preceded by space) [1\u201331]\n\n\n19\n\n\n\n\n\n\n%F\n\n\nISO 8601 date format [YYYY\u2013MM\u2013DD]\n\n\n2012-01-19\n\n\n\n\n\n\n%g\n\n\nlast two digits of ISO 8601 week-based year [00\u201399]\n\n\n12\n\n\n\n\n\n\n%G\n\n\nISO 8601 week-based year\n\n\n2012\n\n\n\n\n\n\n%h\n\n\nsame as \n%b\n\n\nJan\n\n\n\n\n\n\n%H\n\n\nhour of the day (24-hour format): [00\u201323]\n\n\n21\n\n\n\n\n\n\n%I\n\n\nhour of the day (12-hour format): [01\u201312]\n\n\n09\n\n\n\n\n\n\n%j\n\n\nday of the year: [001\u2013366]\n\n\n019\n\n\n\n\n\n\n%m\n\n\nmonth: [01\u201312]\n\n\n01\n\n\n\n\n\n\n%M\n\n\nminute: [00\u201359]\n\n\n24\n\n\n\n\n\n\n%n\n\n\nnewline character\n\n\n\n\n\n\n\n\n%p\n\n\nAM/PM\n\n\nPM\n\n\n\n\n\n\n%r\n\n\nlocale\u2019s time (12-hour format)\n\n\n09:24:52 PM\n\n\n\n\n\n\n%R\n\n\nsame as \n%H:%M\n\n\n21:24\n\n\n\n\n\n\n%S\n\n\nsecond: [00\u201360]\n\n\n52\n\n\n\n\n\n\n%t\n\n\nhorizontal tab character\n\n\n\n\n\n\n\n\n%T\n\n\nsame as \n%H:%M:%S\n\n\n21:24:52\n\n\n\n\n\n\n%u\n\n\nISO 8601 weekday [Monday = 1, 1\u20137]\n\n\n4\n\n\n\n\n\n\n%U\n\n\nSunday week number: [00\u201353]\n\n\n03\n\n\n\n\n\n\n%V\n\n\nISO 8601 week number: [01\u201353]\n\n\n03\n\n\n\n\n\n\n%w\n\n\nweekday: [0 = Sunday, 0\u20136]\n\n\n4\n\n\n\n\n\n\n%W\n\n\nMonday week number: [00\u201353]\n\n\n03\n\n\n\n\n\n\n%x\n\n\nlocale\u2019s date 01/19/\n\n\n12\n\n\n\n\n\n\n%X\n\n\nlocale\u2019s time 21:24:\n\n\n52\n\n\n\n\n\n\n%y\n\n\nlast two digits of year: [00\u201399]\n\n\n12\n\n\n\n\n\n\n%Y\n\n\nyear\n\n\n2012\n\n\n\n\n\n\n%z\n\n\noffset from UTC in ISO 8601 format\n\n\n-0500\n\n\n\n\n\n\n%Z\n\n\ntime zone name\n\n\nEST\n\n\n\n\n\n\n%%\n\n\ntranslates to a percent sign\n\n\n%\n\n\n\n\n\n\n\n\n\n\nstrftime\n example: \nstrftime.c\n\n\n\n\nConversion specifiers for \nstrptime\n\n\n\n\n\n\n\n\nFormat\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n%a\n\n\nabbreviated or full weekday name\n\n\n\n\n\n\n%A\n\n\nsame as \n%a\n\n\n\n\n\n\n%b\n\n\nabbreviated or full month name\n\n\n\n\n\n\n%B\n\n\nsame as \n%b\n\n\n\n\n\n\n%c\n\n\ndate and time\n\n\n\n\n\n\n%C\n\n\nall but the last two digits of the year\n\n\n\n\n\n\n%d\n\n\nday of the month: [01\u201331]\n\n\n\n\n\n\n%D\n\n\ndate [MM/DD/YY]\n\n\n\n\n\n\n%e\n\n\nsame as \n%d\n\n\n\n\n\n\n%h\n\n\nsame as \n%b\n\n\n\n\n\n\n%H\n\n\nhour of the day (24-hour format): [00\u201323]\n\n\n\n\n\n\n%I\n\n\nhour of the day (12-hour format): [01\u201312]\n\n\n\n\n\n\n%j\n\n\nday of the year: [001\u2013366]\n\n\n\n\n\n\n%m\n\n\nmonth: [01\u201312]\n\n\n\n\n\n\n%M\n\n\nminute: [00\u201359]\n\n\n\n\n\n\n%n\n\n\nany white space\n\n\n\n\n\n\n%p\n\n\nAM/PM\n\n\n\n\n\n\n%r\n\n\nlocale\u2019s time (12-hour format, AM/PM notation)\n\n\n\n\n\n\n%R\n\n\ntime as \n%H:%M\n\n\n\n\n\n\n%S\n\n\nsecond: [00\u201360]\n\n\n\n\n\n\n%t\n\n\nany white space\n\n\n\n\n\n\n%T\n\n\ntime as \n%H:%M:%S\n\n\n\n\n\n\n%U\n\n\nSunday week number: [00\u201353]\n\n\n\n\n\n\n%w\n\n\nweekday: [0 = Sunday, 0\u20136]\n\n\n\n\n\n\n%W\n\n\nMonday week number: [00\u201353]\n\n\n\n\n\n\n%x\n\n\nlocale\u2019s date\n\n\n\n\n\n\n%X\n\n\nlocale\u2019s time\n\n\n\n\n\n\n%y\n\n\nlast two digits of year: [00\u201399]\n\n\n\n\n\n\n%Y\n\n\nyear\n\n\n\n\n\n\n%%\n\n\ntranslates to a percent sign\n\n\n\n\n\n\n\n\nFunctions that are affected by \nTZ\n environment variable. If defined, the value of this environment variable is used by these functions instead of the default time zone:\n\n\n\n\nlocaltime\n\n\nmktime\n\n\nstrftime", 
            "title": "Chapter 6. System Data Files and Information"
        }, 
        {
            "location": "/apue/ch7/", 
            "text": "Chapter 7. Process Environment\n\n\nIntroduction\n\n\nmain\n Function\n\n\nA C program starts execution with a function called \nmain\n:\n\n\nint main(int argc, char *argv[]);\n\n\n\n\n\n\nargc\n: number of command-line arguments\n\n\nargv\n: an array of pointers to the arguments\n\n\n\n\nWhen a C program is executed by the kernel (by one of the \nexec\n functions), a special start-up routine is called before the \nmain\n function is called. The executable program file specifies this routine as the starting address for the program; this is set up by the link editor (linker) when it is invoked by the C compiler. This start-up routine takes values from the kernel (the command-line arguments and the environment) and sets things up so that the \nmain\n function is called as shown earlier.\n\n\nProcess Termination\n\n\nThree functions terminate a program normally:\n\n\n\n\n\n\n\n_exit\n: returns to the kernel immediately\n\n\n_Exit\n: same as \n_exit\n\n\nexit\n: performs certain cleanup processing and then returns to the kernel. Historically, it has always performed a clean shutdown of the standard I/O library: the \nfclose\n function is called for all open streams\n\n\n\n\nAll three exit functions expect a single integer argument (\nexit status\n).\n\n\nThe \nexit status of the process is undefined\n, if any of the following occurs:\n\n\n\n\nAny of these functions is called without an exit status\n\n\nmain\n does a return without a return value\n\n\nmain\n function is not declared to return an integer\n\n\n\n\nIf the return type of main is an integer and main \"falls off the end\" (an implicit return), the exit status of the process is 0.\n\n\nReturning an integer value from the main function is equivalent to calling exit with the same value:\n\n\nexit(0);\n is same as \nreturn(0);\n from the \nmain\n function.\n\n\natexit\n Function\n\n\nWith ISO C, a process can register at least 32 functions that are automatically called by \nexit\n. These are called \nexit handlers\n and are registered by calling the \natexit\n function.\n\n\n\n\n\n\n\nfunc\n argument is the address of the function to be called by \nexit\n. When this function is called, it is not passed any arguments and is not expected to return a value. The \nexit\n function calls these functions in reverse order of their registration. Each function is called as many times as it was registered.\n\n\n\n\nWith ISO C and POSIX.1, \nexit\n first calls the exit handlers and then closes (via \nfclose\n) all open streams. POSIX.1 extends the ISO C standard by specifying that any exit handlers installed will be cleared if the program calls any of the \nexec\n family of functions.\n\n\nThe only way a program can be executed by the kernel is if one of the \nexec\n functions is called. \nThe only way a process can voluntarily terminate is if \n_exit\n or \n_Exit\n is called\n, either explicitly or implicitly (by calling \nexit\n). A process can also be involuntarily terminated by a signal.\n\n\nCommand-Line Arguments\n\n\nWhen a program is executed, the process that does the \nexec\n can pass command-line arguments to the new program. This is part of the normal operation of the UNIX system shells.\n\n\nExample:\n\n\n#include \napue.h\n\n\nint\nmain(int argc, char *argv[])\n{\n    int i;\n    for (i = 0; i \n argc; i++) /* echo all command-line args */\n        printf(\nargv[%d]: %s\\n\n, i, argv[i]);\n    exit(0);\n}\n\n\n\n\nWe are guaranteed by both ISO C and POSIX.1 that argv[argc] is a null pointer. This lets us alternatively code the argument-processing loop as:\n\n\nfor (i = 0; argv[i] != NULL; i++)\n\n\n\n\nEnvironment List\n\n\nEach program is also passed an environment list, which is an array of character pointers, with each pointer containing the address of a null-terminated C string. It is contained in the global variable environ:\n\n\nextern char **environ;\n\n\n\n\n\n\n\n\nenviron\n is called the \nenvironment pointer\n, the array of pointers the environment list, and the strings they point to the \nenvironment strings\n, which by convention is \nname=value\n strings. By convetion, predefined names are entirely uppercase.\n\n\n\n\nMemory Layout of a C Program\n\n\nHistorically, a C program has been composed of the following pieces:\n\n\n\n\nText segment: consists of the machine instructions that the CPU executes\n\n\nInitialized data segment (or simply data segment): contains variables that are specifically initialized in the program\n\n\nUninitialized data segment (often called the \"bss\" segment, which is named after \"block started by symbol\"): data in this segment is initialized by the kernel to arithmetic 0 or null pointers before the program starts executing\n\n\nStack: stores automatic variables, along with information that is saved each time a function is called\n\n\nHeap is where dynamic memory allocation usually takes place\n\n\n\n\n\n\nWith Linux on a 32-bit Intel x86 processor, the text segment starts at location \n0x08048000\n, and the bottom of the stack starts just below \n0xC0000000\n. \nThe stack grows from higher-numbered addresses to lower-numbered addresses on this particular architecture.\n The unused virtual address space between the top of the heap and the top of the stack is large\n\n\nThe \nsize(1)\n command reports the sizes (in bytes) of the text, data, and bss segments:\n\n\n    $ size /usr/bin/cc /bin/sh\n    text data bss dec hex filename\n    346919 3576 6680 357175 57337 /usr/bin/cc\n    102134 1776 11272 115182 1c1ee /bin/sh\n\n\n\n\nShared Libraries\n\n\nShared libraries remove the common library routines from the executable file and maintains a single copy of the library routine somewhere in memory that all processes reference:\n\n\n\n\nPros: reduces the size of each executable file; library functions can be replaced with new versions without having to relink edit every program that uses the library\n\n\nCons: adds some runtime overhead, either when the program is first executed or the first time each shared library function is called\n\n\n\n\nMemory Allocation\n\n\n\n\n\n\n\nmalloc\n: allocates a specified number of bytes of memory\n\n\ncalloc\n: allocates space for a specified number of objects of a specified size\n\n\nrealloc\n: increases or decreases the size of a previously allocated area. The final argument to realloc is the new size of the region, not the\ndifference between the old and new sizes\n\n\n\n\nThe pointer returned by the three allocation functions is guaranteed to be suitably aligned so that it can be used for any data object.\n\n\nBecause the three \nalloc\n functions return a generic \nvoid *\n pointer, if we \n#include \nstdlib.h\n (to obtain the function prototypes), we do not explicitly have to cast the pointer returned by these functions when we assign it to a pointer of a different type. \nThe default return value for undeclared functions is int, so using a cast without the proper function declaration could hide an error on systems where the size of type int differs from the size of a function\u2019s return value (a pointer in this case).\n\n\n\n\nfree\n: causes the space pointed to by \nptr\n to be deallocated. This freed space is usually put into a pool of available memory and can be allocated in a later call to one of the three \nalloc\n functions.\n\n\n\n\nThe allocation routines are usually implemented with the \nsbrk(2)\n system call. This system call expands (or contracts) the heap of the process. Although \nsbrk\n can expand or contract the memory of a process, most versions of \nmalloc\n and free never decrease their memory size. \nThe space that we free is available for a later allocation, but the freed space is not usually returned to the kernel; instead, that space is kept in the \nmalloc\n pool.\n\n\nAlternate Memory Allocators\n\n\n[p209]\n\n\n\n\nlibmalloc\n\n\nvmalloc\n\n\nquick-fit\n\n\njemalloc\n\n\nTCMalloc\n\n\nalloca\n Function: has the same calling sequence as \nmalloc\n; however, instead of allocating memory from the heap, the memory is allocated from the stack frame of the current function\n\n\n\n\nEnvironment Variables\n\n\nThe environment strings are usually of the form:\n\n\nname=value\n\n\n\n\nThe UNIX kernel never looks at these strings; their interpretation is up to the various applications. \n\n\n\n\n\n\n\ngetenv\n: returns a pointer to the value of a \nname=value\n string. We should always use \ngetenv\n to fetch a specific value from the environment, instead of accessing \nenviron\n directly\n\n\n\n\n\n\n\n\nputenv\n: takes a string of the form \nname=value\n and places it in the environment list. If name already exists, its old definition is first removed.\n\n\nsetenv\n: sets \nname\n to \nvalue\n. If name already exists in the environment, then:\n\n\nIf \nrewrite\n is nonzero, the existing definition for \nname\n is first removed\n\n\nIf \nrewrite\n is 0, the existing definition for \nname\n is not removed, \nname\n is not set to the new value, and no error occurs\n\n\n\n\n\n\nunsetenv\n: removes any definition of name. It is not an error if such a definition does not exist.\n\n\n\n\nNote the difference between \nputenv\n and \nsetenv\n. Whereas \nsetenv\n must allocate memory to create the \nname=value\n string from its arguments, \nputenv\n is free to place the string passed to it directly into the environment. Indeed, many implementations do exactly this, so \nit would be an error to pass putenv a string allocated on the stack, since the memory would be reused after we return from the current function.\n\n\n\n\nDeleting a string: we just find the pointer in the environment list and move all subsequent pointers down one.\n\n\nModifying a existing \nname\n:\n\n\nIf new \nvalue\n is smaller than or equal to old: we just copy the string\n\n\nIf new \nvalue\n is larger than old: we must \nmalloc\n and replace the old pointer in the environment list for \nname\n with the pointer to this allocated area\n\n\n\n\n\n\nAdding a new \nname\n:\n\n\nFirst time: we call \nmalloc\n, copy the old environment list to this new area and store a pointer to the \nname=value\n string at the end of\nthis list of pointers. We also store a null pointer at the end of this list, of course. Finally, we set \nenviron\n to point to this new list of pointers. \nIf the original environment list was contained above the top of the stack, as is common, then we have moved this list of pointers to the heap. But most of the pointers in this list still point to \nname=value\n strings above the top of the stack.\n\n\nNot first time: we call \nrealloc\n to allocate room for one more pointer. The pointer to the new \nname=value\n string is stored at the end of the list (on top of the previous null pointer), followed by a null pointer.\n\n\n\n\n\n\n\n\nsetjmp\n and \nlongjmp\n Functions\n\n\nIn C, we can't \ngoto\n a label that\u2019s in another function. Instead, we must use the \nsetjmp\n and \nlongjmp\n functions to perform this type of branching. These two functions are useful for handling error conditions that occur in a deeply nested function call.\n\n\n\n\n\nExamples:\n\n\n\n\ncmd1.c\n\n\ncmd2.c\n\n\n\n\nAutomatic, Register, and Volatile Variables\n\n\nWhen we return to \nmain\n as a result of the \nlongjmp\n, implementations do not try to roll back these automatic variables and register variables (in \nmain\n), though standards say only that their values are indeterminate.\n\n\nExample:\n\n\n\n\ntestjmp.c\n\n\n\n\nCompile the above program, with and without compiler optimizations, the results are different:\n\n\n$ gcc testjmp.c compile without any optimization\n$ ./a.out\nin f1():\nglobval = 95, autoval = 96, regival = 97, volaval = 98, statval = 99\nafter longjmp:\nglobval = 95, autoval = 96, regival = 97, volaval = 98, statval = 99\n$ gcc -O testjmp.c compile with full optimization\n$ ./a.out\nin f1():\nglobval = 95, autoval = 96, regival = 97, volaval = 98, statval = 99\nafter longjmp:\nglobval = 95, autoval = 2, regival = 3, volaval = 98, statval = 99\n\n\n\n\nThe optimizations don\u2019t affect the global, static, and volatile variables. The \nsetjmp(3)\n manual page on one system states that variables stored in memory will have values as of the time of the \nlongjmp\n, whereas variables in the CPU and floating-point registers are restored to their values when \nsetjmp\n was called. Without optimization, all five variables are stored in memory. When we enable optimization, both \nautoval\n and \nregival\n go into registers, even though the former wasn't declared \nregister\n, and the \nvolatile\n variable stays in memory.\n\n\nPotential Problem with Automatic Variables\n\n\nAn automatic variable can never be referenced after the function that declared it returns.\n\n\nIncorrect usage of an automatic variable:\n\n\n#include \nstdio.h\n\nFILE *\nopen_data(void)\n{\n    FILE *fp;\n    char databuf[BUFSIZ]; /* setvbuf makes this the stdio buffer */\n    if ((fp = fopen(\ndatafile\n, \nr\n)) == NULL)\n        return(NULL);\n    if (setvbuf(fp, databuf, _IOLBF, BUFSIZ) != 0)\n        return(NULL);\n    return(fp); /* error */\n}\n\n\n\n\nThe problem is that when \nopen_data\n returns, the space it used on the stack will be used by the stack frame for the next function that is called. But the standard I/O library will still be using that portion of memory for its stream buffer. Chaos is sure to result. To correct this problem, the array \ndatabuf\n needs to be allocated from global memory, either statically (\nstatic\n or \nextern\n) or dynamically (one of the \nalloc\n functions).\n\n\ngetrlimit\n and \nsetrlimit\n Functions\n\n\nEvery process has a set of resource limits, some of which can be queried and changed by the \ngetrlimit\n and \nsetrlimit\n functions.\n\n\n\n\n\nThese two functions are defined in the XSI option in the Single UNIX Specification. The resource limits for a process are normally established by process 0 when the system is initialized and then inherited by each successive process. Each implementation has its own way of tuning the various limits.\n\n\n\n\nrlptr\n: a pointer to the following structure:\n\n\n\n\nstruct rlimit {\n    rlim_t rlim_cur; /* soft limit: current limit */\n    rlim_t rlim_max; /* hard limit: maximum value for rlim_cur */\n};\n\n\n\n\n\n\n\n\nresource\n argument takes on one of the following values:\n\n\n\n\nRLIMIT_AS\n: The maximum size in bytes of a process\u2019s total available memory. This affects the \nsbrk\n function and the \nmmap\n function.\n\n\nRLIMIT_CORE\n: The maximum size in bytes of a core file. A limit of 0 prevents the creation of a core file.\n\n\nRLIMIT_CPU\n: The maximum amount of CPU time in seconds. When the soft limit is exceeded, the SIGXCPU signal is sent to the process.\n\n\nRLIMIT_DATA\n: The maximum size in bytes of the data segment: the sum of the initialized data, uninitialized data, and heap from \nFigure 7.6\n.\n\n\nRLIMIT_FSIZE\n: The maximum size in bytes of a file that may be created.  When the soft limit is exceeded, the process is sent the \nSIGXFSZ\n signal.\n\n\nRLIMIT_MEMLOCK\n: The maximum amount of memory in bytes that a process can lock into memory using \nmlock(2)\n.\n\n\nRLIMIT_MSGQUEUE\n: The maximum amount of memory in bytes that a process can allocate for POSIX message queues.\n\n\nRLIMIT_NICE\n: The limit to which a process\u2019s nice value can be raised to affect its scheduling priority.\n\n\nRLIMIT_NOFILE\n: The maximum number of open files per process. Changing this limit affects the value returned by the \nsysconf\n function for its \n_SC_OPEN_MAX\n argument.\n\n\nRLIMIT_NPROC\n: The maximum number of child processes per real user ID. Changing this limit affects the value returned for \n_SC_CHILD_MAX\n by the \nsysconf\n function.  \n\n\nRLIMIT_NPTS\n: The maximum number of pseudo terminals that a user can have open at one time.\n\n\nRLIMIT_RSS\n: Maximum resident set size (RSS) in bytes. If available physical memory is low, the kernel takes memory from processes that exceed their RSS.\n\n\nRLIMIT_SBSIZE\n: The maximum size in bytes of socket buffers that a user can consume at any given time.\n\n\nRLIMIT_SIGPENDING\n: The maximum number of signals that can be queued for a process. This limit is enforced by the sigqueue function\n\n\nRLIMIT_STACK\n: The maximum size in bytes of the stack. See \nFigure 7.6\n.\n\n\nRLIMIT_SWAP\n: The maximum amount of swap space in bytes that a user can consume.\n\n\nRLIMIT_VMEM\n This is a synonym for \nRLIMIT_AS\n.\n\n\n\n\n\n\n\n\nRules of changing resource limits:\n\n\n\n\nA process can change its soft limit to a value less than or equal to its hard limit.\n\n\nA process can lower its hard limit to a value greater than or equal to its soft limit. \nThis lowering of the hard limit is irreversible for normal users.\n\n\nOnly a superuser process can raise a hard limit.\n\n\n\n\nThe resource limits affect the calling process and are inherited by any of its children. This means that the setting of resource limits needs to be built into the shells to affect all our future processes. Indeed, the Bourne shell, the GNU Bourne-again shell, and the Korn shell have the built-in \nulimit\n command, and the C shell has the built-in limit command. (The \numask\n and \nchdir\n functions also have to be handled as shell built-ins.)\n\n\nExample:\n\n\n\n\ngetrlimit.c\n\n\n\n\nSummary\n\n\nUnderstanding the environment of a C program within a UNIX system\u2019s environment is a prerequisite to understanding the process control features of the UNIX System. This chapter discusses process start and termination, and how a process is passed  an argument list and an environment. Although both the argument list and the environment are uninterpreted by the kernel, it is the kernel that passes both from the caller of \nexec\n to the new process.  This chapter also examines the typical memory layout of a C program and how a process can dynamically allocate and free memory.", 
            "title": "Chapter 7. Process Environment"
        }, 
        {
            "location": "/apue/ch8/", 
            "text": "Chapter 8. Process Control\n\n\nProcess Identifiers\n\n\nEvery process has a unique process ID, a non-negative integer. As processes terminate, their IDs can be reused. \nMost UNIX systems implement algorithms to delay reuse so that newly created processes are assigned IDs different from those used by processes that terminated recently. This prevents a new process from being mistaken for the previous process to have used the same ID.\n\n\nThere are some special processes, but the details differ from implementation to implementation:\n\n\n\n\nProcess ID 0: scheduler process (often known as the \nswapper\n), which is part of the kernel and is known as a system process\n\n\nProcess ID 1: \ninit\n process, invoked by the kernel at the end of the bootstrap procedure.\n\n\nIt is responsible for bringing up a UNIX system after the kernel has been bootstrapped. \ninit\n usually reads the system-dependent initialization files (\n/etc/rc*\n files or \n/etc/inittab\n and the files in \n/etc/init.d\n) and brings the system to a certain state.\n\n\nIt never dies.\n\n\nIt is a normal user process, not a system process within the kernel.\n\n\nIt runs with superuser privileges.\n\n\n\n\n\n\n\n\nEach UNIX System implementation has its own set of kernel processes that provide operating system services.\n For example, on some virtual memory implementations of the UNIX System, process ID 2 is the \npagedaemon\n. This process is responsible for supporting the paging of the virtual memory system.\n\n\n\n\n\nNone of these functions has an error return.\n\n\nfork\n Function\n\n\nAn existing process can create a new one by calling the \nfork\n function.\n\n\n\n\n\n\n\nThe new process created by \nfork\n is called the \nchild process\n. This function is called once but returns twice. The only difference in the returns is that the return value in the child is 0, whereas the return value in the parent is the process ID of the new child. [p299]\n\n\nfork\n returns child's process ID in parent: a process can have more than one child, and \nthere is no function that allows a process to obtain the process IDs of its children\n\n\nfork\n returns 0 in child: \na process can have only a single parent, and the child can always call \ngetppid\n to obtain the process ID of its parent\n\n\n\n\n\n\nBoth the child and the parent continue executing with the instruction that follows the call to \nfork\n. The child is a copy of the parent; the parent and the child do not share these portions of memory. The parent and the child do share the text segment.\n\n\nCopy-on-write (COW) is used on modern implementations: a complete copy of the parent\u2019s data, stack and heap is not performed. The shared regions are changed to read-only by the kernel. The kernel makes a copy of that piece of memory only if either process tries to modify these regions.\n\n\n\n\nVariations of the \nfork\n function are provided by some platforms. All four platforms discussed in this book support the \nvfork(2)\n variant discussed in the next section. Linux 3.2.0 also provides new process creation through the \nclone(2)\n system call. This is a generalized form of \nfork\n that allows the caller to control what is shared between parent and child.\n\n\nExample (\nfork1.c\n):\n\n\n#include \napue.h\n\n\nint globvar = 6; /* external variable in initialized data */\nchar buf[] = \na write to stdout\\n\n;\n\nint\nmain(void)\n{\n    int var; /* automatic variable on the stack */\n    pid_t pid;\n\n    var = 88;\n    if (write(STDOUT_FILENO, buf, sizeof(buf)-1) != sizeof(buf)-1)\n        err_sys(\nwrite error\n);\n    printf(\nbefore fork\\n\n); /* we don\u2019t flush stdout */\n\n    if ((pid = fork()) \n 0) {\n        err_sys(\nfork error\n);\n    } else if (pid == 0) { /* child */\n        globvar++; /* modify variables */\n        var++;\n    } else {\n        sleep(2); /* parent */\n    }\n\n    printf(\npid = %ld, glob = %d, var = %d\\n\n, (long)getpid(), globvar,\n           var);\n    exit(0);\n}\n\n\n\n\n$ ./a.out\na write to stdout\nbefore fork\npid = 430, glob = 7, var = 89 # child\u2019s variables were changed\npid = 429, glob = 6, var = 88 # parent\u2019s copy was not changed\n$ ./a.out \n temp.out\n$ cat temp.out\na write to stdout\nbefore fork\npid = 432, glob = 7, var = 89\nbefore fork\npid = 431, glob = 6, var = 88\n\n\n\n\nAnalysis:\n\n\n\n\nWhether the child starts executing before the parent or vice versa is not known. The order depends on the scheduling algorithm used by the kernel. If it\u2019s required that the child and parent synchronize their actions, some form of interprocess communication is required.\n\n\nsizeof(buf)-1\n (subtracting 1 from the size of \nbuf\n) avoids writing the terminating null byte. \nstrlen\n calculates the length of a string not including the terminating null byte, while \nsizeof\n calculates the size of the buffer, including the terminating null byte. However, using \nstrlen\n requires a function call, whereas \nsizeof\n calculates the buffer length at compile time.\n\n\n\"a write to stdout\" (once): \nwrite\n function is not buffered and is called before the \nfork\n, its data is written once to standard output\n\n\n\"before fork\" (once in the first case, twice in the second case): \nprintf\n from the standard I/O library is buffered\n\n\nFirst case (running the program interactively): standard I/O is \nline buffered\n and standard output buffer is flushed by the newline\n\n\nSecond case (redirect stdout to a file): standard I/O is \nfully buffered\n. The \nprintf\n (\nprintf(\"before fork\\n\");\n) before the \nfork\n is called once, but the line remains in the buffer when \nfork\n is called. \nThis buffer is then copied into the child when the parent\u2019s data space is copied to the child. Both the parent and the child now have a standard I/O buffer with this line in it.\n The second \nprintf\n (\nprintf(\"pid = %ld, glob = %d, var = %d\\n\", ...);\n), right before the exit, just appends its data to the existing buffer. When each process terminates, its copy of the buffer is finally flushed.\n\n\n\n\n\n\n\n\nFile Sharing", 
            "title": "Chapter 8. Process Control"
        }, 
        {
            "location": "/utlk/ch1/", 
            "text": "Chapter 1. Introduction\n\n\nThis chapter gives an overview of major features of Linux, as well as Unix kernels. This book is based on \nLinux 2.6.11\n source code.\n\n\nLinux Versus Other Unix-Like Kernels\n\n\nSeveral differences between Linux and Unix implementations:\n\n\n\n\nKernel threading\n\n\nPreemptive kernel: Linux 2.6 can arbitrarily interleave execution flows while they are in privileged mode\n\n\nMultiprocessor support: Linux 2.6 supports symmetric multiprocessing (SMP)\n\n\nSTREAMS\n is not included in Linux\n\n\n\n\nThe Process/Kernel Model\n\n\n\n\nUsers processes\n\n\nKernel threads:\n\n\nrun in Kernel Mode;\n\n\nare non-interactive;\n\n\ncreated during system startup\n\n\n\n\n\n\nKernel routines can be activated in: \n\n\nsystem call;\n\n\nexception signaled by a process; \n\n\ninterrupt by a peripheral device;\n\n\nkernel thread executed\n\n\n\n\n\n\n\n\nProcess Implementation\n\n\nProcess descriptor\n contains registers:\n\n\n\n\nProgram counter (PC) registers\n\n\nStack pointer (SP) registers\n\n\nGeneral purpose registers\n\n\nFloating point registers\n\n\nProcessor control registers\n\n\nMemory management registers\n\n\n\n\nReentrant Kernels\n\n\nA \nkernel control\n path denotes the sequence of instructions executed by the kernel to handle a system call, an exception, or an interrupt.\n\n\nProcess Address Space\n\n\nSynchronization and Critical Regions\n\n\nSignals and Interprocess Communication\n\n\n\n\nUnix signals\n\n\nSystem V IPC: semaphores, message queues, and shared memory\n\n\n\n\nProcess Management\n\n\n\n\nfork()\n, \n_exit()\n, and \nexec()\n-like system calls\n\n\nwait4()\n\n\nProcess groups and login sessions\n\n\n\n\nMemory Management\n\n\n\n\nVirtual memory acts as a logical layer between the application memory requests and the hardware Memory Management Unit (MMU).\n\n\nKernel Memory Allocator: Linux\u2019s KMA uses a Slab allocator on top of a buddy system.\n\n\nProcess virtual address space\n\n\n\n\n\n\nDoubts and Solutions\n\n\nVerbatim\n\n\nChatper 1 on Linux Versus Other Unix-Like Kernels [p3]:\n\n\n\n\nLinux uses kernel threads in a very limited way to execute a few kernel functions periodically; however, they do not represent the basic execution context abstraction. \n\n\n\n\nSummary\n\n\nKernel Architecture\n\n\n\n\nThe Linux kernel, as with most Unix kernels, is \nmonolithic\n: each kernel layer is integrated into the whole kernel program and runs in Kernel Mode on behalf of the current process. [p11]", 
            "title": "Chapter 1. Introduction"
        }, 
        {
            "location": "/utlk/ch2/", 
            "text": "Chapter 2. Memory Addressing\n\n\nThis chapter offers details in \nx86\n microprocessors address memory chips and how Linux uses the available addressing circuits.\n\n\nMemory Addresses\n\n\n\n\nLogical address\n\n\nLinear address\n (also known as \nvirtual address\n)\n\n\nPhysical address\n\n\n\n\nMemory Management Unit (MMU) transforms a logical address into a linear address, and the linear address into a physical address.\n\n\n\n\nMemory arbiter: read or write operations on a RAM chip must be performed serially.\n\n\nSegmentation in Hardware\n\n\nThe following sections focus on address translation when \nprotected mode\n is enabled, in Intel microprocessors starting with the 80286 model.\n\n\nSegment Selectors\n\n\nA logical address consists of:\n\n\n\n\nSegment Selector\n (segment identifier): 16-bit\n\n\nOffset: 32-bit\n\n\n\n\nSegmentation registers\n\n\nSegmentation Registers\n hold Segment Selectors.\n\n\n\n\ncs\n: code segment (program instructions); 2-bit field for CPU's Current Privilege Level (CPL), Linux uses only levels 0 and 3 for Kernel Mode and User Mode\n\n\nss\n: stack segment (current program stack)\n\n\nds\n: data segment (global and static data)\n\n\nes\n, \nfs\n, and \ngs\n: general purpose (arbitrary data)\n\n\n\n\nSegment Descriptors\n\n\nEach segment is represented by an 8-byte \nSegment Descriptor\n that describes the segment characteristics. Segment Descriptors are stored either in the \nGlobal Descriptor Table\n (GDT) or in the \nLocal Descriptor Table\n (LDT). The address and size of GDT and LDT are contained in \ngdtr\n and \nldtr\n control registers respectively.\n\n\n\n\nCode Segment Descriptor: included in GDT or LDT\n\n\nData Segment Descriptor: included in GDT or LDT\n\n\nTask State Segment Descriptor (TSSD): refers to a Task State Segment (TSS), a segment used to save the contents of the processor registers; included in GDT only\n\n\nLocal Descriptor Table Descriptor (LDTD): refers to a segment containing an LDT; included in GDT only\n\n\n\n\nFast Access to Segment Descriptors\n\n\nSegmentation registers store only the Segment Selector. The x86 process provides an additional nonprogrammable register for each of the six programmable segmentation registers to speed up the translation of logical addresses into linear addresses. Each nonprogrammable register contains the 8-byte Segment Descriptor.\n\n\nSegment Selector fields [p40]:\n\n\n\n\nindex\n: identifies the Segment Descriptor entry contained in GDT or LDT\n\n\nTI\n (Table Indicator): specifies whether the Segment Descriptor is included in the GDT (\nTI\n = 0) or in the LDT (\nTI\n = 1).\n\n\nRPL\n (Requestor Privilege Level):  specifies the \nCurrent Privilege Level\n (CPL) of the CPU when the corresponding Segment Selector is loaded into the \ncs\n register\n\n\n\n\nSegmentation Unit\n\n\nThe \nsegmentation unit\n performs the following operations to obtain the linear address:\n\n\n\n\n\n\nExamines the \nTI\n field of the Segment Selector to determine which Descriptor Table (GDT or LDT) stores the Segment Descriptor\n\n\nComputes the address of the Segment Descriptor from the \nindex\n field of the Segment Selector\n\n\nAdds the offset of the logical address to the \nBase\n field of the Segment Descriptor\n\n\n\n\nSegmentation in Linux\n\n\nAll Linux processes running in User Mode use the same pair of segments to address instructions and data. This is similar to processes running in Kernel Mode.\n\n\n\n\nuser code segment\n\n\nuser data segment\n\n\nkernel code segment\n\n\nkernel data segment\n\n\n\n\nSegment Selectors are defined by the macros:\n\n\n\n\n__USER_CS\n\n\n__USER_DS\n\n\n__KERNEL_CS\n\n\n__KERNEL_DS\n\n\n\n\nTo address the kernel code segment, for instance, the kernel just loads the value yielded by the \n__KERNEL_CS\n macro into the \ncs\n segmentation register.\n\n\nThe linear addresses associated with such segments all start at 0 and reach the addressing limit of 2\n32\n \u20131. This means that all processes, either in User Mode or in Kernel Mode, may use the same logical addresses.\n\n\nCPL\n, \nRPL\n and registers\n\n\nThe Current Privilege Level (CPL) of the CPU indicates whether the processor is in User or Kernel Mode and is specified by the \nRPL\n field of the Segment Selector stored in the \ncs\n register. [p42]\n\n\nWhenever the CPL is changed, some segmentation registers (e.g. \nds\n, \nss\n) must be correspondingly updated. [p42-43]\n\n\nImplicit Segment Selector\n\n\nOnly Offset component of its logical address is specified:\n\n\n\n\nss\n: kernel saves a pointer to an instruction or to a data structure\n\n\ncs\n: kernel invokes a function\n\n\nds\n: kernel data structure\n\n\nes\n: user data structure\n\n\n\n\nThe Linux GDT\n\n\nIn multiprocessor systems there is one GDT for every CPU [p43].\n\n\n\n\ncpu_gdt_table\n array: stores GDTs\n\n\ncpu_gdt_descr\n array: addresses and sizes of the GDTs\n\n\n\n\nEach GDT includes 18 segment descriptors and 14 null, unused, or reserved entries. Unused entries are inserted on purpose so that Segment Descriptors usually accessed together are kept in the same 32-byte line of the hardware cache.\n\n\n\n\nFour user and kernel code and data segments\n\n\nTask State Segment (TSS)\n\n\nDefault Local Descriptor Table(LDT), usually shared by all processes\n\n\nThree Thread-Local Storage (TLS) segments: allows multithreaded applications to make use of up to three segments containing data local to each thread. The \nset_thread_area()\n and \nget_thread_area()\n system calls, respectively, create and release a TLS segment for the executing process.\n\n\nThree segments related to Advanced Power Management (APM)\n\n\nFive segments related to Plug and Play (PnP) BIOS services\n\n\nA special TSS segment used by the kernel to handle \"Double fault\" exceptions\n\n\n\n\nThe Linux LDT\n\n\nMost Linux User Mode applications do not make use of a Local Descriptor Table. The kernel defines a default LDT to be shared by most processes. It has five entries but only two are used by the kernel: a \ncall gate\n for \niBCS\n executables, and a call gate for Solaris/x86 executables.\n\n\nIn some cases, processes may require to set up their own LDT, such as applications (such as Wine) that execute segment-oriented Microsoft Windows applications. The \nmodify_ldt()\n system call allows a process to do this.\n\n\nPaging in Hardware\n\n\nThe paging unit translates linear addresses into physical ones. Its key task is to check the requested access type against the access rights of the linear address, and generates a Page Fault exception if memory access is not valid.\n\n\n\n\nPages\n: grouped fixed-length intervals of linear addresses; contiguous linear addresses within a page are mapped into contiguous physical addresses. The term \"page\" to refer both to a set of linear addresses and to the data contained in this group of addresses.\n\n\nPage frames\n (or \nphysical pages\n): RAM partitions from the perspective of the paging unit. Each page frame (storage area) contains a page (block of data), thus the length of a page frame coincides with that of a page.\n\n\nPage table\n: data structures (in main memory) that map linear to physical addresses\n\n\n\n\nRegular Paging\n\n\nThe x86 processors support paging; it is enabled by setting the \nPG\n flag of a control register named \ncr0\n.\n\n\n\n\nDoubts and Solutions\n\n\nSegmentation in Linux [p41]\n\n\n\n\nHowever, Linux uses segmentation in a very limited way. In fact, segmentation and paging are somewhat redundant, because both can be used to separate the physical address spaces of processes: segmentation can assign a different linear address space to each process, while paging can map the same linear address space into different physical address spaces. Linux prefers paging to segmentation for the following reasons:", 
            "title": "Chapter 2. Memory Addressing"
        }, 
        {
            "location": "/unp/ch1/", 
            "text": "Chapter 1. Introduction\n\n\nIntroduction\n\n\nThe \nclient\n and \nserver\n organization is used by most network-awared applications. Some complex applications also require \nasynchronous callback\n communication, where the server initiates a message to the client.\n\n\nA Simple Daytime Client\n\n\n\n\ndaytimetcpcli.c\n\n\n\n\n\n\n\nCreate TCP socket\n\n\nThe \nsocket\n function creates an Internet (\nAF_INET\n) stream (\nSOCK_STREAM\n) socket, which is a fancy name for a TCP socket. The function returns a small integer descriptor to identify the socket.\n\n\nSpecify server's IP address and port\n\n\nThe IP address (\nsin_addr\n) and port number (\nsin_port\n) fields in the Internet socket address structure (\nsockaddr_in\n) must be in specific formats:\n\n\n\n\nhtons\n (host to network short): converts the binary port number\n\n\ninet_pton\n (presentation to numeric): convert the ASCII command-line argument (such as \n206.62.226.35\n when we ran this example) into the proper format.\n\n\n\n\nbzero\n is not an ANSI C function, but is used in this book instead of the ANSI C \nmemset\n function, because \nbzero\n is easier to remember (with only two arguments) than \nmemset\n (with three arguments).\n\n\nEstablish connection with server\n\n\n\n\nconnect\n\n\n\n\nIn the \nunp.h\n header, \nSA\n is defined to be \nstruct sockaddr\n, a generic socket address structure.\n\n\nRead and display server's reply\n\n\nWe must be careful when using TCP because it is a \nbyte-stream\n protocol with no record boundaries. Since we cannot assume that the server's reply will be returned by a single \nread\n, we always need to code the \nread\n in a loop when reading from a TCP socket.\n\n\nTerminate program\n\n\nexit\n terminates the program. Unix always closes all open descriptors when a process terminates.\n\n\nProtocol Independence\n\n\nThe above program is protocol-depdent on IPv4.\n\n\nIt is better to make a program protocol-independent by using the \ngetaddrinfo\n function.\n\n\nError Handling: Wrapper Functions\n\n\nWe can shorten our programs by defining a \nwrapper function\n that performs the actual function call, tests the return value, and terminates on an error.\n\n\nsockfd = Socket(AF_INET, SOCK_STREAM, 0);\n\n\n\n\nWith careful C coding, we could use macros instead of functions, providing a little run-time efficiency, but these wrapper functions are rarely the performance bottleneck of a program. This book uses these wrapper functions unless otherwise explicit error needs handling.\n\n\nUnix \nerrno\n Value\n\n\nThe value of \nerrno\n is set by a function only if an error occurs. All of the positive error values are constants with all-uppercase names beginning with \"E,\" and are normally defined in the \nsys/errno.h\n header. No error has a value of 0.\n\n\nStoring errno in a global variable does not work with multiple threads that share all global variables.\n\n\nA Simple Daytime Server\n\n\n\n\ndaytimetcpsrv.c\n\n\n\n\n\n\n\nCreate a TCP socket\n\n\nIdentical to the client code.\n\n\nBind server's well-known port to socket\n\n\n\n\nbind\n: the server's well-known port (13) is bound to the socket by calling \nbind\n\n\nINADDR_ANY\n allows the server to accept a client connection on any interface\n\n\n\n\nConvert socket to listening socket\n\n\n\n\nlisten\n: converts the socket into a listening socket, on which incoming connections from clients will be accepted by the kernel\n\n\nlistenfd\n in the code is called a \nlistening descriptor\n\n\n\n\nAccept client connection, send reply\n\n\n\n\naccept\n\n\nconnfd\n in the code is called a \nconnected descriptor\n for communication with the client. A new descriptor is returned by accept for each client that connects to our server.\n\n\n\n\nThis book uses this code style for infinite loop:\n\n\nfor ( ; ; ) {\n    // . . .\n}\n\n\n\n\nsnprintf\n function\n\n\n\n\nsnprintf\n instead of \nsprintf\n\n\n\n\nSimilarly:\n\n\n\n\nfgets\n instead of \ngets\n\n\nstrncat\n or \nstrlcat\n instead of \nstrcat\n\n\nstrncpy\n or \nstrlcpy\n instead of a \nstrcpy\n\n\n\n\nTerminate connection\n\n\nclose\n initiates the normal TCP connection termination sequence: a FIN is sent in each direction and each FIN is acknowledged by the other end.\n\n\nThe server implemented in the above server code is:\n\n\n\n\nProtocol-dependent on IPv4\n\n\nHandles only one client at a time. If multiple client connections arrive at about the same time, the kernel queues them, up to some limit, and returns them to \naccept\n one at a time.\n\n\nCalled an \niterative server\n. A \nconcurrent server\n handles multiple clients at the same time.\n\n\n\n\nOSI Model\n\n\nSome terms mentioned:\n\n\n\n\nRaw socket\n: it is possible for an application to bypass the transport layer and use IPv4 or IPv6 directly\n\n\nXTI\n\n\n\n\nSockets provide the interface from the upper three layers of the OSI model into the transport layer:\n\n\n\n\nThe upper three layers handle all the details of the application. The lower four layers know little about the application, but handle all the communication details\n\n\nThe upper three layers form what is called a \nuser process\n while the lower four layers are normally provided as part of the operating system (OS) kernel\n\n\n\n\nBSD Networking History\n\n\nLinux does not fit into the Berkeley-derived classification: Its networking code and sockets API were developed from scratch.\n\n\nUnix Standards\n\n\nBackground on POSIX\n\n\n\n\nPOSIX: Portable Operating System Interface, developed by IEEE and adopted as standards by ISO and IEC (ISO/IEC)\n\n\n\n\nBackground on The Open Group\n\n\n\n\nSingle UNIX Specification\n\n\n\n\nInternet Engineering Task Force (IETF)\n\n\n64-Bit Architectures\n\n\n\n\nILP32\n: integers (I), long integers (L), and pointers (P) occupy 32 bits.\n\n\nLP64\n:only long integers (L) and pointers (P) require 64 bits.\n\n\n\n\nFrom a programming perspective, the LP64 model means we cannot assume that a pointer can be stored in an integer. We must also consider the effect of the LP64 model on existing APIs\n\n\nOn a 32-bit system, \nsize_t\n is a 32-bit value, but on a 64-bit system, it must be a 64-bit value, to take advantage of the larger addressing model. This means a 64-bit system will probably contain a typedef of \nsize_t\n to be an unsigned long.", 
            "title": "Chapter 1. Introduction"
        }, 
        {
            "location": "/unp/ch2/", 
            "text": "Chapter 2. The Transport Layer: TCP, UDP, and SCTP\n\n\nIntroduction\n\n\nThis chapter focuses on the transport layer: TCP, UDP, and Stream Control Transmission Protocol (SCTP). UDP is a simple, unreliable datagram protocol, while TCP is a sophisticated, reliable byte-stream protocol. SCTP is similar to TCP as a reliable transport protocol, but it also provides message boundaries, transport-level support for multihoming, and a way to minimize head-of-line blocking.\n\n\nThe Big Picture\n\n\nOverview of TCP/IP protocols:\n\n\n\n\n\n\n\n\nProtocol\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nIPv4\n\n\nInternet Protocol version 4. IPv4 uses 32-bit addresses and provides packet delivery service for TCP, UDP, SCTP, ICMP, and IGMP.\n\n\n\n\n\n\nIPv6\n\n\nInternet Protocol version 6. IPv6 uses 128-bit addresses.\n\n\n\n\n\n\nTCP\n\n\nTransmission Control Protocol. TCP is a connection-oriented protocol that provides a reliable, full-duplex byte stream to its users\n\n\n\n\n\n\nUDP\n\n\nUser Datagram Protocol. UDP is a connectionless protocol, and UDP sockets are an example of datagram sockets.\n\n\n\n\n\n\nSCTP\n\n\nStream Control Transmission Protocol. SCTP is a connection-oriented protocol that provides a reliable full-duplex association\n\n\n\n\n\n\nICMP\n\n\nInternet Control Message Protocol. ICMP handles error and control information between routers and hosts.\n\n\n\n\n\n\nIGMP\n\n\nInternet Group Management Protocol. IGMP is used with multicasting.\n\n\n\n\n\n\nARP\n\n\nAddress Resolution Protocol. ARP maps an IPv4 address into a hardware address (such as an Ethernet address). ARP is normally used on broadcast networks such as Ethernet, \ntoken ring\n, and \nFDDI\n, and is not needed on point-to-point networks.\n\n\n\n\n\n\nRARP\n\n\nReverse Address Resolution Protocol. RARP maps a hardware address into an IPv4 address. It is sometimes used when a diskless node is booting.\n\n\n\n\n\n\nICMPv6\n\n\nInternet Control Message Protocol version 6. ICMPv6 combines the functionality of ICMPv4, IGMP, and ARP.\n\n\n\n\n\n\nBPF\n\n\nBSD packet filter\n. This interface provides access to the datalink layer. It is normally found on Berkeley-derived kernels.\n\n\n\n\n\n\nDLPI\n\n\nDatalink provider interface\n.\n\n\n\n\n\n\n\n\nUser Datagram Protocol (UDP)\n\n\n\n\nLack of reliability\n\n\nEach UDP datagram has a length\n\n\nConnectionless\n service\n\n\n\n\nTransmission Control Protocol (TCP)\n\n\n\n\nConnection\n: TCP provides connections between clients and servers. A TCP client establishes a connection with a server, exchanges data across the connection, and then terminates the connection.\n\n\nReliability\n: TCP requires acknowledgment when sending data. If an acknowledgment is not received, TCP automatically retransmits the data and waits a longer amount of time.\n\n\nRound-trip time\n (RTT): TCP estimates RTT between a client and server dynamically so that it knows how long to wait for an acknowledgment.\n\n\nSequencing\n: TCP associates a sequence number with every byte (\nsegment\n, unit of data that TCP passes to IP.) it sends. TCP reorders out-of-order segments and discards duplicate segments.\n\n\nFlow control\n\n\nFull-duplex\n: an application can send and receive data in both directions on a given connection at any time.\n\n\n\n\nStream Control Transmission Protocol (SCTP)\n\n\nLike TCP, SCTP provides reliability, sequencing, flow control, and full-duplex data transfer.\n\n\nUnlike TCP, SCTP provides:\n\n\n\n\nAssociation\n instead of \"connection\": An association refers to a communication between two systems, which may involve more than two addresses due to multihoming.\n\n\nMessage-oriented\n: provides sequenced delivery of individual records. Like UDP, the length of a record written by the sender is passed to the receiving application.\n\n\nMultihoming\n: allows a single SCTP endpoint to support multiple IP addresses. This feature can provide increased robustness against network failure.\n\n\n\n\nTCP Connection Establishment and Termination\n\n\nThree-Way Handshake\n\n\n\n\n\n\nServer: \npassive open\n, by calling \nsocket\n, \nbind\n, and \nlisten\n\n\nClient: \nactive open\n, by calling \nconnect\n. The client TCP to send a \"synchronize\" (SYN) segment with no data but it contains client's initial sequence number for the data to be sent on the connection.\n\n\nServer: acknowledges (ACK) client's SYN. The server sends its SYN and the ACK of the client's SYN in a single segment which also contains its own SYN containing the initial sequence number for the data to be sent on the connection.\n\n\nClient: acknowledges the server's SYN.\n\n\n\n\nThe client's initial sequence number as \nJ\n and the server's initial sequence number as \nK\n. The acknowledgment number in an ACK is the next expected sequence number for the end sending the ACK. Since a SYN occupies one byte of the sequence number space, the acknowledgment number in the ACK of each SYN is the initial sequence number plus one.\n\n\nTCP Options\n\n\n\n\nMSS option. The TCP sending the SYN announces its \nmaximum segment size\n (the maximum amount of data that it is willing to accept in each TCP segment)on this connection.\n\n\nWindow scale option. [p38]\n\n\nTimestamp option\n\n\n\n\nTCP Connection Termination\n\n\n\n\nIt takes four segments to terminate a connection:\n\n\n\n\nOne end calls \nclose\n first by sending a FIN segment to mean it is finished sending data. This is called \nactive close\n.\n\n\nThe other end that receives the FIN performs the \npassive close\n. The received FIN is acknowledged by TCP (sending an ACK segment). The receipt of the FIN is also passed to the application as an end-of-file.\n\n\nSometime later, the application that received the end-of-file will close its socket. This causes its TCP to send a FIN.\n\n\nThe TCP on the system that receives this final FIN (the end that did the active close) acknowledges the FIN\n\n\n\n\nA FIN occupies one byte of sequence number space just like a SYN. Therefore, the ACK of each FIN is the sequence number of the FIN plus one.\n\n\nTCP State Transition Diagram\n\n\n\n\nThere are 11 different states defined for a connection and the rules of TCP dictate the transitions from one state to another, based on the current state and the segment received in that state.\n\n\nWatching the Packets\n\n\n\n\nThe client in this example announces an MSS of 536 (\nminimum reassembly buffer size\n) and the server announces an MSS of 1,460 (typical for IPv4 on an Ethernet). It is okay for the MSS to be different in each direction. The acknowledgment of the client's request is sent with the server's reply. This is called \npiggybacking\n and will normally happen when the time it takes the server to process the request and generate the reply is less than around 200 ms. \nWith TCP, there would be eight segments of overhead. If UDP was used, only two packets would be exchanged.\n\n\n\n\nUDP removes all the reliability that TCP provides to the application.\n\n\nUDP avoids the overhead of TCP connection establishment and connection termination.\n\n\n\n\nTIME_WAIT State\n\n\nThe end that performs the active close goes through the TIME_WAIT state. The duration that this endpoint remains in the TIME_WAIT state is twice the \nmaximum segment lifetime\n (MSL), sometimes called 2MSL, which is between 1 and 4 minutes. The MSL is the maximum amount of time that any given IP datagram can live in a network. The IPv4 TTL field  IPv6 hop limit field have a maximum value 255. The assumption is made that a packet with the maximum hop limit of 255 cannot exist in a network for more than MSL seconds. [p43]\n\n\nTCP must handle \nlost duplicates\n (or \nwandering duplicate\n).\n\n\nThere are two reasons for the TIME_WAIT state:\n\n\n\n\nTo implement TCP's full-duplex connection termination reliably. If TCP is performing all the work necessary to terminate both directions of data flow cleanly for a connection (its full-duplex close), then it must correctly handle the loss of any of these four segments.\n\n\nTo allow old duplicate segments to expire in the network. When we successfully establish a TCP connection, all old duplicates from previous \nincarnations\n of the connection have expired in the network.\n\n\n\n\nPort Numbers\n\n\nAll three transport layers (UDP, SCTP and TCP) use 16-bit integer port numbers to differentiate between processes.\n\n\n\n\nThe \nwell-known ports\n: 0 through 1023.\n\n\nThe \nregistered ports\n: 1024 through 49151\n\n\nThe \ndynamic ports\n or \nprivate ports\n, 49152 through 65535. Also called \nephemeral ports\n.\n\n\n\n\nSocket Pair\n\n\n\n\nSocket pair\n: the four-tuple that defines the two endpoints of a TCP connection: the local IP address, local port, foreign IP address, and foreign port. A socket pair uniquely identifies every TCP connection on a network.\n\n\nSocket\n: two values (an IP address and a port number) that identify each endpoint.\n\n\n\n\nTCP Port Numbers and Concurrent Servers\n\n\n[p52-55]\n\n\nBuffer Sizes and Limitations\n\n\nFigures: \nIPv4 Header\n, \nIPv6 Header\n\n\n\n\nMaximum size of an IPv4 datagram: 65,535 bytes (including the header), because of the 16-bit total length field.\n\n\nMaximum size of an IPv6 datagram: 65,575 bytes (including the 40-byte IPv6 header), because of the 16-bit payload length field. IPv6 has a jumbo payload option, which extends the payload length field to 32 bits, but this option is supported only on datalinks with a \nmaximum transmission unit\n (MTU) that exceeds 65,535.\n\n\nMTU\n (maximum transmission unit): dictated by the hardware. Ethernet MTU is 1,500 bytes; Point-to-point links have a configurable MTU.\n\n\nMinimum link MTU for IPv4: 68 bytes. This permits a maximum-sized IPv4 header (20 bytes of fixed header, 40 bytes of options)  and minimum-sized fragment (the fragment offset is in units of 8 bytes) \n[errata]\n\n\nMinimum link MTU for IPv6: 1,280 bytes.\n\n\n\n\n\n\nPath MTU\n: smallest MTU in the path between two hosts. Today, the Ethernet MTU of 1,500 bytes is often the path MTU. The path MTU need not be the same in both directions between any two hosts because routing in the Internet is often asymmetric.\n\n\nFragmentation\n is performed by both IPv4 and IPv6 when the size of an IP datagram to be sent out an interface exceeds the link MTU. The fragments are not normally \nreassembled\n until they reach the final destination.\n\n\nIPv4: hosts perform fragmentation on datagrams that they generate and routers perform fragmentation on datagrams that they forward\n\n\nIPv6: only hosts perform fragmentation on datagrams that they generate; routers do not fragment datagrams that they are forwarding\n\n\nIPv4 header contains fields to handle fragmentation. IPv6 contains an option header with the fragmentation information.\n\n\n\n\n\n\n\"Don't Fragment\" (DF) bit in IPv4 header specifies that this datagram must not be fragmented, either by the sending host or by any router. A router that receives an IPv4 datagram with the DF bit set whose size exceeds the outgoing link's MTU generates an ICMPv4 \"destination unreachable, fragmentation needed but DF bit set\" error message.\n\n\nSince IPv6 routers do not perform fragmentation, there is an implied DF bit with every IPv6 datagram. When an IPv6 router receives a datagram whose size exceeds the outgoing link's MTU, it generates an ICMPv6 \"packet too big\" error message\n\n\nPath MTU discovery\n uses IPv4 DF bit and its implied IPv6 counterpart. Path MTU discovery is optional with IPv4, but IPv6 implementations all either support path MTU discovery or always send using the minimum MTU. [p55]\n\n\n\n\n\n\nMinimum reassembly buffer size\n: the minimum datagram size that we are guaranteed any implementation must support.\n\n\nIPv4: 576 bytes. We have no idea whether a given destination can accept a 577-byte datagram or not. Therefore, many IPv4 applications that use UDP (e.g., DNS, RIP, TFTP, BOOTP, SNMP) prevent applications from generating IP datagrams that exceed this size.\n\n\nIPv6: 1,500 bytes\n\n\n\n\n\n\nTCP has a \nmaximum segment size\n (MSS) that announces to the peer TCP the maximum amount of TCP data that the peer can send per segment. We saw the MSS option on the SYN segments in \nFigure 2.5\n. The goal of the MSS is to tell the peer the actual value of the reassembly buffer size and to try to avoid fragmentation. The MSS is often set to the interface MTU minus the fixed sizes of the IP and TCP headers. On an Ethernet using IPv4, this would be 1,460, and on an Ethernet using IPv6, this would be 1,440. (The TCP header is 20 bytes for both, but the IPv4 header is 20 bytes and the IPv6 header is 40 bytes.)\n\n\nIPv4: The MSS value in the TCP MSS option is a 16-bit field, limiting the value to 65,535. The maximum amount of TCP data in an IPv4 datagram is 65,495 (65,535 minus the 20-byte IPv4 header and minus the 20-byte TCP header).\n\n\nIPv6: the maximum amount of TCP data in an IPv6 datagram without the jumbo payload option is 65,515 (65,535 minus the 20-byte TCP header). The MSS value of 65,535 is considered a special case that designates \"infinity.\" This value is used only if the jumbo payload option is being used, which requires an MTU that exceeds 65,535.\n\n\n\n\n\n\n\n\nTCP Output\n\n\nEvery TCP socket has a send buffer and we can change the size of this buffer with the \nSO_SNDBUF\n socket option. When an application calls \nwrite\n, the kernel copies all the data from the application buffer into the socket send buffer. If there is insufficient room in the socket buffer for all the application's data, the process is put to sleep. This assumes the normal default of a blocking socket. The kernel will not return from the write until the final byte in the application buffer has been copied into the socket send buffer. Therefore, \nthe successful return from a write to a TCP socket only tells us that we can reuse our application buffer. It does not tell us that either the peer TCP has received the data or that the peer application has received the data.\n\n\nTCP takes the data in the socket send buffer and sends it to the peer TCP.\n The peer TCP must acknowledge the data, and as the ACKs arrive from the peer, only then can our TCP discard the acknowledged data from the socket send buffer. TCP must keep a copy of our data until it is acknowledged by the peer.\n\n\nTCP sends the data to IP in MSS-sized or smaller chunks, prepending its TCP header to each segment, where the MSS is the value announced by the peer, or 536 if the peer did not send an MSS option. IP prepends its header, searches the routing table for the destination IP address, and passes the datagram to the appropriate datalink. IP might perform fragmentation before passing the datagram to the datalink, but one goal of the MSS option is to try to avoid fragmentation and newer implementations also use path MTU discovery. Each datalink has an output queue, and if this queue is full, the packet is discarded and an error is returned up the protocol stack [p58]\n\n\nUDP Output\n\n\nUDP socket doesn't have a socket send buffer, since it does not need to keep a copy of the application's data. It has a send buffer size (which we can change with the \nSO_SNDBUF\n socket option), but this is simply an upper limit on the maximum-sized UDP datagram that can be written to the socket. If an application writes a datagram larger than the socket send buffer size, \nEMSGSIZE\n is returned.\n\n\nUDP simply prepends its 8-byte header and passes the datagram to IP. IP determines the outgoing interface by performing the routing function, and then either adds the datagram to the datalink output queue (if it fits within the MTU) or fragments the datagram and adds each fragment to the datalink output queue (see \nUDP and IP Fragmentation in TCPv1\n). If a UDP application sends large datagrams, there is a much higher probability of (IP) fragmentation than with TCP.\n\n\nStandard Internet Services\n\n\nProtocol Usage by Common Internet Applications", 
            "title": "Chapter 2. The Transport Layer: TCP, UDP, and SCTP"
        }, 
        {
            "location": "/unp/ch3/", 
            "text": "Chapter 3. Sockets Introduction\n\n\nIntroduction\n\n\nThis chapter begins the description of the sockets API.\n\n\nSocket Address Structures\n\n\nThe name of socket address structures begin with \nsockaddr_\n and end with a unique suffix for each protocol suite.\n\n\nIPv4 Socket Address Structure\n\n\nAn IPv4 socket address structure, commonly called an \"Internet socket address structure\", is named \nsockaddr_in\n and is defined by including the \nnetinet/in.h\n header.\n\n\nstruct in_addr {\n  in_addr_t   s_addr;           /* 32-bit IPv4 address */\n                                /* network byte ordered */\n};\n\nstruct sockaddr_in {\n  uint8_t         sin_len;      /* length of structure (16) */\n  sa_family_t     sin_family;   /* AF_INET */\n  in_port_t       sin_port;     /* 16-bit TCP or UDP port number */\n                                /* network byte ordered */\n  struct in_addr  sin_addr;     /* 32-bit IPv4 address */\n                                /* network byte ordered */\n  char            sin_zero[8];  /* unused */\n};\n\n\n\n\n\n\nsin_len\n: the length field. We need never set it and need never examine it.\n\n\nThe four socket functions that pass a socket address structure from the process to the kernel, \nbind\n, \nconnect\n, \nsendto\n, and \nsendmsg\n, all go through the \nsockargs\n function in a Berkeley-derived implementation. This function copies the socket address structure from the process and explicitly sets its ~sin_len~ member to the size of the structure that was passed as an argument to these four functions. The five socket functions that pass a socket address structure from the kernel to the process, \naccept\n, \nrecvfrom\n, \nrecvmsg\n, \ngetpeername\n, and \ngetsockname\n, all set the \nsin_len\n member before returning to the process.\n\n\n\n\n\n\nPOSIX requires only three members in the structure: \nsin_family\n, \nsin_addr\n, and \nsin_port\n. Almost all implementations add the sin_zero member so that all socket address structures are at least 16 bytes in size.\n\n\nThe \nin_addr_t\n datatype must be an unsigned integer type of at least 32 bits, \nin_port_t\n must be an unsigned integer type of at least 16 bits, and \nsa_family_t\n can be any unsigned integer type. The latter is normally an 8-bit unsigned integer if the implementation supports the length field, or an unsigned 16-bit integer if the length field is not supported.\n\n\nBoth the IPv4 address and the TCP or UDP port number are always stored in the structure in \nnetwork byte order\n.\n\n\nThe \nsin_zero\n member is unused. By convention, we always set the entire structure to 0 before filling it in.\n\n\nSocket address structures are used only on a given host: The structure itself is not communicated between different hosts", 
            "title": "Chapter 3. Sockets Introduction"
        }, 
        {
            "location": "/icnd1/part1/", 
            "text": "Part I: Networking Fundamentals\n\n\nChapter 1. Introduction to Computer Networking\n\n\nChapter 2. The TCP/IP and OSI Networking Models\n\n\nTCP/IP Networking Model\n\n\nA \nnetworking model\n (\nnetworking architecture\n or \nnetworking blueprint\n), refers to a comprehensive set of documents that define everything that should happen for a computer network to work.\n\n\nThe TCP/IP model both defines and references a large collection of protocols that allow computers to communicate. TCP/IP uses documents called \nRequests for Comments\n (RFC).\n\n\nData Encapsulation Terminology\n\n\n\n\n\n\nCreate and encapsulate the application data with any required application layer headers.\n\n\nEncapsulate the data supplied by the application layer inside a transport layer header. \n\n\nEncapsulate the data supplied by the transport layer inside an Internet layer (IP) header.\n\n\nEncapsulate the data supplied by the Internet layer inside a data link layer header and trailer. This is the only layer that uses both a \nheader\n and a \ntrailer\n.\n\n\nTransmit the bits.\n\n\n\n\nOSI Networking Model\n\n\n\n\nDescribing Protocols by Referencing the OSI Layers\n\n\nNetworking documents often describe TCP/IP protocols and standards by referencing OSI layers, both by layer number and layer name. For instance, a common description of a LAN switch is \u201clayer 2 switch,\u201d with \u201clayer 2\u201d referring to OSI layer 2.\n\n\n\n\n\n\n\n\nLayer Name\n\n\nProtocols and Specifications\n\n\nDevices\n\n\n\n\n\n\n\n\n\n\nApplication, presentation, session (Layers 5\u20137)\n\n\nTelnet, HTTP, FTP, SMTP, POP3, VoIP, SNMP\n\n\nFirewall, intrusion detection systems, hosts\n\n\n\n\n\n\nTransport (Layer 4)\n\n\nTCP, UDP\n\n\nHosts, firewalls\n\n\n\n\n\n\nNetwork (Layer 3)\n\n\nIP\n\n\nRouter\n\n\n\n\n\n\nData link (Layer 2)\n\n\nEthernet (IEEE 802.3), HDLC, Frame Relay, PPP\n\n\nLAN switch, wireless access point, cable modem, DSL modem\n\n\n\n\n\n\nPhysical (Layer 1)\n\n\nRJ-45, EIA/TIA-232, V.35, Ethernet (IEEE 802.3)\n\n\nLAN hub, LAN repeater, cables\n\n\n\n\n\n\n\n\nOSI Layering Concepts and Benefits\n\n\n[p41]\n\n\n\n\nLess complex\n\n\nStandard interfaces\n\n\nEasier to learn\n\n\nEasier to develop\n\n\nMultivendor interoperability\n\n\nModular engineering\n\n\n\n\nOSI Encapsulation Terminology\n\n\n\n\nThe TCP/IP model uses terms such as \nsegment\n, \npacket\n, and \nframe\n to refer to various layers and their respective encapsulated data. OSI uses a more generic term: \nprotocol data unit\n (PDU).\n\n\nChapter 3. Fundamentals of LANs\n\n\nAn Overview of Modern Ethernet LANs\n\n\nTypes of cabling:\n\n\n\n\nUnshielded Twisted-Pair\n (UTP)\n\n\nFiber-optic\n\n\n\n\nMost IEEE standards define a different variation of Ethernet at the physical layer. \nFor the data link layer:\n\n\n\n\n802.3 Media Access Control (MAC) sublayer\n\n\n802.2 Logical Link Control (LLC) sublayer\n\n\n\n\n[p52]\n\n\n\n\n\n\n\n\nCommon Name\n\n\nSpeed\n\n\nAlternative Name\n\n\nName of IEEE Standard\n\n\nCable Type, Maximum Length\n\n\n\n\n\n\n\n\n\n\nEthernet\n\n\n10 Mbps\n\n\n10BASE-T\n\n\nIEEE 802.3\n\n\nCopper, 100 m\n\n\n\n\n\n\nFast Ethernet\n\n\n100 Mbps\n\n\n100BASE-TX\n\n\nIEEE 802.3u\n\n\nCopper, 100 m\n\n\n\n\n\n\nGigabit Ethernet\n\n\n1000 Mbps\n\n\n1000BASE-LX, 1000BASE-SX\n\n\nIEEE 802.3z\n\n\nFiber, 550 m (SX) 5 km (LX)\n\n\n\n\n\n\nGigabit Ethernet\n\n\n1000 Mbps\n\n\n1000BASE-T\n\n\nIEEE 802.3ab\n\n\n100 m\n\n\n\n\n\n\n\n\nThe term Ethernet is often used to mean \"all types of Ethernet\", but in some cases it is used to mean \"10BASE-T Ethernet\"\n\n\nA Brief History of Ethernet\n\n\n\n\nCarrier sense multiple access with collision detection (CSMA/CD) algorithm\n\n\n\n\nRepeaters\n\n\nRepeaters\n extended the length of LANs by cleaning up the electrical signal and repeating it (a Layer 1 function) but without interpreting the meaning of the electrical signal. [p56]\n\n\nBuilding 10BASE-T Networks with Hubs\n\n\nHubs\n are essentially repeaters with multiple physical ports. It simply regenerates the electrical signal that comes in one port and sends the same signal out every other port.\n\n\nEthernet UTP Cabling\n\n\nTransmitting Data Using Twisted Pairs\n\n\nUTP cabling consists of matched pairs of wires that are indeed twisted together, with current on the two wires in opposite directions.\n\n\nUTP Cabling Pinouts for \n10BASE-T and 100BASE-TX\n\n\n10BASE-T and 100BASE-TX Ethernet define that one pair should be used to send data in one direction, with the other pair used to send data in the other direction.\n\n\nThe wires in the UTP cable must be connected to the correct \npin positions\n in the RJ-45 connectors in order for communication to work correctly. \n\n\n[p62-64]\n\n\nThe following applies to 10BASE-T and 100BASE-TX only:\n\n\n\n\nEthernet \nstraight-through cable\n: both ends of the cable use the same EIA/TIA pinout standard on each end of the cable. A straight-through cable is used when the devices on the ends of the cable use opposite pins when they transmit data.\n\n\nEthernet \ncrossover cable\n:  two devices both use the same pins to transmit and the pinouts of the cable are set up to swap the wire pair\n\n\n\n\n\n\n\n\n\n\nDevices That Transmit on 1,2 and Receive on 3,6\n\n\nDevices That Transmit on 3,6 and Receive on 1,2\n\n\n\n\n\n\n\n\n\n\nPC NICs\n\n\nHubs\n\n\n\n\n\n\nRouters\n\n\nSwitches\n\n\n\n\n\n\nWireless Access Point (Ethernet interface)\n\n\n\u2014\n\n\n\n\n\n\nNetworked printers (printers that connect directly to the LAN)\n\n\n\u2014\n\n\n\n\n\n\n\n\n1000BASE-T Cabling\n\n\n1000BASE-T differs from 10BASE-T and 100BASE-TX as far as the cabling and pinouts:\n\n\n\n\nReequires four wire pairs\n\n\nTransmits and receives on each of the four wire pairs simultaneously\n\n\nHas no concept of straight-through and crossover cables\n\n\n\n\nImproving Performance by Using Switches Instead of Hubs\n\n\nCSMA/CD logic helps prevent collisions and also defines how to act when a collision does occur:\n\n\n\n\nA device with a frame to send listens until the Ethernet is not busy.\n\n\nWhen the Ethernet is not busy, the sender(s) begin(s) sending the frame.\n\n\nThe sender(s) listen(s) to make sure that no collision occurred.\n\n\nIf a collision occurs, the devices that had been sending a frame each send a jamming signal to ensure that all stations recognize the collision.\n\n\nAfter the jamming is complete, each sender randomizes a timer and waits that long before trying to resend the collided frame. When each random timer expires, the process starts over with Step 1.\n\n\n\n\nIncreasing Available Bandwidth Using Switches\n\n\nThe term \ncollision domain\n defines the set of devices whose frames could collide. For example, all devices connected to the hub are in the same collision domain. To avoid collisions, and to recover when they occur, devices in the same collision domain use CSMA/CD.\n\n\nSwitches\n significantly reduce, or even eliminate, the number of collisions on a LAN:\n\n\n\n\nSwitches interpret the bits in the received frame so that they can typically send the frame out the one required port, rather than all other ports\n\n\nIf a switch needs to forward multiple frames out the same port, the switch buffers the frames in memory, sending one at a time, thereby avoiding collisions\n\n\n\n\nThe switch\u2019s logic requires that the switch look at the Ethernet header, which is considered a Layer 2 feature. As a result, switches are considered to operate as a Layer 2 device, whereas hubs are Layer 1 devices.\n\n\nBuffering (temporarily holds the frame in memory) also helps prevent collisions.\n\n\nSwitch features provide significant performance improvements:\n\n\n\n\nIf only one device is cabled to each port of a switch, no collisions can occur.\n\n\nDevices connected to one switch port do not share their bandwidth with devices connected to another switch port. Each has its own separate bandwidth, meaning that a switch with 100-Mbps ports has 100 Mbps of bandwidth \nper port\n.\n\n\n\n\nShared Ethernet vs. Switched Ethernet\n\n\n\n\nShared Ethernet\n: bandwidth is shared among the devices on the LAN because they must take turns using the LAN because of the CSMA/CD algorithm. A hub with 24 100-Mbps Ethernet devices connected to it allows for a theoretical maximum of 100 Mbps of bandwidth\n\n\nSwitched Ethernet\n: bandwidth does not have to be shared, allowing for far greater performance. A switch with 24 100-Mbps Ethernet devices connected to it supports 100 Mbps for each port, or 2400 Mbps (2.4 Gbps) theoretical maximum bandwidth.\n\n\n\n\nDoubling Performance by Using Full-Duplex Ethernet\n\n\nIn an Ethernet network using hubs, CSMA/CD imposes \nhalf-duplex\n logic on each device, meaning that only one device can send at a time. LAN switches with only one device cabled to each port of the switch allow the use of \nfull-duplex\n operation; Ethernet card can send and receive concurrently.\n\n\nEthernet Data-Link Protocols\n\n\nEthernet Addressing\n\n\n\n\n\n\n\n\nLAN Addressing Term or Feature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nMAC\n\n\nMedia Access Control. 802.3 (Ethernet) defines the MAC sublayer of IEEE Ethernet.\n\n\n\n\n\n\nEthernet address, NIC address, LAN address\n\n\nOther names often used instead of MAC address. These terms describe the 6-byte address of the LAN interface card.\n\n\n\n\n\n\nBurned-in address\n\n\nThe 6-byte address assigned by the vendor making the card.\n\n\n\n\n\n\nUnicast address\n\n\nA term for a MAC that represents a single LAN interface.\n\n\n\n\n\n\nBroadcast address\n\n\nAn address that means \u201call devices that reside on this LAN right now.\u201d (FFFF.FFFF.FFFF)\n\n\n\n\n\n\nMulticast address\n\n\nOn Ethernet, a multicast address implies some subset of all devices currently on the Ethernet LAN. (0100.5exx.xxxx, any value can be used in the last half)\n\n\n\n\n\n\n\n\nEthernet Framing\n\n\nFraming\n defines the meaning of the bits transmitted and received over a network.\n\n\n\n\n\n\nData\n field holds Layer 3 packets (L3 PDU)\n\n\nMaximum transmission unit\n (MTU) defines the maximum Layer 3 packet that can be sent over a medium. 1500 bytes is the largest IP MTU allowed over an Ethernet.\n\n\n\n\nIdentifying the Data Inside an Ethernet Frame\n\n\nType/Length\n filed:\n\n\n\n\nLength\n field: with a value less than hex 0600 (decimal 1536); another field is needed to identify the type of L3 PDU inside the frame.\n\n\nType\n field: value of hexadecimal 0800 (decimal 2048) implies an IP packet\n\n\n\n\nError Detection\n\n\nErrors (bit changes) occur due to electrical interference. Trailer containing a \nFrame Check Sequence\n (FCS) field used for error detection.\n\n\nChapter 4. Fundamentals of WANs\n\n\nThe WAN topics in this chapter describe mainly how enterprise networks use WANs to connect remote sites.\n\n\nOSI Layer 1 for Point-to-Point WANs\n\n\n\n\nLeased line\n or \nleased circuit\n: WAN cable, line or point-to-point connection that is paid for use\n\n\nTelephone company (telco), or public telephone and telegraph (PTT)\n\n\nService provider\n: a company that provides any form of WAN connectivity, including Internet services.\n\n\n\n\nRouters provide the capability to connect many different types of OSI Layer 1 and Layer 2 technologies. A router is connected to each end of a WAN connection.\n\n\n\n\n\n\nCentral Office (CO): a building where the telco locates the devices used to create its own network\n\n\nChannel service unit/data service (\nCSU/DSU\n)\n\n\ndemarc\n (\ndemarcation point\n): he point at which the telco\u2019s responsibility is on one side and the customer\u2019s responsibility is on the other\n\n\nCustomer premises equipment\n (CPE): devices that are at the customer site\n\n\n\n\nWAN Cabling Standards\n\n\n[p84]\n\n\nClock Rates, Synchronization, DCE, and DTE\n\n\n[p86]\n\n\n\n\nSynchronization: various devices need to synchronize their clocks so that they run at exactly the same speed to make a link work\n\n\nData communications equipment (DCE): device that provides clocking, typically the CSU/DSU\n\n\nData terminal equipment (DTE): device receiving clocking, typically the router\n\n\n\n\nLink Speeds\n\n\n\n\n\n\n\n\nName(s) of Line\n\n\nBit Rate\n\n\n\n\n\n\n\n\n\n\nDS0\n\n\n64 kbps\n\n\n\n\n\n\nDS1 (T1)\n\n\n1.544 Mbps (24 DS0s, plus 8 kbps overhead)\n\n\n\n\n\n\nDS3 (T3)\n\n\n44.736 Mbps (28 DS1s, plus management overhead)\n\n\n\n\n\n\nE1\n\n\n2.048 Mbps (32 DS0s)\n\n\n\n\n\n\nE3\n\n\n34.368 Mbps (16 E1s, plus management overhead)\n\n\n\n\n\n\nJ1 (Y1)\n\n\n2.048 Mbps (32 DS0s; Japanese standard)\n\n\n\n\n\n\n\n\nOSI Layer 2 for Point-to-Point WANs\n\n\nHDLC\n\n\n\n\nHigh-Level Data Link Control\n (HDLC) defines framing to:\n\n\n\n\nDelivers data across the link \n\n\nCheck for errors\n\n\nIdentify the packet type\n\n\n\n\nPoint-to-Point Protocol\n\n\nPoint-to-Point Protocol (PPP) behaves much like HDLC. The framing looks identical to the Cisco proprietary HDLC framing. PPP has become the most popular and feature-rich of WAN data link layer protocols. [p91]\n\n\nPoint-to-Point WAN Summary\n\n\nWAN Terminology [p91-92]\n\n\n\n\nSynchronous: The imposition of time ordering on a bit stream\n\n\nClock source: The device to which the other devices on the link adjust their speed when using synchronous links\n\n\nCSU/DSU: Used on digital links as an interface to the telephone company in the United States. Routers typically use a short cable from a serial interface to a CSU/DSU, which is attached to the line from the telco\n\n\nTelco\n\n\nFour-wire circuit: A line from the telco with four wires, composed of two twisted-pair wires. Each pair is used to send in one direction, so a four-wire circuit allows full-duplex communication.\n\n\nT1\n\n\nE1\n\n\n\n\nAll the following terms may be used to refer to a point-to-point leased line:\n\n\n\n\nleased line\n\n\nleased circuit\n\n\nlink\n\n\nserial link\n\n\nserial line\n\n\npoint-to-point link\n\n\ncircuit\n\n\n\n\nFrame Relay and Packet-Switching Services\n\n\nPacket-switching service\n: a company can connect a large number of routers using a single serial link from each router into the packet-switching service. Once connected, each router can send packets to all the other routers\u2014much like all the devices connected to an Ethernet hub or switch can send data directly to each other.\n\n\nTwo types of packet-switching service are very popular today:\n\n\n\n\nFrame Relay: much more common\n\n\nAsynchronous Transfer Mode (ATM)\n\n\n\n\nChapter 5. Fundamentals of IPv4 Addressing and Routing\n\n\n\n\nRouting: the process of forwarding packets (Layer 3 PDUs).\n\n\nLogical addressing: enables the routing process to identify a packet\u2019s source and destination.\n\n\nRouting protocol: aids routers by dynamically learning about the groups of addresses in the network, which in turn allows the routing (forwarding) process to work well.\n\n\nOther utilities: The network layer also relies on other utilities: Domain Name System (DNS), Dynamic Host Configuration Protocol (DHCP), Address Resolution Protocol (ARP), and ping.\n\n\n\n\nPath selection\n sometimes is used to mean:\n\n\n\n\nRouting protocol\n\n\nRouting (forwarding) of packets\n\n\n\n\nOverview of Network Layer Functions\n\n\nToday, the only Layer 3 protocol that is used widely is the TCP/IP network layer protocol, specifically, IP.  IP does not require any overhead agreements or messages before sending a packet, making IP a connectionless protocol, with no error recovery.\n\n\nRouting (Forwarding)\n\n\nRouting focuses on the end-to-end logic of forwarding data.\n\n\nThe routing table for any particular network layer protocol contains a list of network layer address groupings. Instead of a single entry in the routing table per individual destination network layer address, there is one routing table entry per group.\n\n\nNetwork Layer Interaction with the Data Link Layer\n\n\nThe routing process forwards the packet, and only the packet, end-to-end through the network, discarding data-link headers and trailers along the way.\n\n\nRouters build new data-link headers and trailers and because the new headers contain data-link addresses, the PCs and routers must decide what data-link addresses to use. The Address Resolution Protocol (ARP) is used to dynamically learn the data-link address of an IP host connected to a LAN.\n\n\nRouting as covered so far has two main concepts:\n\n\n\n\nThe process of routing forwards Layer 3 packets, also called Layer 3 protocol data units (L3 PDU), based on the destination Layer 3 address in the packet.\n\n\nThe routing process uses the data link layer to encapsulate the Layer 3 packets into Layer 2 frames for transmission across each successive data link.", 
            "title": "ICND1 Part I: Networking Fundamentals"
        }, 
        {
            "location": "/icnd1/part1/#chapter-1-introduction-to-computer-networking", 
            "text": "", 
            "title": "Chapter 1. Introduction to Computer Networking"
        }, 
        {
            "location": "/icnd1/part1/#chapter-2-the-tcpip-and-osi-networking-models", 
            "text": "TCP/IP Networking Model  A  networking model  ( networking architecture  or  networking blueprint ), refers to a comprehensive set of documents that define everything that should happen for a computer network to work.  The TCP/IP model both defines and references a large collection of protocols that allow computers to communicate. TCP/IP uses documents called  Requests for Comments  (RFC).  Data Encapsulation Terminology    Create and encapsulate the application data with any required application layer headers.  Encapsulate the data supplied by the application layer inside a transport layer header.   Encapsulate the data supplied by the transport layer inside an Internet layer (IP) header.  Encapsulate the data supplied by the Internet layer inside a data link layer header and trailer. This is the only layer that uses both a  header  and a  trailer .  Transmit the bits.   OSI Networking Model   Describing Protocols by Referencing the OSI Layers  Networking documents often describe TCP/IP protocols and standards by referencing OSI layers, both by layer number and layer name. For instance, a common description of a LAN switch is \u201clayer 2 switch,\u201d with \u201clayer 2\u201d referring to OSI layer 2.     Layer Name  Protocols and Specifications  Devices      Application, presentation, session (Layers 5\u20137)  Telnet, HTTP, FTP, SMTP, POP3, VoIP, SNMP  Firewall, intrusion detection systems, hosts    Transport (Layer 4)  TCP, UDP  Hosts, firewalls    Network (Layer 3)  IP  Router    Data link (Layer 2)  Ethernet (IEEE 802.3), HDLC, Frame Relay, PPP  LAN switch, wireless access point, cable modem, DSL modem    Physical (Layer 1)  RJ-45, EIA/TIA-232, V.35, Ethernet (IEEE 802.3)  LAN hub, LAN repeater, cables     OSI Layering Concepts and Benefits  [p41]   Less complex  Standard interfaces  Easier to learn  Easier to develop  Multivendor interoperability  Modular engineering   OSI Encapsulation Terminology   The TCP/IP model uses terms such as  segment ,  packet , and  frame  to refer to various layers and their respective encapsulated data. OSI uses a more generic term:  protocol data unit  (PDU).", 
            "title": "Chapter 2. The TCP/IP and OSI Networking Models"
        }, 
        {
            "location": "/icnd1/part1/#chapter-3-fundamentals-of-lans", 
            "text": "An Overview of Modern Ethernet LANs  Types of cabling:   Unshielded Twisted-Pair  (UTP)  Fiber-optic   Most IEEE standards define a different variation of Ethernet at the physical layer. \nFor the data link layer:   802.3 Media Access Control (MAC) sublayer  802.2 Logical Link Control (LLC) sublayer   [p52]     Common Name  Speed  Alternative Name  Name of IEEE Standard  Cable Type, Maximum Length      Ethernet  10 Mbps  10BASE-T  IEEE 802.3  Copper, 100 m    Fast Ethernet  100 Mbps  100BASE-TX  IEEE 802.3u  Copper, 100 m    Gigabit Ethernet  1000 Mbps  1000BASE-LX, 1000BASE-SX  IEEE 802.3z  Fiber, 550 m (SX) 5 km (LX)    Gigabit Ethernet  1000 Mbps  1000BASE-T  IEEE 802.3ab  100 m     The term Ethernet is often used to mean \"all types of Ethernet\", but in some cases it is used to mean \"10BASE-T Ethernet\"  A Brief History of Ethernet   Carrier sense multiple access with collision detection (CSMA/CD) algorithm   Repeaters  Repeaters  extended the length of LANs by cleaning up the electrical signal and repeating it (a Layer 1 function) but without interpreting the meaning of the electrical signal. [p56]  Building 10BASE-T Networks with Hubs  Hubs  are essentially repeaters with multiple physical ports. It simply regenerates the electrical signal that comes in one port and sends the same signal out every other port.  Ethernet UTP Cabling  Transmitting Data Using Twisted Pairs  UTP cabling consists of matched pairs of wires that are indeed twisted together, with current on the two wires in opposite directions.  UTP Cabling Pinouts for  10BASE-T and 100BASE-TX  10BASE-T and 100BASE-TX Ethernet define that one pair should be used to send data in one direction, with the other pair used to send data in the other direction.  The wires in the UTP cable must be connected to the correct  pin positions  in the RJ-45 connectors in order for communication to work correctly.   [p62-64]  The following applies to 10BASE-T and 100BASE-TX only:   Ethernet  straight-through cable : both ends of the cable use the same EIA/TIA pinout standard on each end of the cable. A straight-through cable is used when the devices on the ends of the cable use opposite pins when they transmit data.  Ethernet  crossover cable :  two devices both use the same pins to transmit and the pinouts of the cable are set up to swap the wire pair      Devices That Transmit on 1,2 and Receive on 3,6  Devices That Transmit on 3,6 and Receive on 1,2      PC NICs  Hubs    Routers  Switches    Wireless Access Point (Ethernet interface)  \u2014    Networked printers (printers that connect directly to the LAN)  \u2014     1000BASE-T Cabling  1000BASE-T differs from 10BASE-T and 100BASE-TX as far as the cabling and pinouts:   Reequires four wire pairs  Transmits and receives on each of the four wire pairs simultaneously  Has no concept of straight-through and crossover cables   Improving Performance by Using Switches Instead of Hubs  CSMA/CD logic helps prevent collisions and also defines how to act when a collision does occur:   A device with a frame to send listens until the Ethernet is not busy.  When the Ethernet is not busy, the sender(s) begin(s) sending the frame.  The sender(s) listen(s) to make sure that no collision occurred.  If a collision occurs, the devices that had been sending a frame each send a jamming signal to ensure that all stations recognize the collision.  After the jamming is complete, each sender randomizes a timer and waits that long before trying to resend the collided frame. When each random timer expires, the process starts over with Step 1.   Increasing Available Bandwidth Using Switches  The term  collision domain  defines the set of devices whose frames could collide. For example, all devices connected to the hub are in the same collision domain. To avoid collisions, and to recover when they occur, devices in the same collision domain use CSMA/CD.  Switches  significantly reduce, or even eliminate, the number of collisions on a LAN:   Switches interpret the bits in the received frame so that they can typically send the frame out the one required port, rather than all other ports  If a switch needs to forward multiple frames out the same port, the switch buffers the frames in memory, sending one at a time, thereby avoiding collisions   The switch\u2019s logic requires that the switch look at the Ethernet header, which is considered a Layer 2 feature. As a result, switches are considered to operate as a Layer 2 device, whereas hubs are Layer 1 devices.  Buffering (temporarily holds the frame in memory) also helps prevent collisions.  Switch features provide significant performance improvements:   If only one device is cabled to each port of a switch, no collisions can occur.  Devices connected to one switch port do not share their bandwidth with devices connected to another switch port. Each has its own separate bandwidth, meaning that a switch with 100-Mbps ports has 100 Mbps of bandwidth  per port .   Shared Ethernet vs. Switched Ethernet   Shared Ethernet : bandwidth is shared among the devices on the LAN because they must take turns using the LAN because of the CSMA/CD algorithm. A hub with 24 100-Mbps Ethernet devices connected to it allows for a theoretical maximum of 100 Mbps of bandwidth  Switched Ethernet : bandwidth does not have to be shared, allowing for far greater performance. A switch with 24 100-Mbps Ethernet devices connected to it supports 100 Mbps for each port, or 2400 Mbps (2.4 Gbps) theoretical maximum bandwidth.   Doubling Performance by Using Full-Duplex Ethernet  In an Ethernet network using hubs, CSMA/CD imposes  half-duplex  logic on each device, meaning that only one device can send at a time. LAN switches with only one device cabled to each port of the switch allow the use of  full-duplex  operation; Ethernet card can send and receive concurrently.  Ethernet Data-Link Protocols  Ethernet Addressing     LAN Addressing Term or Feature  Description      MAC  Media Access Control. 802.3 (Ethernet) defines the MAC sublayer of IEEE Ethernet.    Ethernet address, NIC address, LAN address  Other names often used instead of MAC address. These terms describe the 6-byte address of the LAN interface card.    Burned-in address  The 6-byte address assigned by the vendor making the card.    Unicast address  A term for a MAC that represents a single LAN interface.    Broadcast address  An address that means \u201call devices that reside on this LAN right now.\u201d (FFFF.FFFF.FFFF)    Multicast address  On Ethernet, a multicast address implies some subset of all devices currently on the Ethernet LAN. (0100.5exx.xxxx, any value can be used in the last half)     Ethernet Framing  Framing  defines the meaning of the bits transmitted and received over a network.    Data  field holds Layer 3 packets (L3 PDU)  Maximum transmission unit  (MTU) defines the maximum Layer 3 packet that can be sent over a medium. 1500 bytes is the largest IP MTU allowed over an Ethernet.   Identifying the Data Inside an Ethernet Frame  Type/Length  filed:   Length  field: with a value less than hex 0600 (decimal 1536); another field is needed to identify the type of L3 PDU inside the frame.  Type  field: value of hexadecimal 0800 (decimal 2048) implies an IP packet   Error Detection  Errors (bit changes) occur due to electrical interference. Trailer containing a  Frame Check Sequence  (FCS) field used for error detection.", 
            "title": "Chapter 3. Fundamentals of LANs"
        }, 
        {
            "location": "/icnd1/part1/#chapter-4-fundamentals-of-wans", 
            "text": "The WAN topics in this chapter describe mainly how enterprise networks use WANs to connect remote sites.  OSI Layer 1 for Point-to-Point WANs   Leased line  or  leased circuit : WAN cable, line or point-to-point connection that is paid for use  Telephone company (telco), or public telephone and telegraph (PTT)  Service provider : a company that provides any form of WAN connectivity, including Internet services.   Routers provide the capability to connect many different types of OSI Layer 1 and Layer 2 technologies. A router is connected to each end of a WAN connection.    Central Office (CO): a building where the telco locates the devices used to create its own network  Channel service unit/data service ( CSU/DSU )  demarc  ( demarcation point ): he point at which the telco\u2019s responsibility is on one side and the customer\u2019s responsibility is on the other  Customer premises equipment  (CPE): devices that are at the customer site   WAN Cabling Standards  [p84]  Clock Rates, Synchronization, DCE, and DTE  [p86]   Synchronization: various devices need to synchronize their clocks so that they run at exactly the same speed to make a link work  Data communications equipment (DCE): device that provides clocking, typically the CSU/DSU  Data terminal equipment (DTE): device receiving clocking, typically the router   Link Speeds     Name(s) of Line  Bit Rate      DS0  64 kbps    DS1 (T1)  1.544 Mbps (24 DS0s, plus 8 kbps overhead)    DS3 (T3)  44.736 Mbps (28 DS1s, plus management overhead)    E1  2.048 Mbps (32 DS0s)    E3  34.368 Mbps (16 E1s, plus management overhead)    J1 (Y1)  2.048 Mbps (32 DS0s; Japanese standard)     OSI Layer 2 for Point-to-Point WANs  HDLC   High-Level Data Link Control  (HDLC) defines framing to:   Delivers data across the link   Check for errors  Identify the packet type   Point-to-Point Protocol  Point-to-Point Protocol (PPP) behaves much like HDLC. The framing looks identical to the Cisco proprietary HDLC framing. PPP has become the most popular and feature-rich of WAN data link layer protocols. [p91]  Point-to-Point WAN Summary  WAN Terminology [p91-92]   Synchronous: The imposition of time ordering on a bit stream  Clock source: The device to which the other devices on the link adjust their speed when using synchronous links  CSU/DSU: Used on digital links as an interface to the telephone company in the United States. Routers typically use a short cable from a serial interface to a CSU/DSU, which is attached to the line from the telco  Telco  Four-wire circuit: A line from the telco with four wires, composed of two twisted-pair wires. Each pair is used to send in one direction, so a four-wire circuit allows full-duplex communication.  T1  E1   All the following terms may be used to refer to a point-to-point leased line:   leased line  leased circuit  link  serial link  serial line  point-to-point link  circuit   Frame Relay and Packet-Switching Services  Packet-switching service : a company can connect a large number of routers using a single serial link from each router into the packet-switching service. Once connected, each router can send packets to all the other routers\u2014much like all the devices connected to an Ethernet hub or switch can send data directly to each other.  Two types of packet-switching service are very popular today:   Frame Relay: much more common  Asynchronous Transfer Mode (ATM)", 
            "title": "Chapter 4. Fundamentals of WANs"
        }, 
        {
            "location": "/icnd1/part1/#chapter-5-fundamentals-of-ipv4-addressing-and-routing", 
            "text": "Routing: the process of forwarding packets (Layer 3 PDUs).  Logical addressing: enables the routing process to identify a packet\u2019s source and destination.  Routing protocol: aids routers by dynamically learning about the groups of addresses in the network, which in turn allows the routing (forwarding) process to work well.  Other utilities: The network layer also relies on other utilities: Domain Name System (DNS), Dynamic Host Configuration Protocol (DHCP), Address Resolution Protocol (ARP), and ping.   Path selection  sometimes is used to mean:   Routing protocol  Routing (forwarding) of packets   Overview of Network Layer Functions  Today, the only Layer 3 protocol that is used widely is the TCP/IP network layer protocol, specifically, IP.  IP does not require any overhead agreements or messages before sending a packet, making IP a connectionless protocol, with no error recovery.  Routing (Forwarding)  Routing focuses on the end-to-end logic of forwarding data.  The routing table for any particular network layer protocol contains a list of network layer address groupings. Instead of a single entry in the routing table per individual destination network layer address, there is one routing table entry per group.  Network Layer Interaction with the Data Link Layer  The routing process forwards the packet, and only the packet, end-to-end through the network, discarding data-link headers and trailers along the way.  Routers build new data-link headers and trailers and because the new headers contain data-link addresses, the PCs and routers must decide what data-link addresses to use. The Address Resolution Protocol (ARP) is used to dynamically learn the data-link address of an IP host connected to a LAN.  Routing as covered so far has two main concepts:   The process of routing forwards Layer 3 packets, also called Layer 3 protocol data units (L3 PDU), based on the destination Layer 3 address in the packet.  The routing process uses the data link layer to encapsulate the Layer 3 packets into Layer 2 frames for transmission across each successive data link.", 
            "title": "Chapter 5. Fundamentals of IPv4 Addressing and Routing"
        }, 
        {
            "location": "/icnd2/part1/", 
            "text": "Part I: LAN Switching\n\n\nChapter 1. Virtual LANs", 
            "title": "ICND2 Part I: LAN Switching"
        }, 
        {
            "location": "/icnd2/part1/#chapter-1-virtual-lans", 
            "text": "", 
            "title": "Chapter 1. Virtual LANs"
        }, 
        {
            "location": "/tcpv1/ch1/", 
            "text": "Chapter 1. Introduction\n\n\nSome terms [p1]:\n\n\n\n\nGateways\n: later called routers\n\n\nCatenet\n (\"concatenated\" network): obsolete term, later called internetwork\n\n\n\n\nThis chapter provides an overview of the Internet architecture and TCP/IP protocol suite.\n\n\nArchitectural Principles\n\n\nDesign and Implementation\n\n\nThe Architecture and Protocols of the TCP/IP Suite\n\n\nInternets, Intranets, and Extranets", 
            "title": "Chapter 1. Introduction"
        }, 
        {
            "location": "/tcpv1/ch2/", 
            "text": "Chapter 2. The Internet Address Architecture", 
            "title": "Chapter 2. The Internet Address Architecture"
        }, 
        {
            "location": "/tcpv1/ch10/", 
            "text": "Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation\n\n\nIP Fragmentation\n\n\nIP employs \nfragmentation\n and \nreassembly\n. Fragmentation in IPv4 can take place at the original sending host and at any intermediate routers along the end-to-end path. Note that datagram fragments can themselves be fragmented. Fragmentation in IPv6 is somewhat different because \nonly the source is permitted to perform fragmentation\n.\n\n\nWhen an IP datagram is fragmented, it is not reassembled until it reaches its final destination, because:\n\n\n\n\nNot performing reassembly within the network alleviates the forwarding software (or hardware) in routers from implementing this feature\n\n\nDifferent fragments of the same datagram may follow different paths to their common destination\n\n\n\n\nExample: UDP/IPv4 Fragmentation\n\n\nAn UDP application may wish to avoid IP fragmentation, because when the size of the resulting datagram exceeds the link\u2019s MTU, the IP datagram is split across multiple IP packets, which can lead to performance issues because \nif any fragment is lost, the entire datagram is lost.\n\n\n\n\nA single UDP datagram with 2992 UDP payload bytes is fragmented into three UDP/ IPv4 packets (no options). The UDP header that contains the source and destination port numbers appears only in the first fragment (a complicating factor for firewalls and NATs). Fragmentation is controlled by the \nIdentification\n, \nFragment Offset\n, and \nMore Fragments\n (MF) fields in the IPv4 header.\n\n\nThe original UDP datagram included 2992 bytes of application (UDP payload) data and 8 bytes of UDP header, resulting in an IPv4 Total Length field value of 3020 bytes (IP header is 20-byte). When this datagram was fragmented into three packets, 40 extra bytes were created (20 bytes for each of the newly created IPv4 fragment headers). Thus, the total number of bytes sent is 3060. [p489]\n\n\nFields:\n\n\n\n\nIdentification\n: its value (set by the original sender) is copied to each fragment and is used to group them together when they arrive\n\n\nFragment Offset\n: the offset of the first byte of the fragment payload byte in the original IPv4 datagram (in 8-byte units)\n\n\nMF\n: indicates whether more fragments in the datagram should be expected and is 0 only in the final fragment\n\n\n\n\nIf one fragment is lost, the entire datagram is lost, since IP itself has no error correction mechanism of its own. Mechanisms such as timeout and retransmission are left as the responsibility of the higher layers. \nFor this reason, fragmentation is often avoided.\n\n\nWe can use our \nsock\n program and increase the size of the datagram until fragmentation occurs. On an Ethernet, the maximum amount of data in a frame is ordinarily 1500 bytes, which leaves at most 1472 bytes for application data to avoid fragmentation, assuming 20 bytes for the IPv4 header and 8 bytes for the UDP header.\n\n\nWe will run our sock program with data sizes of 1471, 1472, 1473, and 1474 bytes. We expect the last two to cause fragmentation:\n\n\n[p490-492]\n\n\nLinux% sock -u -i -n1 -w1471 10.0.0.3 discard\nLinux% sock -u -i -n1 -w1472 10.0.0.3 discard \nLinux% sock -u -i -n1 -w1473 10.0.0.3 discard\nLinux% sock -u -i -n1 -w1474 10.0.0.3 discard\n\n\n\n\n1 23:42:43.562452 10.0.0.5.46530 \n 10.0.0.3.9:\n        udp 1471 (DF) (ttl 64, id 61350, len 1499)\n2 23:42:50.267424 10.0.0.5.46531 \n 10.0.0.3.9:\n        udp 1472 (DF) (ttl 64, id 62020, len 1500)\n3 23:42:57.814555 10.0.0.5 \n 10.0.0.3:\n        udp (frag 37671:1@1480) (ttl 64, len 21)\n4 23:42:57.814715 10.0.0.5.46532 \n 10.0.0.3.9:\n        udp 1473 (frag 37671:1480@0+) (ttl 64, len 1500)\n5 23:43:04.368677 10.0.0.5 \n 10.0.0.3:\n        udp (frag 37672:2@1480) (ttl 64, len 22)\n6 23:43:04.368838 10.0.0.5.46535 \n 10.0.0.3.9:\n        udp 1474 (frag 37672:1480@0+) (ttl 64, len 1500)\n\n\n\n\nOne observation that may be surprising is that the fragments with larger offsets are delivered \nprior\n to the first fragments. In effect, \nthe sender has intentionally reordered the fragments.\n This behavior can be beneficial. If the last fragment is delivered first, the receiving host is able to ascer- tain the maximum amount of buffer space it will require in order to reassemble the entire datagram.", 
            "title": "Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation"
        }, 
        {
            "location": "/tcpv1/headers/", 
            "text": "Headers\n\n\nIPv4 Header\n\n\n\n\nIPv6 Header\n\n\n\n\nUDP Header\n\n\n\n\nTCP Header", 
            "title": "Headers"
        }, 
        {
            "location": "/tcpv1/headers/#headers", 
            "text": "IPv4 Header   IPv6 Header   UDP Header   TCP Header", 
            "title": "Headers"
        }, 
        {
            "location": "/htae/", 
            "text": "Hacking: The Art of Exploitation, 2nd Edition\n\n\n0x200 Programming", 
            "title": "HTAE"
        }, 
        {
            "location": "/htae/#0x200-programming", 
            "text": "", 
            "title": "0x200 Programming"
        }, 
        {
            "location": "/golang/", 
            "text": "Golang\n\n\nStructs\n\n\nVisibility\n\n\nThe naming of the struct type and its fields adheres to the visibility rule. It is possible that an exported struct type has a mix of fields: some exported, others not.\n\n\nFactory methods\n\n\nForce using factory methods on a private type [TWTG p233]:\n\n\nwrong := new(matrix.matrix)    // will NOT compile (matrix is private)\nright := matrix.NewMatrix(...)   // the ONLY way to instantiate a matrix\n\n\n\n\nStructs with tags\n\n\nOnly the package \nreflect\n can access tag content. \nreflect.TypeOf()\n on a variable gives the right type; if this is a struct type, it can be indexed by \nField\n, and then the \nTag\n property can be used. For example:\n\n\n\n\nstruct_tag.go\n\n\n\n\nAnonymous fields and embedded structs\n\n\nConflicting names [TWTG p239]\n\n\n\n\nAn outer name hides an inner name. This provides a way to override a field or method.\n\n\nIf the same name appears twice at the same level, it is an error if the name is used by the program.\n\n\n\n\nMethods\n\n\n\n\nReceiver type\n\n\nMethod set: collection of all the methods on a given type \nT\n (or \n*T\n)\n\n\nNo method overloading\n\n\nA method and the type on which it acts must be defined in the same package\n\n\nPointer or value as receiver: if for a type \nT\n a method \nMeth()\n exists on \n*T\n and \nt\n is a variable of type \nT\n, then \nt.Meth()\n is automatically translated to \n(\nt).Meth()\n [TWTG p246]\n\n\n\n\nMethods on embedded types and inheritance\n\n\n\n\nOverriding: \nmethod4.go\n [TWTG p250]\n\n\nEmbedding multiple anonymous types\n\n\n\n\nEmbed functionality in a type\n\n\n\n\nAggregation (or composition): include a named field of the type of the wanted functionality\n\n\nEmbedding\n\n\n\n\nFormat specifiers\n\n\n\n\n%T\n: complete type specification\n\n\n%#v\n complete output of the instance with its fields\n\n\n\n\nInterfaces\n\n\nInterfaces in Go provide a way to specify the behavior of an object: if something can do this, then it can be used here.\n\n\n\n\nA type doesn\u2019t have to state explicitly that it implements an interface: interfaces are satisfied implicitly. Multiple types can implement the same interface.\n\n\nA type that implements an interface can also have other functions. \n\n\nA type can implement many interfaces.\n\n\nAn interface type can contain a reference to an instance of any of the types that implement the interface (an interface has what is called a dynamic type)\n\n\n\n\nThe interface variable both contains the value of the receiver instance and a pointer to the appropriate method in a method table.\n\n\n\n\ninterfaces_poly.go\n\n\n\n\nInterface embedding interfaces\n\n\nAn interface can contain the name of one or more other interface(s), which is equivalent to explicitly enumerating the methods of the embedded interface in the containing interface. [TWTG p270]\n\n\nDetect and convert the type of an interface variable: type assertions\n\n\nWe can test if \nvarI\n (interface variable) contains at a certain moment a variable of type \nT\n with the type assertion test [TWTG p271]:\n\n\nif v, ok := varI.(T); ok {\n    // checked type assertion\n}\n\n\n\n\n\n\ntype_interfaces.go\n\n\n\n\nThe type switch\n\n\n\n\nType switch\n\n\n\n\n\n\n\nTesting if a value implements an interface\n\n\nv\n is a value and we want to test whether it implements the \nStringer\n interface:\n\n\nif sv, ok := v.(Stringer); ok {\n    fmt.Printf(\u201cv implements String(): %s\\n\u201d, sv.String()); // note: sv, not v\n}\n\n\n\n\nWriting functions so that they accept an interface variable as a parameter makes them more general. Use interfaces to make code more generally applicable.\n\n\nUsing method sets with interfaces\n\n\n\n\nPointer methods can be called with pointers.\n\n\nValue methods can be called with values.\n\n\nValue-receiver methods can be called with pointer values because they can be dereferenced first.\n\n\nPointer-receiver methods \ncannot\n be called with values, however, because the value stored inside an interface has no address.\n\n\n\n\nExamples:\n\n\n\n\nmethodset2.go\n\n\nsort.go\n\n\nsortmain.go\n\n\n\n\nEmpty Interface\n\n\nA variable of empty interface type \ninterface{}\n can through assignment receive a variable of any type.\n\n\nInterface Slice\n\n\n\n\nInterface slice\n\n\n\n\nInterface to interface\n\n\nAn interface value can also be assigned to another interface value, as long as the underlying value implements the necessary methods. \n\n\n\n\n\nReflection\n\n\nReflection is the ability of a program to examine its own structure, particularly through the types; it\u2019s a form of \nmetaprogramming\n. \nreflect\n can be used to investigate types and variables at runtime, e.g. its size, its methods, and it can also call these methods \"dynamically\".\n\n\n\n\nreflect.TypeOf\n\n\nreflect.ValueOf\n\n\n\n\n\n\n\n\n\nv.Kind()\n: returns a constant indicating the type\n\n\nv.Interface()\n: recovers the (interface) value\n\n\n\n\nExample:\n\n\n\n\nreflect1.go\n\n\n\n\nSetting a value through reflection\n\n\n\n\nSettability\n: a \nValue\n can be changed only if it is addressable and was not obtained by the use of unexported struct fields.\n\n\n\n\n\n\nReferences\n\n\n\n\n[TWTG] \nThe Way To Go: A Thorough Introduction To The Go Programming Language\n\n\n[EG] \nEffective Go\n\n\n[TGB] \nThe Go Blog", 
            "title": "Go"
        }, 
        {
            "location": "/golang/#golang", 
            "text": "Structs  Visibility  The naming of the struct type and its fields adheres to the visibility rule. It is possible that an exported struct type has a mix of fields: some exported, others not.  Factory methods  Force using factory methods on a private type [TWTG p233]:  wrong := new(matrix.matrix)    // will NOT compile (matrix is private)\nright := matrix.NewMatrix(...)   // the ONLY way to instantiate a matrix  Structs with tags  Only the package  reflect  can access tag content.  reflect.TypeOf()  on a variable gives the right type; if this is a struct type, it can be indexed by  Field , and then the  Tag  property can be used. For example:   struct_tag.go   Anonymous fields and embedded structs  Conflicting names [TWTG p239]   An outer name hides an inner name. This provides a way to override a field or method.  If the same name appears twice at the same level, it is an error if the name is used by the program.   Methods   Receiver type  Method set: collection of all the methods on a given type  T  (or  *T )  No method overloading  A method and the type on which it acts must be defined in the same package  Pointer or value as receiver: if for a type  T  a method  Meth()  exists on  *T  and  t  is a variable of type  T , then  t.Meth()  is automatically translated to  ( t).Meth()  [TWTG p246]   Methods on embedded types and inheritance   Overriding:  method4.go  [TWTG p250]  Embedding multiple anonymous types   Embed functionality in a type   Aggregation (or composition): include a named field of the type of the wanted functionality  Embedding   Format specifiers   %T : complete type specification  %#v  complete output of the instance with its fields   Interfaces  Interfaces in Go provide a way to specify the behavior of an object: if something can do this, then it can be used here.   A type doesn\u2019t have to state explicitly that it implements an interface: interfaces are satisfied implicitly. Multiple types can implement the same interface.  A type that implements an interface can also have other functions.   A type can implement many interfaces.  An interface type can contain a reference to an instance of any of the types that implement the interface (an interface has what is called a dynamic type)   The interface variable both contains the value of the receiver instance and a pointer to the appropriate method in a method table.   interfaces_poly.go   Interface embedding interfaces  An interface can contain the name of one or more other interface(s), which is equivalent to explicitly enumerating the methods of the embedded interface in the containing interface. [TWTG p270]  Detect and convert the type of an interface variable: type assertions  We can test if  varI  (interface variable) contains at a certain moment a variable of type  T  with the type assertion test [TWTG p271]:  if v, ok := varI.(T); ok {\n    // checked type assertion\n}   type_interfaces.go   The type switch   Type switch    Testing if a value implements an interface  v  is a value and we want to test whether it implements the  Stringer  interface:  if sv, ok := v.(Stringer); ok {\n    fmt.Printf(\u201cv implements String(): %s\\n\u201d, sv.String()); // note: sv, not v\n}  Writing functions so that they accept an interface variable as a parameter makes them more general. Use interfaces to make code more generally applicable.  Using method sets with interfaces   Pointer methods can be called with pointers.  Value methods can be called with values.  Value-receiver methods can be called with pointer values because they can be dereferenced first.  Pointer-receiver methods  cannot  be called with values, however, because the value stored inside an interface has no address.   Examples:   methodset2.go  sort.go  sortmain.go   Empty Interface  A variable of empty interface type  interface{}  can through assignment receive a variable of any type.  Interface Slice   Interface slice   Interface to interface  An interface value can also be assigned to another interface value, as long as the underlying value implements the necessary methods.    Reflection  Reflection is the ability of a program to examine its own structure, particularly through the types; it\u2019s a form of  metaprogramming .  reflect  can be used to investigate types and variables at runtime, e.g. its size, its methods, and it can also call these methods \"dynamically\".   reflect.TypeOf  reflect.ValueOf     v.Kind() : returns a constant indicating the type  v.Interface() : recovers the (interface) value   Example:   reflect1.go   Setting a value through reflection   Settability : a  Value  can be changed only if it is addressable and was not obtained by the use of unexported struct fields.    References   [TWTG]  The Way To Go: A Thorough Introduction To The Go Programming Language  [EG]  Effective Go  [TGB]  The Go Blog", 
            "title": "Golang"
        }, 
        {
            "location": "/bash/", 
            "text": "Bash\n\n\n\n\nReferences\n\n\n\n\nThe GNU Bash Reference Manual\n\n\nBash Hackers Wiki", 
            "title": "Bash"
        }, 
        {
            "location": "/bash/#bash", 
            "text": "References   The GNU Bash Reference Manual  Bash Hackers Wiki", 
            "title": "Bash"
        }, 
        {
            "location": "/c/", 
            "text": "C\n\n\n\n\nIf you think like a computer, writing C actually makes sense. \n\n\n-- \nLinus Torvalds\n\n\n\n\nFirst-class ADT\n\n\nBad:\n\n\n/* Include guards and include files omitted. */\n\n#define MAX_NO_OF_ORDERS 42\n\n/* Internal representation of a customer. */\n\ntypedef struct\n\n{\n    const char* name;\n    Address address;\n    size_t noOfOrders;\n    Order orders[MAX_NO_OF_ORDERS];\n} Customer;\n\nvoid initCustomer(Customer* theCustomer,\n                  const char* name,\n                  const Address* address);\n\nvoid placeOrder(Customer *customer, const Order* order);\n\n/* A lot of other related functions... */\n\n\n\n\nGood:\n\n\n\n\n1_FirstClassADT\n\n\n\n\nInformation hiding\n\n\nThe First-class ADT pattern will eliminate dependency problems. Thuis pattern provides a method that separates interface from implementation.\n\n\nIncomplete Types\n\n\nThe C standard (C99) allows us to declare objects of incomplete types in a context where their sizes aren\u2019t needed. \n\n\nIn the following code:\n\n\n/* Pointer to an incomplete type */\ntypedef struct Customer* CustomerPtr;\n\n\n\n\nInstances of this pointer will serve as a handle for the clients of a first-class ADT. This mechanism enforces the constraint on clients to use the provided interface functions (\nCustomer.h\n) because there is no way a client can access a field in the \nCustomer\n structure (the C language \ndoes not allow an incomplete type to be de-referenced\n). The type is considered complete as soon as the compiler detects a subsequent specifier (\nCustomer.c\n), with the same tag, and a declaration list containing the members.\n\n\nCopy Semantics\n\n\nClients only use a handle, which is declared as a pointer, to the ADT. Copies of a handle are simply pointer assignment.\n\n\nDependencies managed\n\n\nInternals of the data structure are encapsulated in the implementation and clients cannot access them. \n\n\nConsequences\n\n\nPros:\n\n\n\n\nImproved encapsulation\n\n\nLoose coupling\n\n\nControlled construction and destruction\n\n\n\n\nCons:\n\n\n\n\nExtra level of indirection\n\n\nIncreased dynamic memory usage\n\n\n\n\n\n\nReferences\n\n\n\n\n[PIC]: \nPatterns in C", 
            "title": "C"
        }, 
        {
            "location": "/c/#c", 
            "text": "If you think like a computer, writing C actually makes sense.   --  Linus Torvalds   First-class ADT  Bad:  /* Include guards and include files omitted. */\n\n#define MAX_NO_OF_ORDERS 42\n\n/* Internal representation of a customer. */\n\ntypedef struct\n\n{\n    const char* name;\n    Address address;\n    size_t noOfOrders;\n    Order orders[MAX_NO_OF_ORDERS];\n} Customer;\n\nvoid initCustomer(Customer* theCustomer,\n                  const char* name,\n                  const Address* address);\n\nvoid placeOrder(Customer *customer, const Order* order);\n\n/* A lot of other related functions... */  Good:   1_FirstClassADT   Information hiding  The First-class ADT pattern will eliminate dependency problems. Thuis pattern provides a method that separates interface from implementation.  Incomplete Types  The C standard (C99) allows us to declare objects of incomplete types in a context where their sizes aren\u2019t needed.   In the following code:  /* Pointer to an incomplete type */\ntypedef struct Customer* CustomerPtr;  Instances of this pointer will serve as a handle for the clients of a first-class ADT. This mechanism enforces the constraint on clients to use the provided interface functions ( Customer.h ) because there is no way a client can access a field in the  Customer  structure (the C language  does not allow an incomplete type to be de-referenced ). The type is considered complete as soon as the compiler detects a subsequent specifier ( Customer.c ), with the same tag, and a declaration list containing the members.  Copy Semantics  Clients only use a handle, which is declared as a pointer, to the ADT. Copies of a handle are simply pointer assignment.  Dependencies managed  Internals of the data structure are encapsulated in the implementation and clients cannot access them.   Consequences  Pros:   Improved encapsulation  Loose coupling  Controlled construction and destruction   Cons:   Extra level of indirection  Increased dynamic memory usage    References   [PIC]:  Patterns in C", 
            "title": "C"
        }, 
        {
            "location": "/iptables/", 
            "text": "iptables\n\n\n\n\nReferences\n\n\n\n\n[ITT]: \nIptables Tutorial 1.2.2", 
            "title": "iptables"
        }, 
        {
            "location": "/iptables/#iptables", 
            "text": "References   [ITT]:  Iptables Tutorial 1.2.2", 
            "title": "iptables"
        }, 
        {
            "location": "/nginx/", 
            "text": "Nginx\n\n\n\n\nReferences\n\n\n\n\n[ND]: \nnginx documentation\n\n\n[NTAG]: \nNGINX and NGINX Plus Tutorial and Admin Guide", 
            "title": "Nginx"
        }, 
        {
            "location": "/nginx/#nginx", 
            "text": "References   [ND]:  nginx documentation  [NTAG]:  NGINX and NGINX Plus Tutorial and Admin Guide", 
            "title": "Nginx"
        }, 
        {
            "location": "/vim/", 
            "text": "Vim\n\n\n\n\nReferences\n\n\n\n\n[LVVE]: Learning the vi and Vim Editors, 7th Edition\n\n\n[LVHW]: \nLearn Vimscript the Hard Way", 
            "title": "Vim"
        }, 
        {
            "location": "/vim/#vim", 
            "text": "References   [LVVE]: Learning the vi and Vim Editors, 7th Edition  [LVHW]:  Learn Vimscript the Hard Way", 
            "title": "Vim"
        }
    ]
}